/*
 * Globus device code:          Copyright 2005 Northern Illinois University
 * Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
 * Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
 *
 * XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
 */

#include "mpidimpl.h"
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#if defined(HAVE_LIMITS_H)
#include <limits.h>
#endif
#if defined(HAVE_STDINT_H)
#include <stdint.h>
#endif

mpig_process_t mpig_process = {NULL, "(unknown)", -1, -1, -1, -1};


/* FIXME: the defintion of this array should be generated by configure based on a list of communication modules. */
MPIG_STATIC mpig_cm_t * const mpig_cm_table_array[] =
{
    &mpig_cm_self,
    &mpig_cm_vmpi,
#if TRUE && defined(HAVE_GLOBUS_XIO_MODULE)
    &mpig_cm_xio_net_san,
    &mpig_cm_xio_net_lan,
    &mpig_cm_xio_net_wan,
    &mpig_cm_xio_net_default,
#endif    
    &mpig_cm_other,
    NULL
};

mpig_cm_t * const * const mpig_cm_table = mpig_cm_table_array;
const int mpig_cm_table_num_entries = sizeof(mpig_cm_table_array) / sizeof(mpig_cm_t *) - 1;

            
/*
 * MPID_Init()
 */
#undef FUNCNAME
#define FUNCNAME MPID_Init
int MPID_Init(int * argc, char *** argv, int requested, int * provided, int * has_args, int * has_env)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    mpig_bc_t bc;
    char * lan_id = NULL;
    mpig_bc_t * bcs = NULL;
    mpig_pg_t * pg = NULL;
    bool_t pg_committed;
    const char * pg_id = NULL;
    bool_t pg_locked = FALSE;
    int pg_rank;
    int pg_size;
    MPID_Comm * comm;
    int n;
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_MPID_INIT);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_INIT);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "entering: requested=%d", requested));
    
    /* if vendor MPI is to be used, then initialize it */
#   if defined(MPIG_VMPI)
    {
	int vrc;

	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_PM, "initializing vendor MPI"));

	/* initialize the vendor MPI module */
	vrc = mpig_vmpi_init(argc, argv);
	MPIG_ERR_VMPI_CHKANDJUMP(vrc, "MPI_Init", &mpi_errno);
    }
#   endif
    
    /* initialize the device's process information structure */
    mpig_process_mutex_construct();
    mpig_process_mutex_lock();
    {
	/* get the operating system's process id for the local process */
	mpig_process.my_pid = getpid();

	/* get the name of the machine on which the local process is running */
#       if defined(HAVE_GETHOSTNAME)
	{
	    if(gethostname(mpig_process.my_hostname, (size_t) MPI_MAX_PROCESSOR_NAME) != 0)
	    {
		mpig_process.my_hostname[0] = '\0';
	    }
	}
#       else
	{
	    mpig_process.my_hostname[0] = '\0';
	}
#       endif
    }
    mpig_process_mutex_unlock();
    
    /* set the maximum size of a message tag.  a communication module may reduce this value if needed. */
    MPIR_Process.attrs.tag_ub = INT_MAX;

    /* activate globus modules */
#   if defined(HAVE_GLOBUS_COMMON_MODULE)
    {
	globus_result_t grc;
	
	globus_module_set_args(argc, argv);
    
	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ADI3, "activating globus common module"));
	grc = globus_module_activate(GLOBUS_COMMON_MODULE);
	MPIU_ERR_CHKANDJUMP2((grc), mpi_errno, MPI_ERR_OTHER, "**globus|module_activate", "**globus|module_activate %s %s",
	    "common", globus_error_print_chain(globus_error_peek(grc)));
	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ADI3, "globus common module activated"));
    }
#   endif
    
    /* initialize the request allocator module */
    mpig_request_alloc_init();
    
    /* initialize the receive queue */
    mpi_errno = mpig_recvq_init();
    MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|recvq_init");
    
    /* initialize the process management module which interfaces with globus */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ADI3, "initializing process management module"));
    mpi_errno = mpig_pm_init(argc, argv);
    MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|pm_init");
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ADI3, "processes management module initialized"));

    /* initialize the process group tracking subsystem */
    mpi_errno = mpig_pg_init();
    MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**dev|pg_init");

    /* initialize the communication methods */
    for (n = 0; n < mpig_cm_table_num_entries; n++)
    {
	mpig_cm_t * const cm = mpig_cm_table[n];
	
	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_CM | MPIG_DEBUG_LEVEL_CEMT, "initializing communication method: cm=" MPIG_PTR_FMT
	    ", cm_name", MPIG_PTR_CAST(cm), mpig_cm_get_name(cm)));

	mpi_errno = mpig_cm_get_vtable(cm)->init(cm, argc, argv);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|cm|init", "**globus|cm|init %s",
	    mpig_cm_get_name(cm));

	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_CM | MPIG_DEBUG_LEVEL_CEMT, "communication method initialization complete: cm="
	    MPIG_PTR_FMT ", cm_name", MPIG_PTR_CAST(cm), mpig_cm_get_name(cm)));
    }

    /* create and populate the buiness card with contact information from the communication modules */
    mpig_bc_construct(&bc);

    for (n = 0; n < mpig_cm_table_num_entries; n++)
    {
	mpig_cm_t * const cm = mpig_cm_table[n];
	if (mpig_cm_get_vtable(cm)->add_contact_info != NULL)
	{
	    mpi_errno = mpig_cm_get_vtable(cm)->add_contact_info(cm, &bc);
	    MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|cm|add_contact_info",
		"**globus|cm|add_contact_info %s", mpig_cm_get_name(cm));
	}
    }

    /* add the LAN identification string to the business card (if one is defined) */
    lan_id = getenv("MPIG_LAN_ID");
    if (lan_id == NULL)
    {
        lan_id = getenv("GLOBUS_LAN_ID");
    }
    if (lan_id != NULL)
    {
	mpi_errno = mpig_bc_add_contact(&bc, "MPIG_LAN_ID", lan_id);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|bc_add_contact",
	    "**globus|bc_add_contact %s", "MPIG_LAN_ID");
    }
    
    /* use the process management module to exchange the businesses cards and obtian information about the process group. */
    mpi_errno = mpig_pm_exchange_business_cards(&bc, &bcs);
    mpig_bc_destruct(&bc);
    MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|pm_xchg");
    
    mpig_pm_get_pg_id(&pg_id);
    mpig_pm_get_pg_size(&pg_size);
    mpig_pm_get_pg_rank(&pg_rank);
    mpig_pm_get_app_num(&bcs[pg_rank], &MPIR_Process.attrs.appnum);

    /* initialize the usage statistics module */
    mpig_usage_init();
    
    /* place a copy of the process group information in the process structure */
    mpig_process.my_pg_id = MPIU_Strdup(pg_id);
    mpig_process.my_pg_size = pg_size;
    mpig_process.my_pg_rank = pg_rank;
    
    /* now that we know the process group rank, initialize the debugging output module */
#   if defined(MPIG_DEBUG)
    {
	mpig_debug_init();
    }
#   endif

    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ADI3, "pid=%lu", (unsigned long) mpig_process.my_pid));
    
    /* acquire, creating if necessary, a reference to the process group object used to manage the virtual connection objects.  if
       creation was necessary, the virtual connection objects within the PG will be initialized at this time. */
    mpi_errno = mpig_pg_acquire_ref(pg_id, pg_size, TRUE, &pg, &pg_committed);
    MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|pg_acquire_ref");
    pg_locked = TRUE;
    {    
	mpig_vc_t * vc;
	bool_t vc_was_inuse;
	int p;

	/* stash away a pointer to my process group.  the PG reference count was already incremented by
	   mpig_pg_acquire_ref_and_lock().  it should be reduced again in MPID_Finalize() using mpig_pg_release(). */
	mpig_process.my_pg = pg;
	
	for (p = 0; p < pg_size; p++)
	{
#	    if (FALSE)
	    {
		MPIG_DEBUG_STMT(MPIG_DEBUG_LEVEL_BC,
		{
		    char * bc_str;
		    mpig_bc_serialize_object(&bcs[p], &bc_str);
		    mpig_debug_uprintf(MPIG_DEBUG_LEVEL_BC, "serialized BC for process %s:%d - %s\n", pg_id, p, bc_str);
		    mpig_bc_free_serialized_object(bc_str);
		});
	    }
#	    endif

	    mpig_pg_get_vc(pg, p, &vc);

	    mpig_vc_mutex_lock(vc);
	    {
		MPIU_Assert(mpig_vc_is_initialized(vc) == FALSE);
		
		/* stash a copy of the business card in the VC.  it will be used during the extraction of contact information,
		   and also by the MPI-2 dynamic process routines when an exchange of business cards is necessary. */
		mpi_errno = mpig_bc_copy(&bcs[p], mpig_vc_get_bc(vc));
		MPIU_ERR_CHKANDSTMT((mpi_errno), mpi_errno, MPI_ERR_OTHER, {goto vc_unlock;}, "**globus|bc_copy");

		/* extract the contact information from the business card contained within the VC object.  the information is
		   extracted from the business card because it is used each time a communicator is created to construct the
		   topology information.  since the gathering of data from the business card is not necessarily efficient, the
		   information is extract to once and store in a form more easily manipulated by the machine. */
		mpi_errno = mpig_vc_construct_contact_info(vc);
		MPIU_ERR_CHKANDSTMT2((mpi_errno), mpi_errno, MPI_ERR_OTHER, {goto vc_unlock;},
		    "**globus|vc_construct_contact_info", "**globus|vc_construct_contact_info %s %d", pg_id, pg_rank);
		/*
		 * select the communication method that will be used for each VC
		 *
		 * NOTE: since no barrier exists in the process management interface, some communication methods could be
		 * susceptible to receiving connection requests from remote processes before the VCs have been initialized.  for
		 * such communication methods, the cm->select_method() routine must take care not to blindly reinitialize
		 * internal fields of the VC, causing the existing connection to be corrupted or lost.
		 */
		mpi_errno = mpig_vc_select_comm_method(vc);
		MPIU_ERR_CHKANDSTMT2((mpi_errno), mpi_errno, MPI_ERR_OTHER, {goto vc_unlock;}, "**globus|vc_select_comm_method",
		    "**globus|vc_select_comm_method %s %d", pg_id, pg_rank);

		mpig_vc_set_initialized(vc, TRUE);

	      vc_unlock: ;
	    }
	    mpig_vc_mutex_unlock(vc);

	    if (mpi_errno) goto fn_fail;
	}
	/* end for (p = 0; p < pg_size; p++) */

	/* free the business card array provided by the process management subsystem */
	mpig_pm_free_business_cards(bcs);
	
	/* initialize the topology information module */
	mpi_errno = mpig_topology_init();
	MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|topology_init");
	
	/* initialize the communicator tracking module */
	mpi_errno = mpig_comm_init();
	MPIU_ERR_CHKANDJUMP((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**globus|comm_init");
	
	/* initialize the MPI_COMM_WORLD object */
	comm = MPIR_Process.comm_world;

	comm->rank = pg_rank;
	comm->remote_size = pg_size;
	comm->local_size = pg_size;
    
	mpi_errno = MPID_VCRT_Create(comm->remote_size, &comm->vcrt);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**dev|vcrt_create",
			     "**dev|vcrt_create %s", "MPI_COMM_WORLD");
    
	mpi_errno = MPID_VCRT_Get_ptr(comm->vcrt, &comm->vcr);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**dev|vcrt_get_ptr",
			     "**dev|vcrt_get_ptr %s", "MPI_COMM_WORLD");

	/* add each VC in the process group to the MPI_COMM_WORLD communicator and increment each VC's reference count */
	for (p = 0; p < pg_size; p++)
	{
	    mpig_pg_get_vc(pg, p, &vc);
	    mpig_vcrt_set_vc(comm->vcrt, p, vc);
	    mpig_vc_mutex_lock(vc);
	    {
		mpig_vc_inc_ref_count(vc, &vc_was_inuse);
		/* The VC reference should always be greater than zero before the increment since the PG module holds a reference
		   to it until the PG is committed */
		MPIU_Assert(vc_was_inuse);
	    }
	    mpig_vc_mutex_unlock(vc);
	}

	/* construction of the device fields must occur after the VCs have been added to the VCRT since topology discovery, which
	   is part of the constructio process, is performed as part of the construction process */
	mpig_comm_construct(comm);
	
	/* initialize the MPI_COMM_SELF object */
	comm = MPIR_Process.comm_self;

	comm->rank = 0;
	comm->remote_size = 1;
	comm->local_size = 1;
	
	mpi_errno = MPID_VCRT_Create(comm->remote_size, &comm->vcrt);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**dev|vcrt_create",
			     "**dev|vcrt_create %s", "MPI_COMM_SELF");
    
	mpi_errno = MPID_VCRT_Get_ptr(comm->vcrt, &comm->vcr);
	MPIU_ERR_CHKANDJUMP1((mpi_errno), mpi_errno, MPI_ERR_OTHER, "**dev|vcrt_get_ptr",
			     "**dev|vcrt_get_ptr %s", "MPI_COMM_SELF");
    
	/* add the VC representing the local process the MPI_COMM_SELF communicator and increment that VC's reference count */
	mpig_pg_get_vc(pg, pg_rank, &vc);
	mpig_vcrt_set_vc(comm->vcrt, 0, vc);
	mpig_vc_mutex_lock(vc);
	{
	    mpig_vc_inc_ref_count(vc, &vc_was_inuse);
	    /* The VC reference should always be greater than zero before the increment since the PG module holds a reference
	       to it until the PG is committed */
	    MPIU_Assert(vc_was_inuse);
	}
	mpig_vc_mutex_unlock(vc);

	/* construction of the device fields must occur after the VCs have been added to the VCRT since topology discovery, which
	   is part of the constructio process, is performed as part of the construction process */
	mpig_comm_construct(comm);
    }
    mpig_pg_mutex_unlock(pg);
    pg_locked = FALSE;

    /* now that all of the VCs have been activated and references to them established, commit the process group */
    if (pg != NULL)
    {
	mpig_pg_commit(pg);
    }

    /* if this process group was spawned by a MPI job, then form the MPI_COMM_PARENT inter-communicator */
#   if XXX
    {
	MPIU_Assert(has_parent == FALSE);
	/*
	 * - Get the (MPI) port of the parent
	 *
	 * - Perform a MPI_Comm_connect to the parent
	 *
	 * - Set MPIR_Process.comm_parent to the handle of the new inter-communicator
	 */
    }
#   endif
    
    /* set provided thread level */
    if (provided != NULL)
    {
	*provided = MPI_THREAD_FUNNELED;
    }

    /* indicate if the process management system has made the arguments or environment variables available */
    if (has_args != NULL)
    {
	*has_args = TRUE;
    }
    if (has_env != NULL)
    {
	*has_env = TRUE;
    }

  fn_return:
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "exiting: provided=%d, has_args=%s, has_env=%s, "
		       "mpi_errno=" MPIG_ERRNO_FMT, MPI_THREAD_FUNNELED, "true", "true", mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_INIT);
    return mpi_errno;

  fn_fail:
    /* --BEGIN ERROR HANDLING-- */
    {
	MPIR_Process.initialized = MPICH_PRE_INIT;

	/* clean up the process group structure */
	if (pg != NULL)
	{
	    mpig_pg_mutex_unlock_conditional(pg, pg_locked);
	    mpig_pg_release_ref(pg);
	}
    
	/* XXX: track progress and clean up and allocated resources such as the process group and VCRTs */

	mpig_request_alloc_finalize();
	
	goto fn_return;
    }
    /* --END ERROR HANDLING-- */
}
/* MPID_Init() */

/*
 * MPID_Finalize()
 */
#undef FUNCNAME
#define FUNCNAME MPID_Finalize
int MPID_Finalize()
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int n;
    int mrc;
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_MPID_FINALIZE);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_FINALIZE);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "entering"));

    mpig_usage_finalize();

    /* MPIR_Comm_free() is never called for MPI_COMM_WORLD and MPI_COMM_SELF, so the reference count is decremented and
       mpig_comm_free_hook() is called here to release the application reference to the predefined (builtin) communicators */
    MPIU_Object_release_ref(MPIR_Process.comm_world, &n);
    MPIU_Object_release_ref(MPIR_Process.comm_self, &n);
    mpig_comm_free_hook(MPIR_Process.comm_world);
    mpig_comm_free_hook(MPIR_Process.comm_self);

    /*
     * shutdown the communicator tracking module, waiting for all posted operations to complete on all communicators
     *
     * NOTE: applications that leave receive operation(s) unsatisfied will hang!  such an application is erroneous, and can be
     * corrected by canceling any such operations before calling MPI_Finalize().
     */
    mrc = mpig_comm_finalize();
    MPIU_ERR_CHKANDSTMT((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**globus|comm_finalize");
    
    /* release the virtual connection reference tables allocated in MPID_Init() and associated with MPI_COMM_WORLD and
       MPI_COMM_SELF */
    MPID_VCRT_Release(MPIR_Process.comm_world->vcrt);
    MPID_VCRT_Release(MPIR_Process.comm_self->vcrt);
    MPIR_Process.comm_world->vcrt = NULL;
    MPIR_Process.comm_self->vcrt = NULL;
    
    /* shutdown the topology information module */
    mrc = mpig_topology_finalize();
    MPIU_ERR_CHKANDSTMT((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**globus|topology_finalize");
    
    /* shutdown the communication methods.  each method is responsible for insuring that any VCs managed by it are disconnected
       before returning. */
    for (n = mpig_cm_table_num_entries - 1; n >= 0; n--)
    {
	mpig_cm_t * const cm = mpig_cm_table[n];
	mrc = mpig_cm_get_vtable(cm)->finalize(cm);
	MPIU_ERR_CHKANDSTMT1((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**globus|cm|finalize",
	    "**globus|cm|finalize %s", mpig_cm_get_name(cm));
    }
    
    /* release the reference to the process group associated with MPI_COMM_WORLD */
    mpig_pg_release_ref(mpig_process.my_pg);
    mpig_process.my_pg = NULL;
    
    /* shutdown the process group management module */
    mrc = mpig_pg_finalize();
    MPIU_ERR_CHKANDSTMT((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**dev|pg_finalize");

    /* shutdown the process management module */
    mrc = mpig_pm_finalize();
    MPIU_ERR_CHKANDSTMT((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**globus|pm_finalize");
    
    /* shutdown the receive queue module */
    mrc = mpig_recvq_finalize();
    MPIU_ERR_CHKANDSTMT((mrc), mrc, MPI_ERR_OTHER, {MPIU_ERR_ADD(mpi_errno, mrc);}, "**globus|recvq_finalize");
    
    /* shutdown the request allocator module */
    mpig_request_alloc_finalize();
    
    /* deactivate globus modules */
#   if defined(HAVE_GLOBUS_COMMON_MODULE)
    {
	globus_result_t grc;
	
	grc = globus_module_deactivate(GLOBUS_COMMON_MODULE);
	MPIU_ERR_CHKANDSTMT1((grc), mpi_errno, MPI_ERR_OTHER, {;}, "**globus|module_deactivate",
	    "**globus|module_deactivate %s", "common");
    }
#   endif

    /* destroy the device's process information structure */
    MPIU_Free(mpig_process.my_pg_id);
    mpig_process_mutex_destruct();

    MPIU_Assert(mpig_pe_active_ops_count == 0);
    
    /* shutdown the vendor MPI module */
#   if defined(MPIG_VMPI)
    {
	int vrc;
	
	vrc = mpig_vmpi_finalize();
	MPIG_ERR_VMPI_CHKANDSTMT(vrc, "MPI_Finalize", &mpi_errno, {;});
    }
#   endif

    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "exiting: mpi_errno=" MPIG_ERRNO_FMT, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_FINALIZE);
    return mpi_errno;
}
/* MPID_Finalize() */


/*
 * MPID_Abort()
 */
#undef FUNCNAME
#define FUNCNAME MPID_Abort
int MPID_Abort(MPID_Comm * const comm, const int mpi_errno, const int exit_code, const char * const error_msg)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    MPIG_STATE_DECL(MPID_STATE_MPID_ABORT);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_ABORT);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "entering: comm=" MPIG_PTR_FMT ", mpi_errno=" MPIG_ERRNO_FMT
		       ", exit_code=%d, error_msg=%s", MPIG_PTR_CAST(comm), mpi_errno, exit_code, MPIG_STR_VAL(error_msg)));

    fflush(stdout);
    fflush(stderr);
    
    if (mpi_errno)
    {
	char * str;
	
	str = (char *) MPIU_Malloc(MPIG_ERR_STRING_SIZE);
	if (str)
	{
	    MPIR_Err_get_string(mpi_errno, str, MPIG_ERR_STRING_SIZE, NULL);
	    fprintf(stderr, "[pgid=%s:pgrank=%d:tid=%lu] %s\n", mpig_process.my_pg_id, mpig_process.my_pg_rank,
		mpig_thread_get_id(), str);
	    fflush(stderr);
	    MPIU_Free(str);
	    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ERROR, "%s", str));
	}
	else
	{
	    fprintf(stderr, "[pgid=%s:pgrank=%d:tid=%lu] ERROR: unable to allocate memory needed to output an error message\n",
		mpig_process.my_pg_id, mpig_process.my_pg_rank, mpig_thread_get_id());
	    fflush(stderr);
	    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ERROR, "ERROR: unable to allocate memory needed to output an error message"));
	}
    }

    if (error_msg != NULL)
    {
	fprintf(stderr, "[pgid=%s:pgrank=%d:tid=%lu] %s\n", mpig_process.my_pg_id, mpig_process.my_pg_rank, mpig_thread_get_id(),
	    error_msg);
	fflush(stderr);
	MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ERROR, "%s", error_msg));
    }

    /* MPI-2-XXX: what do we do with jobs spawned by a communicator containing one or more processes in the aborting
       communicator?  do we abort those job as well or leave them running?  should we follow the unix model and terminate any
       child jobs if they are connected directly or indirectly to the processes in the aborting communicator (see the definition
       of connected in the MPI standard)?  conversely, should we permit jobs that are no longer connected to the processes in the
       aborting communicator to continue to run, much as unix would lets a daemon process continue to run even when the invoking
       program terminats?  if it is desirable to leave disconnected child jobs running, how do we determine that no process in
       the child job is (indirectly) connected to the processes in the aborting communicator? */

    /* contact GRAMs and cancel other subjobs, then cancel our own.  XXX: in an ideal universe, we would like a core file for the
       process initiating the abort, but there is a race condition between GRAM killing the process and the process reaching the
       call to the abort() function.  I'm not sure how to resolve this.  Perhaps there is a way to tell GRAM to send a SIGABRT to
       the job(s). */
    mpig_pm_abort(exit_code);
    abort();  /* just in case... */
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "exiting"));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_ABORT);
    return mpi_errno;
}
/* MPID_Abort() */


/*
 * MPID_Comm_spawn_multiple()
 */
#undef FUNCNAME
#define FUNCNAME MPID_Comm_spawn_multiple
int MPID_Comm_spawn_multiple(int count, char * array_of_commands[], char ** array_of_argv[], int array_of_maxprocs[],
			     MPID_Info * array_of_info_ptrs[], int root, MPID_Comm * comm_ptr, MPID_Comm ** intercomm,
			     int array_of_errcodes[]) 
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_MPID_COMM_SPAWN_MULTIPLE);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_COMM_SPAWN_MULTIPLE);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3 | MPIG_DEBUG_LEVEL_DYNAMIC, "entering"));

    MPIU_ERR_SETFATALANDSTMT1(mpi_errno, MPI_ERR_INTERN, {goto fn_fail;}, "**notimpl", "**notimpl %s", fcname);
    
  fn_return:
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3 | MPIG_DEBUG_LEVEL_DYNAMIC, "exiting"));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_COMM_SPAWN_MULTIPLE);
    return mpi_errno;

  fn_fail:
    /* --BEGIN ERROR HANDLING-- */
    goto fn_return;
    /* --END ERROR HANDLING-- */
}
/* MPID_Comm_spawn_multiple() */


/*
 * MPID_Get_processor_name()
 *
 * Returns the processor name.  Uses mpig_process.my_hostname, which is set in MPID_Init().
 */
#undef FUNCNAME
#define FUNCNAME MPID_Get_processor_name
int MPID_Get_processor_name(char * name, int name_len, int * resultlen)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int len;
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_MPID_GET_PROCESSOR_NAME);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_GET_PROCESSOR_NAME);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "entering"));

    len = (int) strlen(mpig_process.my_hostname);
    if (len > 0 && len < name_len)
    {
	MPIU_Strncpy(name, mpig_process.my_hostname, (size_t) name_len);
	*resultlen = len;
    }
    else
    {
	mpi_errno = MPI_ERR_UNKNOWN;
	goto fn_fail;
    }

  fn_return:
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "exiting"));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_GET_PROCESSOR_NAME);
    return mpi_errno;

  fn_fail:
    /* --BEGIN ERROR HANDLING-- */
    goto fn_return;
    /* --END ERROR HANDLING-- */
}
/* MPID_Get_processor_name() */


/*
 * MPID_Get_universe_size()
 */
#undef FUNCNAME
#define FUNCNAME MPID_Get_universe_size
int MPID_Get_universe_size(int  * universe_size)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_MPID_GET_UNIVERSE_SIZE);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_MPID_GET_UNIVERSE_SIZE);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "entering"));

    /* FIXME: someday we might want to allow the user to set an environment variable specifying the universe size, or have
       mpiexec compute it from a known hosts file, but for now set the size to "unavailable". */
    *universe_size = MPIR_UNIVERSE_SIZE_NOT_AVAILABLE;
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_ADI3, "exiting"));
    MPIG_FUNC_EXIT(MPID_STATE_MPID_GET_UNIVERSE_SIZE);
    return mpi_errno;
}
/* MPID_Get_universe_size() */


/*
 * MPID_GPID_Get([IN] comm, [IN] rank, [OUT] gpid[2])
 *
 * MPI-2-FIXME: THIS IS NOT RIGHT FOR MPI-2 FUNCTIONALITY!!!  gpid[0] needs to be unique to a process group.
 *
 * NOTE: for MPI-2 functionality, the global id needs to be bigger than an int.  We could hash the (host, pid(p0), etc.) tuple
 * into an int if necessary, but it would be better if the if were guaranteed to be unique.  for this, it seems best if the
 * device defined the data format.  the device could also define a matching MPI datatype that the upper layer could use for
 * communicating the ids.
 */
#undef FUNCNAME
#define FUNCNAME MPID_GPID_Get
int MPID_GPID_Get(MPID_Comm * comm, int rank, int gpid[])
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    const mpig_vc_t * const vc = mpig_comm_get_remote_vc(comm, rank);
    int mpi_errno = MPI_SUCCESS;

    MPIG_UNUSED_VAR(fcname);
    
    gpid[0] = 0;
    gpid[1] = mpig_vc_get_pg_rank(vc);

    return mpi_errno;
}
/* MPID_GPID_Get() */
