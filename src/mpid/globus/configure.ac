# 
# Globus device code:          Copyright 2005 Northern Illinois University
# Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
# Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
# 
# XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
# 

AC_INIT(configure.ac)

notice_msg=`echo "start of configure for the ${device_name} device" | tr '[a-z]' '[A-Z]'`
AC_MSG_NOTICE([----------------------------------------])
AC_MSG_NOTICE([$notice_msg])

#
# set the directory that contains support scripts such as install-sh and config.guess
#
AC_CONFIG_AUX_DIR(../../../confdb)

#
# definitions will be placed in mpidconf.h file rather than in the DEFS variable
#
cp ${srcdir}/mpidconf.h.in .
# echo "" >mpidconf-extras.h.in
# echo '/**** mpidconf-extras.h.in: generated by src/mpid/$device_name/configure ****/' >>mpidconf-extras.h.in
AC_CONFIG_HEADERS(mpidconf.h)

AC_DEFUN([LAH_TEMPLATE],[
    cat >>mpidconf.h.in <<_LACEOF

m4_text_wrap([$2 */], [   ], [/* ])
[@%:@undef] $1
_LACEOF
])

#
# save initial values of important variables
#
MPIG_SAVE_LIBS=${LIBS}

#
# configuration options
#
AC_ARG_ENABLE(mpig-threaded,
[--enable-mpig-threaded=package - enable use of threads within the MPIg device.
The following thread packages are supported.
    globus - Globus threads [only option if using Globus middleware]
    pthreads - POSIX threads [default if not using Globus middleware]
    none - MPIg device will not use threads],,enable_mpig_threaded=default)

#
# first check that we have a clean build if we are doing a VPATH build
#
PAC_VPATH_CHECK()

#
# load cached results computed in the top-level configure tests
#
PAC_LOAD_BASE_CACHE

#
# check for standard programs needed by the Makefile
#
AC_PROG_INSTALL
PAC_PROG_CHECK_INSTALL_WORKS
PAC_PROG_MKDIR_P
PAC_PROG_MAKE

#
# check for optional, but common C types
#
AC_CHECK_TYPES(bool bool_t)

#
# get sizes for intrinsic C types
#
AC_CHECK_SIZEOF(char)
AC_CHECK_SIZEOF(short)
AC_CHECK_SIZEOF(int)
AC_CHECK_SIZEOF(long)
AC_CHECK_SIZEOF(long long)
AC_CHECK_SIZEOF(float)
AC_CHECK_SIZEOF(double)
AC_CHECK_SIZEOF(long double)
AC_CHECK_SIZEOF(void *)

#
# create a mapping from integer types to printf integer conversion length modifiers
#
mpig_char_fmt_mod="hh"
mpig_unsigned_char_fmt_mod="hh"
mpig_short_fmt_mod="h"
mpig_unsigned_short_fmt_mod="h"
mpig_int_fmt_mod=""
mpig_unsigned_int_fmt_mod=""
mpig_long_fmt_mod="l"
mpig_unsigned_long_fmt_mod="l"
mpig_long_long_fmt_mod="ll"
mpig_unsigned_long_long_fmt_mod="ll"

#
# determine the unsigned integer type to which a pointer should be cast when doing a printf.  also get the corresponding printf
# conversion specifier.
#
AC_MSG_CHECKING([for an unsigned integer type big enough to hold a pointer])
MPIG_PTR_CAST=""
for mpig_type in "char" "short" "int" "long" "long long" ; do
    eval mpig_size="\${ac_cv_sizeof_`echo ${mpig_type} | tr '[ *]' [_p]`}"
    if test ${ac_cv_sizeof_void_p} -eq ${mpig_size} ; then
        MPIG_PTR_CAST="unsigned ${mpig_type}"
        break
    fi
done
if test -n "${MPIG_PTR_CAST}" ; then
   AC_MSG_RESULT([${MPIG_PTR_CAST}])
else
   AC_MSG_RESULT([unknown])
   AC_MSG_ERROR([unable to find an integer type big enough to hold a pointer!])
fi

AC_MSG_CHECKING([printf conversion specifier for a pointer])
eval MPIG_PTR_FMT="\"\\\"0x%0`expr ${ac_cv_sizeof_void_p} \* 2`\${mpig_`echo ${MPIG_PTR_CAST} | tr '[ *]' [_p]`_fmt_mod}x\\\"\""
AC_MSG_RESULT([${MPIG_PTR_FMT}])
dnl AC_DEFINE_UNQUOTED(MPIG_PTR_CAST,${MPIG_PTR_CAST:?},[an unsigned integer big enough to hold a pointer])
dnl AC_DEFINE_UNQUOTED(MPIG_PTR_FMT,${MPIG_PTR_FMT:?},[printf conversion specifier for a pointer converted to a MPIG_PTR_CAST])
AC_SUBST(MPIG_PTR_CAST)
AC_SUBST(MPIG_PTR_FMT)

#
# miscellaneous header and function checks
#
AC_CHECK_HEADERS(unistd.h limits.h stdint.h errno.h sched.h)
AC_CHECK_FUNCS(sched_yield yield nanosleep usleep sleep)

#
# check for functions needed to get a complete fully qualified host name
#
AC_CHECK_FUNCS(gethostname getdomainname)
if test "$ac_cv_func_gethostname" = "yes" ; then
    # do we need to declare gethostname?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],gethostname)
fi

#
# check for uuid generation packages
#
AC_CHECK_HEADERS(uuid/uuid.h)
AC_SEARCH_LIBS(uuid_generate, uuid)
AC_CHECK_FUNCS(uuid_generate uuid_parse uuid_unparse uuid_copy)

#
# determine this machine's endianess
#
AC_CACHE_CHECK([endianess of system],
lac_cv_my_endian,[
AC_RUN_IFELSE([
AC_LANG_SOURCE([
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
    int data;
    char * datap = (char *) &data;
    FILE *f;

    f = fopen("conftest.out", "w");
    data = 10;
    if (*datap == 10)
    {
        fprintf(f, "little\n");
    }
    else if (*(datap + sizeof(int) - 1) == 10)
    {
        fprintf(f, "big\n");
    }
    else
    {
        fprintf(f, "undetermined\n");
    }

    fclose(f);
    exit(0);
}
])
],lac_cv_my_endian=`cat conftest.out`,
  lac_cv_my_endian="FAILED",
  lac_cv_my_endian=${CROSS_MY_ENDIAN:-undetermined})
])

if test "$lac_cv_my_endian" = "big" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_BIG"
elif test "$lac_cv_my_endian" = "little" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_LITTLE"
else
    AC_MSG_ERROR([Unable to determine endianess of system.  If cross compiling, set CROSS_MY_ENDIAN to "big" or "little".])
fi
AC_DEFINE_UNQUOTED(MPIG_MY_ENDIAN,${MPIG_MY_ENDIAN},[endianess of the system])

#
# determine if threads are to be used internally and which threads package will be used
#
if test -z "${MPIG_THREADED}" ; then
    case ${enable_mpig_threaded} in
	posix|pthread|pthreads|yes)
	MPIG_THREADS_PKG=posix
	MPIG_THREADED=yes
	;;
	default|no|none)
	MPIG_THREADS_PKG=
	MPIG_THREADED=no
	;;
	*)
	AC_MSG_ERROR([The threads package "${enable_mpig_threaded}" is not known to the ${device_name} device.  Please select another package.])
	;;
    esac
elif test "${enable_mpig_threaded}" = "yes" -a "${MPIG_THREADED}" = "no" ; then
    AC_MSG_ERROR([The selected Grid Middleware package (${MPIG_GRID_PKG_NAME}) is not thread safe; however, the --enable-mpig-threaded option was passed to configure.  Please remove the option or select a middleware package that is thread safe.])
elif test "${enable_mpig_threaded}" = "no" -a "${MPIG_THREADED}" = "yes" ; then
    AC_MSG_ERROR([The selected Grid Middleware package (${MPIG_GRID_PKG_NAME}) requires threads; however, the --disable-mpig-threaded option was passed to configure.  Please remove the option or select a middleware package that does not require threads.])
elif test "${enable_mpig_threaded}" != "default" -a "${enable_mpig_threaded}" != "${MPIG_THREADS_PKG}" ; then
    AC_MSG_ERROR([The threads "${MPIG_THREADS_PKG} package is required by the selected Grid Middleware (${MPIG_GRID_PKG_NAME}); however, the --enable-mpig-threaded=${enable_mpig_threaded} option was passed to configure specified a different package.  Please remove the option or select a middleware package that is compatible with the specified threads package.])
fi
if test "${MPIG_THREADED}" = "yes" ; then
    AC_DEFINE(MPIG_THREADED,1,[define if MPIg is allowed to use threads internally])
fi 
if test -n "${MPIG_THREADS_PKG}" ; then
    mpig_define_name="HAVE_`echo ${MPIG_THREADS_PKG} | tr '[a-z- ]' '[A-Z__]'`_THREADS"
    LAH_TEMPLATE([${mpig_define_name}], [threads package to be used internally by MPIg])
    AC_DEFINE_UNQUOTED([${mpig_define_name}], 1)
fi

if test "${MPIG_THREADS_PKG}" = "posix" ; then
    AC_CHECK_HEADERS(pthread.h)
    AC_CHECK_FUNCS(pthread_yield)
    if test "$ac_cv_func_pthread_yield" = "yes" ; then
        PAC_FUNC_NEEDS_DECL([#include <pthread.h>],pthread_yield)
    fi
fi

#
# determine if C compiler supports function inlining
#
AC_C_INLINE
if test "$ac_cv_c_inline" != "no" ; then
    AC_DEFINE(HAVE_C_INLINE,1,[define if the C compiler supports function inlining])
fi

#
# determine the size of MPICH2's MPI_AINT, and the printf conversion specifers for MPI_Aint and MPIU_Size_t
#
AC_MSG_CHECKING([size of MPICH2 MPI_AINT])
eval SIZEOF_MPICH2_AINT="\${SIZEOF_`echo ${MPI_AINT} | tr '[a-z]' '[A-Z]'`}"
AC_MSG_RESULT([$SIZEOF_MPICH2_AINT])
AC_DEFINE_UNQUOTED(TYPEOF_MPICH2_AINT,${MPI_AINT:?},[integer type of the same size as the MPICH2 MPI_Aint type])
AC_DEFINE_UNQUOTED(SIZEOF_MPICH2_AINT,${SIZEOF_MPICH2_AINT:?},[size of the MPICH2 MPI_Aint type])

AC_MSG_NOTICE([INFO: MPI_Aint is "${MPI_AINT}"])
AC_MSG_CHECKING([printf conversion specifier for MPI_Aint])
eval MPIG_AINT_FMT="\"\\\"%\${MPIG_`echo ${MPI_AINT} | tr ' *' '_p'`_fmt_mod}d\\\"\""
dnl AC_DEFINE_UNQUOTED(MPIG_AINT_FMT,${MPIG_AINT_FMT:?},[printf conversion specifier for MPI_Aint])
AC_SUBST(MPIG_AINT_FMT)
AC_MSG_RESULT([$MPIG_AINT_FMT])

AC_MSG_NOTICE([INFO: MPIU_Size_t is "${MPIU_SIZE_T}"])
AC_MSG_CHECKING([printf conversion specifier for MPIU_Size_t])
eval MPIG_SIZE_FMT="\"\\\"%\${MPIG_`echo ${MPIU_SIZE_T} | tr ' *' '_p'`_fmt_mod}u\\\"\""
dnl AC_DEFINE_UNQUOTED(MPIG_SIZE_FMT,${MPIG_SIZE_FMT:?},[printf conversion specifier for MPIU_Size_t])
AC_SUBST(MPIG_SIZE_FMT)
AC_MSG_RESULT([$MPIG_SIZE_FMT])

#
# determine if CPP supports variadic macros
#
AC_CACHE_CHECK([whether CPP accepts C99 style variadic macros],
lac_cv_have_c99_variadic_macros,[
AC_COMPILE_IFELSE([
AC_LANG_SOURCE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, ...)  printf("%d: " fmt, rank, ## __VA_ARGS__)
int main(int argc, char ** argv)
{
    MY_PRINTF(0, "hello");
    MY_PRINTF(1, "world %d", 3);
    return 0;
}
])
], lac_cv_have_c99_variadic_macros=yes, lac_cv_have_c99_variadic_macros=no)
])
if test $lac_cv_have_c99_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_C99_VARIADIC_MACROS,,[define if CPP supports C99 style variadic macros])
fi

AC_CACHE_CHECK([whether CPP accepts GNU style variadic macros],
lac_cv_have_gnu_variadic_macros,[
AC_COMPILE_IFELSE([
AC_LANG_SOURCE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, args...)  printf("%d: " fmt, rank, ## args)
int main(int argc, char ** argv)
{
    MY_PRINTF(0, "hello");
    MY_PRINTF(1, "world %d", 3);
    return 0;
}
])
], lac_cv_have_gnu_variadic_macros=yes, lac_cv_have_gnu_variadic_macros=no)
])
if test $lac_cv_have_gnu_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_GNU_VARIADIC_MACROS,,[define if CPP supports GNU style variadic macros])
fi

#
# determine if the compiler defines a symbol containing the function name
#
AC_CACHE_CHECK([whether the compiler defines __func__],
lac_cv_have__func__,[
AC_RUN_IFELSE([
AC_LANG_SOURCE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__func__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
])
], lac_cv_have__func__=yes, lac_cv_have__func__=no)
])
if test $lac_cv_have__func__ = "yes" ; then
    AC_DEFINE(HAVE__FUNC__,,[define if the compiler defines __func__])
fi

AC_CACHE_CHECK([whether the compiler defines __FUNC__],
lac_cv_have_cap__func__,[
AC_RUN_IFELSE([
AC_LANG_SOURCE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNC__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
])
], lac_cv_have_cap__func__=yes, lac_cv_have_cap__func__=no)
])
if test $lac_cv_have_cap__func__ = "yes" ; then
    AC_DEFINE(HAVE_CAP__FUNC__,,[define if the compiler defines __FUNC__])
fi

AC_CACHE_CHECK([whether the compiler sets __FUNCTION__],
lac_cv_have__function__,[
AC_RUN_IFELSE([
AC_LANG_SOURCE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNCTION__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
])
], lac_cv_have__function__=yes, lac_cv_have__function__=no)
])
if test $lac_cv_have__function__ = "yes" ; then
    AC_DEFINE(HAVE__FUNCTION__,,[define if the compiler defines __FUNCTION__])
fi

#
# m4 macros to acquire information from the vendor MPI
#
AC_DEFUN([LAC_CHECK_C_VMPI_FUNC],
[
m4_pushdef([lac_upper_varname], m4_translit([HAVE_C_V$1], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$1], [A-Z], [a-z]))
AC_CACHE_CHECK([for the vendor MPI function $1 (C binding)], lac_lower_varname, [
SAVE_MPIG_CONFIGURE_ACTIVE=${MPIG_CONFIGURE_ACTIVE}
MPIG_CONFIGURE_ACTIVE=""
AC_LINK_IFELSE([
AC_LANG_SOURCE([
void $1(float * a);
int main(int argc, char *argv[[]])
{
    void (*func)(float * a) = $1;
    float a = 1.0;
    func(&a);
    return 0;
}
], lac_lower_varname=yes, lac_lower_varname=no)
])
MPIG_CONFIGURE_ACTIVE=${SAVE_MPIG_CONFIGURE_ACTIVE}
])
if test ${lac_lower_varname} = "yes" ; then
    AC_DEFINE_UNQUOTED(lac_upper_varname, 1, [define if the vendor MPI provides the function $1])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_varname])
])

AC_DEFUN([LAC_CHECK_C_VMPI_CONSTANT],
[
m4_pushdef([lac_upper_varname], m4_translit([HAVE_C_V$2], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$2], [A-Z], [a-z]))
AC_CACHE_CHECK([for the vendor MPI constant $2 (C binding)], lac_lower_varname, [
SAVE_MPIG_CONFIGURE_ACTIVE=${MPIG_CONFIGURE_ACTIVE}
MPIG_CONFIGURE_ACTIVE=""
AC_COMPILE_IFELSE([
AC_LANG_SOURCE([
#include "mpi.h"
void func($1 a);
int main(int argc, char *argv[[]])
{
    $1 a = $2;
    func(a);
    return 0;
}
])
], lac_lower_varname=yes, lac_lower_varname=no)
MPIG_CONFIGURE_ACTIVE=${SAVE_MPIG_CONFIGURE_ACTIVE}
])
if test ${lac_lower_varname} = "yes" ; then
    AC_DEFINE_UNQUOTED(lac_upper_varname, 1, [define if the the vendor MPI provides the constant $2])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_varname])
])

AC_DEFUN([LAC_GET_VMPI_TYPE_FORMAT],
[
m4_pushdef([lac_upper_type], m4_translit([V$1], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_fmt_v$1], [A-Z], [a-z]))
AC_CACHE_CHECK([printf conversion specifier for vendor $1], lac_lower_varname, [
if test "${[TYPEOF_]lac_upper_type[_IS_BASIC]}" = "yes" ; then
    lac_fmt_mod_varname='mpig_'${[TYPEOF_]lac_upper_type}'_fmt_mod'
    eval lac_fmt_mod='${'${lac_fmt_mod_varname}'}'
    lac_lower_varname="\"0x%0`expr 2 \* ${[SIZEOF_]lac_upper_type}`${lac_fmt_mod}x\""
    unset lac_fmt_mod_varname
    unset lac_fmt_mod
else
    lac_lower_varname="not basic!"
fi
])
if test "${lac_lower_varname}" != "not basic!" ; then
    AC_DEFINE_UNQUOTED([FMT_]lac_upper_type, ${lac_lower_varname}, [printf conversion specifier for vendor $1 handle])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_type])
])

#
# vendor MPI
#
if test "${MPIG_VMPI:?}" != "no" ; then
    # vendor MPI settings from mpich2prereq
    AC_DEFINE(MPIG_VMPI,1,[define if we are building on top of a vendor MPI])

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_COMM,${SIZEOF_VMPI_COMM:?},[size of the vendor MPI_Comm handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_COMM, ${TYPEOF_VMPI_COMM:?}, [C type equivalent to a vendor MPI_Comm handle])
    if test "${TYPEOF_VMPI_COMM_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_COMM_IS_BASIC, 1, [define if TYPEOF_VMPI_COMM is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Comm)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_DATATYPE,${SIZEOF_VMPI_DATATYPE:?},[size of the vendor MPI_Datatype handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_DATATYPE, ${TYPEOF_VMPI_DATATYPE:?}, [C type equivalent to a vendor MPI_Datatype handle])
    if test "${TYPEOF_VMPI_DATATYPE_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_DATATYPE_IS_BASIC, 1, [define if TYPEOF_VMPI_DATATYPE is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Datatype)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_OP,${SIZEOF_VMPI_OP:?},[size of the vendor MPI_Op object])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_OP, ${TYPEOF_VMPI_OP:?}, [C type equivalent to a vendor MPI_Op handle])
    if test "${TYPEOF_VMPI_OP_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_OP_IS_BASIC, 1, [define if TYPEOF_VMPI_OP is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Op)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_REQUEST,${SIZEOF_VMPI_REQUEST:?},[size of the vendor MPI_Request handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_REQUEST, ${TYPEOF_VMPI_REQUEST:?}, [C type equivalent to a vendor MPI_Request handle])
    if test "${TYPEOF_VMPI_REQUEST_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_REQUEST_IS_BASIC, 1, [define if TYPEOF_VMPI_REQUEST is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Request)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_STATUS,${SIZEOF_VMPI_STATUS:?},[size of the vendor MPI_Status object])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_STATUS, ${TYPEOF_VMPI_STATUS:?}, [C type equivalent to a vendor MPI_Status handle])
    if test "${TYPEOF_VMPI_STATUS_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_STATUS_IS_BASIC, 1, [define if TYPEOF_VMPI_STATUS is a basic C type])
    fi
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_AINT,${SIZEOF_VMPI_AINT:?},[size of the vendor MPI_Aint type])

    # determine if the vendor MPI supports MPI-2 functionality
    LAC_CHECK_C_VMPI_FUNC(MPI_Comm_get_attr)
    LAC_CHECK_C_VMPI_FUNC(MPI_Comm_set_errhandler)
    LAC_CHECK_C_VMPI_FUNC(MPI_Init_thread)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_dup)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_hvector)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_hindexed)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_indexed_block)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_resized)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_struct)

    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_DOUBLE)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_DOUBLE_INT)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_LONG)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_LONG_INT)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_UNSIGNED_LONG_LONG)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_SIGNED_CHAR)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_WCHAR)

    # determine which, if any, of the Fortran datatype handles are defined in the C header file
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER)
    if test "$lac_cv_have_c_vmpi_integer" = "yes" ; then
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER1)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER2)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER4)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER8)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_INTEGER16)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_REAL4)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_REAL8)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_REAL16)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_COMPLEX8)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_COMPLEX16)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_COMPLEX32)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_DOUBLE_COMPLEX)
        LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_2DOUBLE_COMPLEX)

        AC_DEFINE(HAVE_F77_VMPI_DATATYPES_IN_C,1,[define if the vendor MPI defines Fortran datatypes in its C binding])
    else
        # FIXME: if the Fortran datatype handles are not defined in the C header file, then we will need to jump through some
        # hoops when mirroring the construction of datatypes that involve Fortran handles.  this problem likely also exists for
        # other bindings like C++ for which the MPI-2 assigns handles for boolean and complex types.  MPI-2 provides a mechanism
        # for converting handles from one language to another, but MPI-1 does not.  this could get very complicated...
        AC_MSG_FAILURE(
            [MPIg requires the vendor MPI to define the datatype handles for all language bindings in the C header file])
    fi

    LAC_CHECK_C_VMPI_CONSTANT(MPI_Op, MPI_REPLACE)

    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_ACCESS)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_AMODE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_ASSERT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_BAD_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_BASE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_CONVERSION)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_DISP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_DUP_DATAREP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE_EXISTS)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE_IN_USE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_KEY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_NOKEY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_VALUE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_IO)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_KEYVAL)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_LOCKTYPE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NAME)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NOT_SAME)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_MEM)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_SPACE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_SUCH_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_PORT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_QUOTA)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_READ_ONLY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_RMA_CONFLICT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_RMA_SYNC)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SERVICE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SIZE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SPAWN)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_UNSUPPORTED_DATAREP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_UNSUPPORTED_OPERATION)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_WIN)

    AC_CACHE_CHECK([version of the MPI standard implemented by the vendor MPI],
    lac_cv_vmpi_version,[
        AC_RUN_IFELSE([
        AC_LANG_SOURCE([
        #include "mpi.h"
        #include <stdio.h>
        int main(int argc, char *argv[[]])
        {
            FILE * fp = fopen("conftest.out","w");
            fprintf(fp, "%d\n", MPI_VERSION);
            close(fp);
            return 0;
        }
        ])
        ], lac_cv_vmpi_version=`cat conftest.out`, lac_cv_vmpi_version=0)
    ])

    AC_DEFINE_UNQUOTED(MPIG_VMPI_VERSION,${lac_cv_vmpi_version},
        [define with the MPI standard version implemented by the vendor MPI])

    #
    # if the vendor MPI does not implement the MPI-2 standard, then it is possible that it also does not support passing NULL in
    # place of the command line arguments.  in that case, we must provide an alternative main() that first calls MPI_Init and
    # calls the application's main().  see comments in mpig_vmpi_premain.c for additional details.
    #
    if test -z "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" ; then
        if test ${lac_cv_vmpi_version} -lt 2 ; then
	    MPIG_VMPI_PREMAIN_LIBS_REQUIRED=yes
        else
	    MPIG_VMPI_PREMAIN_LIBS_REQUIRED=no
        fi
    fi

    if test "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" = "yes" ; then
        AC_DEFINE(MPIG_VMPI_PREMAIN_REQUIRED,1,
		[define if MPIg must initialize the vendor MPI before the main routine of the application is called])
        for c in cc cxx ; do
	    cnu=`echo ${c} | tr '[a-z]' '[A-Z]'`
	    cf=mpich2-grid-${c}
	    premain_lib="libmpig_vmpi_premain_${c}.a"
            if test -f ${cf} ; then
                AC_MSG_NOTICE([Updating the paths in the MPIg compiler script ${cf}])
                mv ${cf} ${cf}.orig
                sed -e 's!^\(MPIG_VMPI_PREMAIN_LIB\)=.*!\1="'"${MPIG_BUILD_DIR}/${premain_lib}"'"!' ${cf}.orig >${cf}
                chmod 755 ${cf}
                rm -f ${cf}.orig
		eval MPIG_VMPI_PREMAIN_${cnu}_LIB=${premain_lib}
            fi
        done
    fi

    MPIG_VMPI_DEFINED=1

else # no vendor MPI

    MPIG_VMPI_DEFINED=0
fi

AC_SUBST(MPIG_VMPI)
AC_SUBST(MPIG_VMPI_DEFINED)
AC_SUBST(MPIG_VMPI_PREMAIN_CC_LIB)
AC_SUBST(MPIG_VMPI_PREMAIN_CXX_LIB)
# end of vendor MPI section

#
# miscellaneous settings from mpich2prereq
#
dnl AC_DEFINE_UNQUOTED(MPIG_USING_GRID_PKG,"${MPIG_USING_GRID_PKG:?}",[Grid middleware being used by MPIg])

AC_SUBST(MPIG_SOURCE_DIR)
AC_SUBST(MPIG_BUILD_DIR)

AC_DEFINE_UNQUOTED(MPIG_MPICH2_VERSION,"${MPIG_MPICH2_VERSION:?}",[MPICH2 version])

if test "${MPIG_DEBUG:?}" = "yes" ; then
    AC_DEFINE(MPIG_DEBUG,1,[define if MPIg should include debugging output and checks])
    MPIG_DEBUG_DEFINED=1
else
    MPIG_DEBUG_DEFINED=0
fi
AC_SUBST(MPIG_DEBUG_DEFINED)

dnl AC_DEFINE_UNQUOTED(TYPEOF_MPIG_ALIGNED_T,${TYPEOF_MPIG_ALIGNED_T:?},[type to use insure proper memory alignment for all types])
dnl AC_DEFINE_UNQUOTED(SIZEOF_MPIG_ALIGNED_T,${SIZEOF_MPIG_ALIGNED_T:?},[size of the type used for aligning memory accesses])
dnl AC_DEFINE_UNQUOTED(MEMALIGN_MPIG_ALIGNED_T,${MEMALIGN_MPIG_ALIGNED_T:?},[memory alignment of MPIG_ALIGNED_T])

if test "${MPIG_ROMIO_ENABLED:?}" = "yes" ; then
    ROMIO_ENABLED=1
else
    ROMIO_ENABLED=0
fi
AC_SUBST(ROMIO_ENABLED)

#
# Globus settings from mpich2prereq
#
if test "${MPIG_USING_GRID_PKG}" = "globus" ; then
    if test "${HAVE_GLOBUS_COMMON_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_COMMON_MODULE,1,[define if the Globus Common module is installed])
    fi

    if test "${HAVE_GLOBUS_DC_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_DC_MODULE,1,[define if the Globus Common module is installed])
    fi

    if test "${HAVE_GLOBUS_USAGE_MODULE:?}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_USAGE_MODULE,1,[define if Globus Usage module is installed])
        AC_DEFINE_UNQUOTED(HAVE_GLOBUS_USAGE_VERSION,"${HAVE_GLOBUS_USAGE_VERSION:?}",[Globus Usage module version])
    fi

    if test "${HAVE_GLOBUS_DUROC_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_DUROC_MODULE,1,[define if the Globus DUROC Runtime module is installed])
    fi

    if test "${HAVE_GLOBUS_RENDEZVOUS_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_RENDEZVOUS_MODULE,1,[define if the Globus Rendezvous Client C bindings module is installed])
    fi

    if test "${HAVE_GLOBUS_XIO_MODULE:?}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_XIO_MODULE,1,[define if Globus XIO module is installed])
        AC_DEFINE_UNQUOTED(HAVE_GLOBUS_XIO_VERSION,"${HAVE_GLOBUS_XIO_VERSION:?}",[Globus XIO module version])
    fi

    # since mpich2preq-globus sets MPIG_THREADS_PKG to globus, HAVE_GLOBUS_THREADS is automatically defined above in the
    # section on thread packages
    #
    # if test "${HAVE_GLOBUS_THREADS}" = "yes" ; then
    #     AC_DEFINE(HAVE_GLOBUS_THREADS,1,[define if the flavor of Globus being used is multithreaded])
    # fi
fi

#
# setup file substitutions needed to create mpiddefs.h
#
if test "${MPIG_RENAME_SYMBOLS:?}" = "yes" ; then
    MPIG_SYMBOL_MAP_PUBLIC_H=.mpig_symbol_map_public.h
    MPIG_SYMBOL_MAP_INTERNAL_H=.mpig_symbol_map_internal.h
    AC_DEFINE(MPIG_RENAME_SYMBOLS,1,[define if MPI symbols need to be renamed])
    MPIG_RENAME_SYMBOLS_DEFINED=1
else
    MPIG_SYMBOL_MAP_PUBLIC_H=/dev/null
    MPIG_SYMBOL_MAP_INTERNAL_H=/dev/null
    MPIG_RENAME_SYMBOLS_DEFINED=0
fi
AC_SUBST_FILE(MPIG_SYMBOL_MAP_PUBLIC_H)
AC_SUBST_FILE(MPIG_SYMBOL_MAP_INTERNAL_H)
AC_SUBST(MPIG_RENAME_SYMBOLS_DEFINED)

#
# settings imported from the top-level configure
# 
AC_SUBST(AR)
AC_SUBST(AR_FLAGS)
AC_SUBST(RANLIB)
AC_SUBST(MPILIBNAME)
AC_SUBST(PMPILIBNAME)
AC_SUBST(CC)
AC_SUBST(CFLAGS)
AC_SUBST(CPPFLAGS)
AC_SUBST(DEFS)
AC_SUBST(LDFLAGS)
AC_SUBST(LIBS)
PAC_CC_SUBDIR_SHLIBS
AC_SUBST(master_top_srcdir)
AC_SUBST(master_top_builddir)
AC_SUBST(ETAGS)
AC_SUBST(ETAGSADD)

#
# dependency handling
#
AC_SUBST(MAKE_DEPEND_C)

#
# setting to be included in localdefs.h
#
# XXX: MPIG_SAVE_LIBS may contain special regex characters that need to be escaped
EXTRA_LIBS=`echo ${LIBS} | sed -e "s/^${MPIG_SAVE_LIBS} *//"`
AC_SUBST(EXTRA_LIBS)

#
# create Makefile, etc.
#
AC_OUTPUT(Makefile examples/Makefile mpiexec mpiddefs.h.out:mpiddefs.h.in localdefs,
[
    AC_MSG_NOTICE([Copying mpiexec to $master_top_builddir/bin/])
    if test ! -d $master_top_builddir/bin ; then
        mkdir $master_top_builddir/bin
    fi
    chmod 755 mpiexec
    cp -pf mpiexec $master_top_builddir/bin/mpiexec

    if test ! -d $master_top_builddir/src/include ; then
        mkdir $master_top_builddir/src/include
    fi

    # if the mpiddefs.h file has changed, then copy it to the top-level include directory
    mpig_copy_file=yes
    if test -f $master_top_builddir/src/include/mpiddefs.h ; then
        if diff $master_top_builddir/src/include/mpiddefs.h mpiddefs.h.out >/dev/null 2>&1 ; then
           mpig_copy_file=no
        fi
    fi
    if test "$mpig_copy_file" = "yes" ; then 
        AC_MSG_NOTICE([Copying mpiddefs.h.out to $master_top_builddir/src/include/])
        cp -pf mpiddefs.h.out $master_top_builddir/src/include/mpiddefs.h
    else
        AC_MSG_NOTICE([mpiddefs.h.out has not changed.  skipping copy to top-level include directory.])
    fi    
    if test "$MPIG_RENAME_SYMBOLS" = "yes" ; then
        true
        # rm -f .mpig_symbol_map_*
    fi
],
[
    master_top_builddir=${master_top_builddir}
    master_top_srcdir=${master_top_srcdir}
    MPIG_RENAME_SYMBOLS=${MPIG_RENAME_SYMBOLS}
    if test "${MPIG_RENAME_SYMBOLS}" = "yes" ; then
        AC_MSG_NOTICE([Extracting symbols from the symbol map])
        grep '^MPI_' ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >.mpig_symbol_map_public.h
        grep '^PMPI_' ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >>.mpig_symbol_map_public.h
	[grep '^\#[[:space:]]*define[[:space:]]\+P\?MPI_[[:alnum:]_]\+[[:space:]]\+MPI[RD][[:alnum:]_]\+' \
	    $master_top_srcdir/src/include/mpi.h.in | sed -e 's/.*[[:space:]]\(.*\)/^\1[ ]/' >.mpig_symbol_map_public_extras.txt]
	if test -s .mpig_symbol_map_public_extras.txt ; then
	    grep -f .mpig_symbol_map_public_extras.txt ${srcdir}/mpig_symbol_map.txt | \
		sed -e 's/^/#define /' >>.mpig_symbol_map_public.h
	fi
        if test "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" = "yes" ; then
           echo '#define main(argc_, argv_) mpig_app_main(argc_, argv_)' >>.mpig_symbol_map_public.h
        fi
        grep -v '^P\?MPI_' ${srcdir}/mpig_symbol_map.txt | grep -v -f .mpig_symbol_map_public_extras.txt \
	    ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >.mpig_symbol_map_internal.h
    fi

])

AC_OUTPUT_COMMANDS

notice_msg=`echo "end of configure for the ${device_name} device" | tr '[a-z]' '[A-Z]'`
AC_MSG_NOTICE([$notice_msg])
AC_MSG_NOTICE([----------------------------------------])
