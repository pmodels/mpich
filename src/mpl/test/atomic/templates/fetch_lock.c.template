/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */
/*
 *  (C) 2019 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#include "atomic_test.h"

typedef struct lock_add_t {
    int tid;
    int num_threads;
    ATOMIC_TYPE *p_atomic_val;
    int64_t *p_protected_val;
} lock_add_t;

BASE_TYPE test_values[] = TEST_VALUES;

static void lock_add_fetch_add(int num_threads, int tid, void *arg);
static void lock_add_fetch_sub(int num_threads, int tid, void *arg);
static void lock_add_fetch_lock(int num_threads, int tid, void *arg);

int main()
{
#ifdef MPL_USE_NO_ATOMIC_PRIMITIVES
    return 0;
#else
    int i;
    for (i = 0; i < sizeof(num_threads_list) / sizeof(int); i++) {
        int num_threads = num_threads_list[i];
        ATOMIC_TYPE atomic_val = ATOMIC_INITIALIZER(0);
        int64_t protected_val = 0;
        lock_add_t lock_add_arg;
        lock_add_arg.p_atomic_val = &atomic_val;
        lock_add_arg.p_protected_val = &protected_val;
        test_parallel_for(num_threads, lock_add_fetch_add, &lock_add_arg);
        TEST_ASSERT(ATOMIC_RELAXED_LOAD(&atomic_val) == 8192 * num_threads);
        test_parallel_for(num_threads, lock_add_fetch_sub, &lock_add_arg);
        TEST_ASSERT(ATOMIC_RELAXED_LOAD(&atomic_val) == 0);
        test_parallel_for(num_threads, lock_add_fetch_lock, &lock_add_arg);
        TEST_ASSERT(protected_val == 8192 * num_threads);
    }
    return 0;
#endif
}

static void lock_add_fetch_add(int num_threads, int tid, void *arg)
{
    lock_add_t *lock_add_arg = (lock_add_t *)arg;
    ATOMIC_TYPE *p_atomic_val = lock_add_arg->p_atomic_val;
    int i;
    for (i = 0; i < 8192; i++)
        ATOMIC_FETCH_ADD(p_atomic_val, 1);
}

static void lock_add_fetch_sub(int num_threads, int tid, void *arg)
{
    lock_add_t *lock_add_arg = (lock_add_t *)arg;
    ATOMIC_TYPE *p_atomic_val = lock_add_arg->p_atomic_val;
    int i;
    for (i = 0; i < 8192; i++)
        ATOMIC_FETCH_SUB(p_atomic_val, 1);
}

static void lock_add_fetch_lock(int num_threads, int tid, void *arg)
{
    lock_add_t *lock_add_arg = (lock_add_t *)arg;
    int64_t *p_protected_val = lock_add_arg->p_protected_val;
    ATOMIC_TYPE *p_atomic_val = lock_add_arg->p_atomic_val;
    int i;
    for (i = 0; i < 8192; i++) {
        while (1) {
            if (ATOMIC_ACQUIRE_LOAD(p_atomic_val) == 0) {
                if (ATOMIC_FETCH_ADD(p_atomic_val, 1) == 0) {
                    (*p_protected_val) += 1;
                    /* release lock. */
                    ATOMIC_RELEASE_STORE(p_atomic_val, 0);
                    break;
                }
            }
        }
    }
}
