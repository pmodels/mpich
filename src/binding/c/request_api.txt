# vim: set ft=c:

MPI_Cancel:
    .desc: Cancels a communication request
    .extra: NULL
/*
    Notes:
    The primary expected use of 'MPI_Cancel' is in multi-buffering
    schemes, where speculative 'MPI_Irecvs' are made.  When the computation
    completes, some of these receive requests may remain; using 'MPI_Cancel' allows
    the user to cancel these unsatisfied requests.
    
    Cancelling a send operation is much more difficult, in large part because the
    send will usually be at least partially complete (the information on the tag,
    size, and source are usually sent immediately to the destination).
    Users are
    advised that cancelling a send, while a local operation (as defined by the MPI
    standard), is likely to be expensive (usually generating one or more internal
    messages).
*/

MPI_Grequest_complete:
    .desc: Notify MPI that a user-defined request is complete
    .seealso: MPI_Grequest_start

MPI_Grequest_start:
    .desc: Create and return a user-defined request

MPIX_Grequest_start:
    query_fn: FUNCTION_SMALL, func_type=MPI_Grequest_query_function, [callback function invoked when request status is queried]
    free_fn: FUNCTION_SMALL, func_type=MPI_Grequest_free_function, [callback function invoked when request is freed]
    cancel_fn: FUNCTION_SMALL, func_type=MPI_Grequest_cancel_function, [callback function invoked when request is cancelled]
    poll_fn: FUNCTION_SMALL, func_type=MPIX_Grequest_poll_function, [callback function invoked when request completeion is tested]
    wait_fn: FUNCTION_SMALL, func_type=MPIX_Grequest_wait_function, [callback function invoked when request is waited on]
    extra_state: EXTRA_STATE, [extra state]
    request: REQUEST, direction=out, [generalized request]
    .file: grequest_start_x
    .desc: Create and return a user-defined extended request
{
    MPIR_Request *request_ptr = NULL;
    mpi_errno = MPIR_Grequest_start_impl(query_fn, free_fn, cancel_fn, extra_state, &request_ptr);
    if (mpi_errno) {
        goto fn_fail;
    }
    request_ptr->u.ureq.greq_fns->poll_fn = poll_fn;
    request_ptr->u.ureq.greq_fns->wait_fn = wait_fn;
    *request = request_ptr->handle;
}

MPIX_Grequest_class_create:
    query_fn: FUNCTION_SMALL, func_type=MPI_Grequest_query_function, [callback function invoked when request status is queried]
    free_fn: FUNCTION_SMALL, func_type=MPI_Grequest_free_function, [callback function invoked when request is freed]
    cancel_fn: FUNCTION_SMALL, func_type=MPI_Grequest_cancel_function, [callback function invoked when request is cancelled]
    poll_fn: FUNCTION_SMALL, func_type=MPIX_Grequest_poll_function, [callback function invoked when request completeion is tested]
    wait_fn: FUNCTION_SMALL, func_type=MPIX_Grequest_wait_function, [callback function invoked when request is waited on]
    greq_class: GREQUEST_CLASS, direction=out, [generalized request class]

MPIX_Grequest_class_allocate:
    greq_class: GREQUEST_CLASS, [generalized request class]
    extra_state: EXTRA_STATE, [extra state]
    request: REQUEST, direction=out, [generalized request]
    .desc: Create and return a user-defined extended request based on a generalized request class

MPI_Request_free:
    .desc: Frees a communication request object
    .seealso: MPI_Isend, MPI_Irecv, MPI_Issend, MPI_Ibsend, MPI_Irsend, MPI_Recv_init, MPI_Send_init, MPI_Ssend_init, MPI_Rsend_init, MPI_Wait, MPI_Test, MPI_Waitall, MPI_Waitany, MPI_Waitsome, MPI_Testall, MPI_Testany, MPI_Testsome
/*
    Notes:
    
    This routine is normally used to free inactive persistent requests created with
    either 'MPI_Recv_init' or 'MPI_Send_init' and friends.  It `is` also
    permissible to free an active request.  However, once freed, the request can no
    longer be used in a wait or test routine (e.g., 'MPI_Wait') to determine
    completion.
    
    This routine may also be used to free a non-persistent requests such as those
    created with 'MPI_Irecv' or 'MPI_Isend' and friends.  Like active persistent
    requests, once freed, the request can no longer be used with test/wait routines
    to determine completion.
*/

MPI_Request_get_status:
    .desc: Nondestructive test for the completion of a Request
{ -- early_return --
    if (request == MPI_REQUEST_NULL) {
        *flag = 1;
        MPIR_Status_set_empty(status);
        if (status != MPI_STATUS_IGNORE) {
            status->MPI_ERROR = MPI_SUCCESS;
        }
        goto fn_exit;
    }
}

MPI_Start:
    .desc: Initiates a communication with a persistent request handle
{
    mpi_errno = MPID_Startall(1, &request_ptr);
    if (mpi_errno != MPI_SUCCESS)
        goto fn_fail;
}

MPI_Startall:
    .desc: Starts a collection of persistent requests
    .impl: mpid

MPI_Status_set_cancelled:
    .desc: Sets the cancelled state associated with a request
{
    MPIR_STATUS_SET_CANCEL_BIT(*status, flag ? TRUE : FALSE);
}

MPI_Test_cancelled:
    .desc: Tests to see if a request was cancelled
    .extra: SignalSafe
{
    *flag = MPIR_STATUS_GET_CANCEL_BIT(*status);
}

MPI_Test:
    .desc: Test for the completion of a request
    .extra: waitstatus
{
    mpi_errno = MPIR_Test(request, flag, status);
    if (mpi_errno)
        goto fn_fail;
}

MPI_Testall:
    .desc: Tests for the completion of all previously initiated requests
    .extra: waitstatus
/*
    Notes:
      'flag' is true only if all requests have completed.  Otherwise, flag is
      false and neither the 'array_of_requests' nor the 'array_of_statuses' is
      modified.
    
    If one or more of the requests completes with an error, 'MPI_ERR_IN_STATUS' is
    returned.  An error value will be present is elements of 'array_of_statuses'
    associated with the requests.  Likewise, the 'MPI_ERROR' field in the status
    elements associated with requests that have successfully completed will be
    'MPI_SUCCESS'.  Finally, those requests that have not completed will have a
    value of 'MPI_ERR_PENDING'.
    
    While it is possible to list a request handle more than once in the
    'array_of_requests', such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
*/
{ -- error_check -- array_of_statuses
    if (count > 0) {
        MPIR_ERRTEST_ARGNULL(array_of_statuses, "array_of_statuses", mpi_errno);
    }
}
{
    mpi_errno = MPIR_Testall(count, array_of_requests, flag, array_of_statuses);
    if (mpi_errno != MPI_SUCCESS)
        goto fn_fail;
}

MPI_Testany:
    .desc: Tests for completion of any previdously initiated requests
    .extra: waitstatus
/*
    Notes:
    
    While it is possible to list a request handle more than once in the
    'array_of_requests', such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
*/
{ -- error_check --
    if (count > 0) {
        MPIR_ERRTEST_ARGNULL(array_of_requests, "array_of_requests", mpi_errno);
    }
}
{
    int n_inactive = 0;
    int last_disabled_anysource = -1;
    int first_nonnull = count;

    *flag = FALSE;
    *indx = MPI_UNDEFINED;

    for (int i = 0; i < count; i++) {
        if (array_of_requests[i] != MPI_REQUEST_NULL) {
            MPIR_Request_get_ptr(array_of_requests[i], request_ptrs[i]);
            /* Validate object pointers if error checking is enabled */
#ifdef HAVE_ERROR_CHECKING
            {
                MPID_BEGIN_ERROR_CHECKS;
                {
                    MPIR_Request_valid_ptr(request_ptrs[i], mpi_errno);
                    if (mpi_errno)
                        goto fn_fail;
                }
                MPID_END_ERROR_CHECKS;
            }
#endif
            if (unlikely(MPIR_Request_is_anysrc_mismatched(request_ptrs[i]))) {
                last_disabled_anysource = i;
            }

            if (MPIR_Request_is_complete(request_ptrs[i])) {
                if (MPIR_Request_is_active(request_ptrs[i])) {
                    *indx = i;
                    *flag = TRUE;
                    break;
                } else {
                    request_ptrs[i] = NULL;
                }
            } else {
                if (first_nonnull == count)
                    first_nonnull = i;
            }
        } else {
            request_ptrs[i] = NULL;
            n_inactive += 1;
        }
    }

    if (n_inactive == count) {
        *flag = TRUE;
        *indx = MPI_UNDEFINED;
        if (status != NULL)     /* could be null if count=0 */
            MPIR_Status_set_empty(status);
        goto fn_exit;
    }

    if (*indx == MPI_UNDEFINED) {
        mpi_errno =
            MPID_Testany(count - first_nonnull, &request_ptrs[first_nonnull], indx, flag, status);
        /* --BEGIN ERROR HANDLING-- */
        if (mpi_errno != MPI_SUCCESS) {
            goto fn_fail;
        }
        /* --END ERROR HANDLING-- */

        if (*indx != MPI_UNDEFINED) {
            *indx += first_nonnull;
        }
    }

    if (*indx != MPI_UNDEFINED) {
        mpi_errno = MPIR_Request_completion_processing(request_ptrs[*indx], status);
        if (!MPIR_Request_is_persistent(request_ptrs[*indx])) {
            MPIR_Request_free(request_ptrs[*indx]);
            array_of_requests[*indx] = MPI_REQUEST_NULL;
        }
        MPIR_ERR_CHECK(mpi_errno);
        goto fn_exit;
    }

    /* If none of the requests completed, mark the last anysource request as
     * pending failure. */
    if (unlikely(last_disabled_anysource != -1)) {
        MPIR_ERR_SET(mpi_errno, MPIX_ERR_PROC_FAILED_PENDING, "**failure_pending");
        if (status != MPI_STATUS_IGNORE)
            status->MPI_ERROR = mpi_errno;
        *flag = TRUE;
        goto fn_fail;
    }
}

MPI_Testsome:
    .desc: Tests for some given requests to complete
    .extra: waitstatus
/*
    Notes:
    
    While it is possible to list a request handle more than once in the
    'array_of_requests', such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
*/
{ -- error_check -- array_of_indices, array_of_statuses
    if (incount > 0) {
        MPIR_ERRTEST_ARGNULL(array_of_requests, "array_of_requests", mpi_errno);
        MPIR_ERRTEST_ARGNULL(array_of_indices, "array_of_indices", mpi_errno);
        MPIR_ERRTEST_ARGNULL(array_of_statuses, "array_of_statuses", mpi_errno);
    }
}
{
    int n_inactive;
    int proc_failure = FALSE;

    *outcount = 0;
    n_inactive = 0;
    for (int i = 0; i < incount; i++) {
        if (array_of_requests[i] != MPI_REQUEST_NULL) {
            MPIR_Request_get_ptr(array_of_requests[i], request_ptrs[i]);
            /* Validate object pointers if error checking is enabled */
#ifdef HAVE_ERROR_CHECKING
            {
                MPID_BEGIN_ERROR_CHECKS;
                {
                    MPIR_Request_valid_ptr(request_ptrs[i], mpi_errno);
                    if (mpi_errno)
                        goto fn_fail;
                }
                MPID_END_ERROR_CHECKS;
            }
#endif
            if (unlikely(MPIR_Request_is_anysrc_mismatched(request_ptrs[i]))) {
                proc_failure = TRUE;
                int rc = MPI_SUCCESS;
                MPIR_ERR_SET(rc, MPIX_ERR_PROC_FAILED_PENDING, "**failure_pending");
                if (array_of_statuses != MPI_STATUSES_IGNORE)
                    array_of_statuses[i].MPI_ERROR = rc;
            }
        } else {
            request_ptrs[i] = NULL;
            n_inactive += 1;
        }
    }

    if (n_inactive == incount) {
        *outcount = MPI_UNDEFINED;
        goto fn_exit;
    }

    mpi_errno = MPID_Testsome(incount, request_ptrs, outcount, array_of_indices, array_of_statuses);
    /* --BEGIN ERROR HANDLING-- */
    if (mpi_errno != MPI_SUCCESS)
        goto fn_fail;
    /* --END ERROR HANDLING-- */

    if (proc_failure)
        mpi_errno = MPI_ERR_IN_STATUS;

    if (*outcount == MPI_UNDEFINED)
        goto fn_exit;

    for (int i = 0; i < *outcount; i++) {
        int idx = array_of_indices[i];
        MPI_Status *status_ptr = (array_of_statuses == MPI_STATUSES_IGNORE) ?
            MPI_STATUS_IGNORE : &array_of_statuses[i];
        int rc = MPIR_Request_completion_processing(request_ptrs[idx], status_ptr);
        if (!MPIR_Request_is_persistent(request_ptrs[idx])) {
            MPIR_Request_free(request_ptrs[idx]);
            array_of_requests[idx] = MPI_REQUEST_NULL;
        }
        if (rc == MPI_SUCCESS) {
            request_ptrs[idx] = NULL;
        } else {
            mpi_errno = MPI_ERR_IN_STATUS;
            if (status_ptr != MPI_STATUS_IGNORE) {
                status_ptr->MPI_ERROR = rc;
            }
        }
    }

    if (mpi_errno == MPI_ERR_IN_STATUS) {
        if (array_of_statuses != MPI_STATUSES_IGNORE) {
            for (int i = 0; i < *outcount; i++) {
                if (request_ptrs[array_of_indices[i]] == NULL) {
                    array_of_statuses[i].MPI_ERROR = MPI_SUCCESS;
                }
            }
        }
    }
}

MPI_Wait:
    .desc: Waits for an MPI request to complete
    .extra: waitstatus
{
    mpi_errno = MPIR_Wait(request, status);
    if (mpi_errno)
        goto fn_fail;
}

MPI_Waitall:
    .desc: Waits for all given MPI Requests to complete
    .extra: waitstatus
/*
    Notes:
    
    If one or more of the requests completes with an error, 'MPI_ERR_IN_STATUS' is
    returned.  An error value will be present is elements of 'array_of_statuses'
    associated with the requests.  Likewise, the 'MPI_ERROR' field in the status
    elements associated with requests that have successfully completed will be
    'MPI_SUCCESS'.  Finally, those requests that have not completed will have a
    value of 'MPI_ERR_PENDING'.
    
    While it is possible to list a request handle more than once in the
    array_of_requests, such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
*/
{ -- error_check -- array_of_statuses
    if (count > 0) {
        MPIR_ERRTEST_ARGNULL(array_of_statuses, "array_of_statuses", mpi_errno);
    }
}
{
    mpi_errno = MPIR_Waitall(count, array_of_requests, array_of_statuses);
    if (mpi_errno)
        goto fn_fail;
}

MPI_Waitany:
    .desc: Waits for any specified MPI Request to complete
    .extra: waitstatus
/*
    Notes:
    If all of the requests are 'MPI_REQUEST_NULL', then 'indx' is returned as
    'MPI_UNDEFINED', and 'status' is returned as an empty status.
    
    While it is possible to list a request handle more than once in the
    array_of_requests, such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
*/
{
    int last_disabled_anysource = -1;
    int first_nonnull = count;

    *indx = MPI_UNDEFINED;

    for (int i = 0; i < count; i++) {
#ifdef HAVE_ERROR_CHECKING
        MPID_BEGIN_ERROR_CHECKS;
        {
            MPIR_ERRTEST_ARRAYREQUEST_OR_NULL(array_of_requests[i], i, mpi_errno);
        }
        MPID_END_ERROR_CHECKS;
#endif /* HAVE_ERROR_CHECKING */
        if (array_of_requests[i] != MPI_REQUEST_NULL) {
            MPIR_Request_get_ptr(array_of_requests[i], request_ptrs[i]);
            /* Validate object pointers if error checking is enabled */
#ifdef HAVE_ERROR_CHECKING
            {
                MPID_BEGIN_ERROR_CHECKS;
                {
                    MPIR_Request_valid_ptr(request_ptrs[i], mpi_errno);
                    if (mpi_errno != MPI_SUCCESS)
                        goto fn_fail;
                }
                MPID_END_ERROR_CHECKS;
            }
#endif

            if (unlikely(MPIR_Request_is_anysrc_mismatched(request_ptrs[i]))) {
                last_disabled_anysource = i;
            }

            /* Since waitany is likely to return as soon as a
             * completed request is found, the first loop here is
             * taking the longest. We can check for any completed
             * request here, and we can poll from the first entry
             * which is not null. */
            if (MPIR_Request_is_complete(request_ptrs[i])) {
                if (MPIR_Request_is_active(request_ptrs[i])) {
                    *indx = i;
                    break;
                } else {
                    request_ptrs[i] = NULL;
                }
            } else {
                if (first_nonnull == count)
                    first_nonnull = i;
            }
        } else {
            request_ptrs[i] = NULL;
        }
    }

    if (*indx == MPI_UNDEFINED) {
        if (unlikely(last_disabled_anysource != -1)) {
            int flag;
            mpi_errno = MPI_Testany(count, array_of_requests, indx, &flag, status);
            goto fn_exit;
        }

        mpi_errno = MPID_Waitany(count - first_nonnull, &request_ptrs[first_nonnull], indx, status);
        MPIR_ERR_CHECK(mpi_errno);

        if (*indx != MPI_UNDEFINED) {
            *indx += first_nonnull;
        } else {
            goto fn_exit;
        }
    }

    mpi_errno = MPIR_Request_completion_processing(request_ptrs[*indx], status);
    if (!MPIR_Request_is_persistent(request_ptrs[*indx])) {
        MPIR_Request_free(request_ptrs[*indx]);
        array_of_requests[*indx] = MPI_REQUEST_NULL;
    }
    MPIR_ERR_CHECK(mpi_errno);
}

MPI_Waitsome:
    .desc: Waits for some given MPI Requests to complete
/*
    Notes:
      The array of indicies are in the range '0' to 'incount - 1' for C and
    in the range '1' to 'incount' for Fortran.
    
    Null requests are ignored; if all requests are null, then the routine
    returns with 'outcount' set to 'MPI_UNDEFINED'.
    
    While it is possible to list a request handle more than once in the
    array_of_requests, such an action is considered erroneous and may cause the
    program to unexecpectedly terminate or produce incorrect results.
    
    'MPI_Waitsome' provides an interface much like the Unix 'select' or 'poll'
    calls and, in a high qualilty implementation, indicates all of the requests
    that have completed when 'MPI_Waitsome' is called.
    However, 'MPI_Waitsome' only guarantees that at least one
    request has completed; there is no guarantee that `all` completed requests
    will be returned, or that the entries in 'array_of_indices' will be in
    increasing order. Also, requests that are completed while 'MPI_Waitsome' is
    executing may or may not be returned, depending on the timing of the
    completion of the message.
    
    .N waitstatus
*/
{ -- error_check -- array_of_indices, array_of_statuses
    if (incount > 0) {
        MPIR_ERRTEST_ARGNULL(array_of_indices, "array_of_indices", mpi_errno);
        MPIR_ERRTEST_ARGNULL(array_of_statuses, "array_of_statuses", mpi_errno);
    }
}
{
    int n_inactive;
    int disabled_anysource = FALSE;

    *outcount = 0;
    n_inactive = 0;
    for (int i = 0; i < incount; i++) {
        if (array_of_requests[i] != MPI_REQUEST_NULL) {
            MPIR_Request_get_ptr(array_of_requests[i], request_ptrs[i]);
            /* Validate object pointers if error checking is enabled */
#ifdef HAVE_ERROR_CHECKING
            {
                MPID_BEGIN_ERROR_CHECKS;
                {
                    MPIR_Request_valid_ptr(request_ptrs[i], mpi_errno);
                    if (mpi_errno != MPI_SUCCESS) {
                        goto fn_fail;
                    }

                }
                MPID_END_ERROR_CHECKS;
            }
#endif

            /* If one of the requests is an anysource on a communicator that's
             * disabled such communication, convert this operation to a testall
             * instead to prevent getting stuck in the progress engine. */
            if (unlikely(MPIR_Request_is_anysrc_mismatched(request_ptrs[i]))) {
                disabled_anysource = TRUE;
            }
        } else {
            n_inactive += 1;
            request_ptrs[i] = NULL;
        }
    }

    if (n_inactive == incount) {
        *outcount = MPI_UNDEFINED;
        goto fn_exit;
    }

    if (unlikely(disabled_anysource)) {
        mpi_errno =
            MPI_Testsome(incount, array_of_requests, outcount, array_of_indices, array_of_statuses);
        goto fn_exit;
    }

    mpi_errno = MPID_Waitsome(incount, request_ptrs, outcount, array_of_indices, array_of_statuses);
    if (mpi_errno != MPI_SUCCESS) {
        goto fn_fail;
    }

    if (*outcount == MPI_UNDEFINED)
        goto fn_exit;

    for (int i = 0; i < *outcount; i++) {
        int idx = array_of_indices[i];
        MPI_Status *status_ptr = (array_of_statuses != MPI_STATUSES_IGNORE) ? &array_of_statuses[i] : MPI_STATUS_IGNORE;
        int rc = MPIR_Request_completion_processing(request_ptrs[idx], status_ptr);
        if (!MPIR_Request_is_persistent(request_ptrs[idx])) {
            MPIR_Request_free(request_ptrs[idx]);
            array_of_requests[idx] = MPI_REQUEST_NULL;
        }
        if (rc == MPI_SUCCESS) {
            request_ptrs[idx] = NULL;
        } else {
            mpi_errno = MPI_ERR_IN_STATUS;
            if (status_ptr != MPI_STATUS_IGNORE) {
                status_ptr->MPI_ERROR = rc;
            }
        }
    }

    if (mpi_errno == MPI_ERR_IN_STATUS) {
        if (array_of_statuses != MPI_STATUSES_IGNORE) {
            for (int i = 0; i < *outcount; i++) {
                if (request_ptrs[array_of_indices[i]] == NULL) {
                    array_of_statuses[i].MPI_ERROR = MPI_SUCCESS;
                }
            }
        }
    }
}

LIS_KIND_MAP:
    GREQUEST_CLASS: None
BASE_C_KIND_MAP:
    GREQUEST_CLASS: MPIX_Grequest_class
SMALL_C_KIND_MAP:
    GREQUEST_CLASS: MPIX_Grequest_class
BIG_C_KIND_MAP:
    GREQUEST_CLASS: MPIX_Grequest_class
