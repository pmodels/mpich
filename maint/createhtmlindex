#! /usr/bin/env perl
##
## Copyright (C) by Argonne National Laboratory
##     See COPYRIGHT in top-level directory
##

use strict;

# Create an index of web pages for MPICH
#
# Default values
# Root for the pages
my $WWWRoot=`pwd`;
chop $WWWRoot;

# in case for out-of-tree build
my $srcdir = ".";

# End of line character (\r\n is DOS-friendly)
my $eol = "\r\n";
# Number of columns in table of names
my $TableCols = 3;
#
# Process arguments for any changes
foreach $a (@ARGV) {
    if ($a =~ /-?-wwwroot=(.*)/) {
	$WWWRoot = $1;
    }
    elsif ($a =~ /-?-srcdir=(.*)/) {
	$srcdir = $1;
    }
    elsif ($a =~ /-?help/) {
	print STDOUT "createhtmlindex [ -wwwroot=directory ]\n\n";
	print STDOUT "Build the www index pages for MPICH.\n";
	print STDOUT "This must be run in the root of an MPICH tree; it may\n";
        print STDOUT "be run in a VPATH directory after configuring.\n";
	exit 1;
    }
    else {
	print STDERR "Unknown argument $a\n";
	exit 1;
    }
}

# ---- Create the alias pages for large count functions ----
my $poly_aliases_lst = "$srcdir/src/binding/c/mansrc/poly_aliases.lst";
open In, $poly_aliases_lst or die "Failed to open $poly_aliases_lst\n";
while (<In>) {
    # e.g. MPI_Recv - MPI_Recv_c
    if (/^(MPI\w+) - (MPI\w+)/) {
        open Out, "> www/www3/$2.html" or die "Can't create www/www3/$2.html\n";
        print Out "<meta http-equiv=\"refresh\" content=\"0; url=$1.html\">\n";
        close Out;
    }
}
close In;

# ---- Create the main index ----
open( OUTFD, ">$WWWRoot/www/index.html" ) ||
    die "Cannot open $WWWRoot/www/index.html\n";

&AddHeader( "Man pages for MPI" );

print OUTFD "<H2>MPI Commands</H2>$eol";
&AddDirectoryContents( "www", "www1" );

print OUTFD "<H2>MPI Routines</H2>$eol";
&AddDirectoryContents( "www", "www3" );

print OUTFD "<H2>MPI Constants</H2>$eol";
&AddDirectoryConstants( "www", "www3/Constants.html" );

&AddTrailer( );

close( OUTFD );

# ---- Create the www1 index ----
open( OUTFD, ">$WWWRoot/www/www1/index.htm" ) ||
    die "Cannot open $WWWRoot/www/www1/index.htm\n";

&AddHeader( "Manpages for MPICH" );
&AddDirectoryContents( "www/www1", "." );
&AddTrailer( );
close( OUTFD );

# ---- Create the www3 index ----
open( OUTFD, ">$WWWRoot/www/www3/index.htm" ) ||
    die "Cannot open $WWWRoot/www/www3/index.htm\n";

&AddHeader( "Man pages for MPI Routines and Constants" );
&AddDirectoryContents( "www/www3", "." );
print OUTFD "<H2>MPI Routines</H2>$eol";
&AddDirectoryContents( "www/www3", "." );

print OUTFD "<H2>MPI Constants</H2>$eol";
&AddDirectoryConstants( "www/www3", "Constants.html" );

&AddTrailer( );
close( OUTFD );

0;
# ---------------------------------------------------------------------------
# Support routines.
# All write to OUTFD and use $eol for end-of-line
# ---------------------------------------------------------------------------
sub AddHeader {
    my $title = $_[0];
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $today = sprintf("%d/%d/%d", $mon + 1, $mday, $year + 1900);
    print OUTFD "<HTML>$eol<HEAD>$eol<TITLE>$title</TITLE>$eol";
    print OUTFD "<!-- This file generated by createhtmlindex on $today -->$eol";
    print OUTFD "</HEAD>$eol<BODY BGCOLOR=\"FFFFFF\">$eol";
    print OUTFD "<H1>$title</H1>$eol";
}

sub AddTrailer {
    print OUTFD "</BODY>$eol</HTML>$eol";
}

# Create a table of indexes for MPI Constants. Each link points to an
# anchor within Constants.html. We assume each anchor is in a expected
# format.
#
sub AddDirectoryConstants {
    my ($rootdir, $file) = @_;
    my %links;
    open In, "$rootdir/$file" or die "Can't open $rootdir/$file\n";
    while (<In>) {
        if (/<a name="(.+?)"><\/a>/) {
            $links{$1} = "$file#$1";
        }
    }
    MakeHTMLTable(\%links);
}

# Take all .htm and .html files and add them to the OUTFD file.
# This works in two steps:
# 1. Read the contents of the directory into the %links
# 2. Use the routine MakeHTMLTable to create a table with a given
# number of columns, adding the links within the columns
# Look in $1/$2 for files, but make links relative to $2
#
sub AddDirectoryContents {
    my ($rootdir, $dirname) = @_;

    my %links;
    opendir DIR, "$rootdir/$dirname";

    my $prefixname;
    if ($dirname ne ".") {
	$prefixname = "$dirname/";
    }
    while (my $filename = readdir DIR) {
	if ($filename =~ /(index|Constants)\.html?/) {
            next;
        } elsif ($filename =~ /(\w+)\.html?$/) {
            $links{$1} = "$prefixname$filename";
	}
    }
    closedir DIR;

    MakeHTMLTable(\%links);
}

# MakeHTMLTable takes an hash of items and turns them into a table with
# $TableCols columns.
#
sub MakeHTMLTable {
    my ($links) = @_;
    my @keys = sort keys %$links;
    my $nvals = @keys;

    my $nrows = int ( ($nvals + $TableCols - 1) / $TableCols );
    print OUTFD "<TABLE>$eol";
    for (my $j=0; $j<$nrows; $j++) {
	print OUTFD "<TR>";
	for (my $e=0; $e<$TableCols; $e++) {
	    my $linkname = $keys[$j + $e * $nrows];
	    my $filename = $links->{$linkname};
            my $line;
	    if ($filename) {
		$line = "<A HREF=\"$filename\">$linkname</A>";
	    }
	    print OUTFD "<TD>$line</TD>$eol";
	}
	print OUTFD "</TR>$eol";
    }
    print OUTFD "</TABLE>$eol";
}
