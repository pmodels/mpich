AC_PREREQ(2.63)
# 
# (C) 2006 by Argonne National Laboratory.
#     See COPYRIGHT in top-level directory.
#
dnl Process this file with autoconf to produce a configure script.
dnl
dnl aclocal_cache.m4, included by sowing/confdb/aclocal.m4, fixes 
dnl bugs in autoconf caching.
dnl
dnl This is a large configure script and it is important to keep it
dnl clearly organized.  In addition, this script must coordinate with 
dnl the other modules that can be used to construct MPICH2, such as
dnl the communication device and the process manager.  Each of these
dnl may have special features or limitations that other modules or
dnl this configure may need to take into account.  To handle this, there
dnl are xx major steps in this configure script:
dnl
dnl 1. Identify major modules and source any prerequisite scripts
dnl 2. Determine compiler characteristics 
dnl 3. Setup and configure the other modules
dnl 4. Determine MPI features and characteristics (such as datatype values)
dnl
dnl Each of these is described in more detail below.
dnl
dnl 1. Identify the modules (most are specified by 
dnl --with-<modulename>=instance,
dnl for example, --with-pm=mpd or --with-device=ch3:nemesis).
dnl For each module, source the file mpich2prereq if present (in the
dnl module's top-level directory).  This
dnl must be a bourne (sh) shell script; it can access any of the variables
dnl in the configure script.  In addition, there are a few variables that
dnl are defined and provided to allow the modules to communicate their 
dnl needs or limitations to the other modules.  These are:
dnl    MPID_MAX_THREAD_LEVEL - thread level supported by device.
dnl                            if unset, is MPI_THREAD_FUNNELED
dnl    MPID_NO_LONG_LONG     - if yes, the device does not support the 
dnl                            long long integer type
dnl    MPID_NO_LONG_DOUBLE   - if yes, the device does not support the
dnl                            long double type
dnl    MPID_PM_NAMESERVER    - if set, provides the name of the nameserver
dnl                            that the process manager supports.
dnl                            This name server will be used if the
dnl                            default name server is selected.
dnl    MPID_NO_PM            - If yes, the device does not require any
dnl                            PM implementation.  
dnl    MPID_NO_PMI           - If yes, the device does not require any 
dnl                            PMI implementation.
dnl    EXTRA_STATUS_DECL     - Any extra declarations that the device
dnl                            needs added to the definition of MPI_Status.
dnl    MPID_MAX_PROCESSOR_NAME - The maximum number of character in a processor
dnl                            name.  If not set, 128 will be used.
dnl    PMI_REQUIRES_READABLE_TOKENS - if yes, define the C-preprocessor
dnl                            value USE_HUMAN_READABLE_TOKENS, which is
dnl                            used in src/include/mpimem.h to define token
dnl                            separators used in src/util/mem/argstr.c
dnl    PM_REQUIRES_PMI       - if set, provides the name of the PMI 
dnl                            interface implementation.  If not set,
dnl                            the "simple" PMI implementation is used.
dnl                            A process manager that needs a particular
dnl                            process manager should check that this is
dnl                            not set to an incompatible value.
dnl    MPID_NO_SPAWN         - if yes, the device does not support the
dnl                            dynamic process routines (spawn, connect
dnl                            attach, join, plus port and publish 
dnl                            routines).  The major effect of this
dnl                            is to let the test codes know that
dnl                            spawn is not implemented.
dnl    MPID_NO_RMA           - if yes, the device does not support the
dnl                            MPI RMA routines (MPI_Win_create and 
dnl                            MPI_Put etc.).  The major effect of this
dnl                            is to let the test codes know that 
dnl                            RMA is not implemented.
dnl
dnl Note that the meanings of these variables are defined so that an 
dnl undefined value gives the default.  This makes it easy to expand
dnl the set of such variables, since only modules that need the new
dnl variable will need to be changed.
dnl
dnl 2. Determine compiler characteristics
dnl Here is where features of the compilers are determined, including
dnl support for shared libraries and sizes of the basic datatype types.
dnl
dnl 3. Setup and configure the other modules
dnl Before each module configure is executed, the script setup_<module>
dnl is run if present.  This is a bourne (sh) shell script and may
dnl access configure variables.  It should not make any changes to the
dnl compiler name or flags (e.g., do not add -D_XOPEN_SOURCE to CFLAGS here,
dnl because that may invalidate the determination of the compiler 
dnl characteristics in the prior step).
dnl
dnl 4. Determine MPI features
dnl    
dnl
dnl Special environment variables
dnl To let other scripts and in particular the configure in test/mpi
dnl know that they are being invoked from within the MPICH2 configure,
dnl the following environment variables are set and exported:
dnl    FROM_MPICH2
dnl    MPICH2_ENABLE_F77
dnl    MPICH2_ENABLE_FC
dnl    MPICH2_ENABLE_CXX
dnl
dnl The file name here refers to a file in the source being configured
dnl In later versions of autoconf, the binding of AC_INIT changed (!!!)
dnl The original version was AC_INIT(a source file)
dnl The later version is AC_INIT(package,version,[bug-report],[tarname])
dnl Here we use the original version
dnl AC_INIT(src/include/mpiimpl.h)
dnl
dnl Note that no executable statements are allowed (and any are silently 
dnl dropped) before AC_INIT.
dnl
dnl AC_INIT requires an explicit version number
dnl Args are package name, version, bug report, and tar file name
dnl All must be literals
dnl Note that AC_PACKAGE_STRING is not a command but must be defined(!)
dnl Unfortunately, setting the PACKAGE names is not compatible with
dnl AC_CONFIG_SUBDIRS, since the resulting values in the generated
dnl conf file will not be consistent.
dnl define([AC_PACKAGE_STRING],[MPICH2 1.0.6])
dnl AC_INIT(mpich2,1.0.6,mpich2-maint@mcs.anl.gov,mpich2-1.0.6)
dnl Use the oldstyle AC_INIT instead

AC_INIT(src/include/mpichconf.h.in)

CONFIGURE_ARGS_CLEAN=`echo $* | tr '"' ' '`
AC_SUBST(CONFIGURE_ARGS_CLEAN)

# Try to find the version and release date
if test -s "$srcdir/maint/Version" ; then
    . $srcdir/maint/Version
    export MPICH2_VERSION
else
    AC_MSG_ERROR([Version information not found. Configuration aborted.])
fi
AC_SUBST(MPICH2_RELEASE_DATE)
# Produce a numeric version assuming the following format:
# Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
# Example: 1.0.7rc1 has
#          MAJ = 1
#          MIN = 0
#          REV = 7
#          EXT = rc
#          EXT_NUMBER = 1
#
# Converting to numeric version will convert EXT to a format number:
#          ALPHA (a) = 0
#          BETA (b)  = 1
#          RC (rc)   = 2
#          PATCH (p) = 3
# Regular releases are treated as patch 0
#
# Numeric version will have 1 digit for MAJ, 2 digits for MIN,
# 2 digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER.
changequote(<<,>>)
V1=`expr $MPICH2_VERSION : '\([0-9]*\)\.[0-9]*\.*[0-9]*[a-zA-Z]*[0-9]*'`
V2=`expr $MPICH2_VERSION : '[0-9]*\.\([0-9]*\)\.*[0-9]*[a-zA-Z]*[0-9]*'`
V3=`expr $MPICH2_VERSION : '[0-9]*\.[0-9]*\.*\([0-9]*\)[a-zA-Z]*[0-9]*'`
V4=`expr $MPICH2_VERSION : '[0-9]*\.[0-9]*\.*[0-9]*\([a-zA-Z]*\)[0-9]*'`
V5=`expr $MPICH2_VERSION : '[0-9]*\.[0-9]*\.*[0-9]*[a-zA-Z]*\([0-9]*\)'`
changequote([,])

if test "$V2" -le 9 ; then V2=0$V2 ; fi
if test "$V3" = "" ; then V3=0; fi
if test "$V3" -le 9 ; then V3=0$V3 ; fi
if test "$V4" = "a" ; then
    V4=0
elif test "$V4" = "b" ; then
    V4=1
elif test "$V4" = "rc" ; then
    V4=2
elif test "$V4" = "" ; then
    V4=3
    V5=0
elif test "$V4" = "p" ; then
    V4=3
fi
if test "$V5" -le 9 ; then V5=0$V5 ; fi

MPICH2_NUMVERSION=`expr $V1$V2$V3$V4$V5 + 0`
AC_SUBST(MPICH2_NUMVERSION)
AC_SUBST(MPICH2_VERSION)

# ABIVERSION is the name used by simplemake, so we reassign the
# libmpich_so_version number to it
ABIVERSION=${libmpich_so_version}
export ABIVERSION
export libmpich_so_version
AC_SUBST(ABIVERSION)

# Print out the configure options
CONFIGURE_ARGUMENTS="$ac_configure_args"
AC_SUBST(CONFIGURE_ARGUMENTS)
if test -n "$ac_configure_args" ; then
    echo "Configuring MPICH2 version $MPICH2_VERSION with $ac_configure_args"
else 
    echo "Configuring MPICH2 version $MPICH2_VERSION"
fi

# Add the information on the system:
echo "Running on system: `uname -a`"

dnl Definitions will be placed in this file rather than in the DEFS variable
AC_CONFIG_HEADER(src/include/mpichconf.h)
AH_TOP([/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*  
 *  (C) 2001 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */
#ifndef MPICHCONF_H_INCLUDED
#define MPICHCONF_H_INCLUDED
])
AH_BOTTOM([#endif])

dnl Set the directory that contains support scripts such as install-sh and
dnl config.guess
AC_CONFIG_AUX_DIR(confdb)

# Set the FROM_MPICH2 variable to tell subconfigures that they are
# built from within MPICH2
FROM_MPICH2=yes
export FROM_MPICH2
AC_ARG_VAR(FROM_MPICH2,
	[internal flag to tell subconfigures that
	they are built from within MPICH2])

# Save a copy of precious flags as USER_* before any of these flags
# are being modified by configure tests.
PAC_PREFIX_ALL_FLAGS(USER)

# WRAPPER_xFLAGS are used by mpicc and friends.
#
# WRAPPER_CFLAGS and other compile flags are used for compile options
# that are added by MPICH2, but should be used by applications (such
# as include paths).
#
# All libraries that are detected by MPICH2 as needed for some of its
# functionality (such as -lpthread) should be added to LIBS so
# autoconf link tests can use them. Libraries that are built by MPICH2
# at make time (and hence are not available for autoconf link tests to
# use), such as OPA and MPL, should be added to WRAPPER_LIBS for
# static builds. All libraries in LIBS are added to WRAPPER_LIBS
# (similarly LDFLAGS are added to WRAPPER_LDFLAGS) as well, at the end
# of configure.
PAC_PREFIX_ALL_FLAGS(WRAPPER)
WRAPPER_CFLAGS="$CFLAGS $MPICH2_MPICC_FLAGS"
WRAPPER_CPPFLAGS="$CPPFLAGS $MPICH2_MPICPP_FLAGS"
WRAPPER_CXXFLAGS="$CXXFLAGS $MPICH2_MPICXX_FLAGS"
WRAPPER_FFLAGS="$FFLAGS $MPICH2_MPIF77_FLAGS"
WRAPPER_FCFLAGS="$FCFLAGS $MPICH2_MPIFC_FLAGS"
WRAPPER_LDFLAGS="$MPICH2_LDFLAGS"
WRAPPER_LIBS="$MPICH2_LIBS"

# Add MPICH2LIB_* to the appropriate flags
AC_ARG_VAR(MPICH2LIB_CFLAGS,
	[extra CFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_CPPFLAGS,
	[extra CPPFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_CXXFLAGS,
	[extra CXXFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_FFLAGS,
	[extra FFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_FCFLAGS,
	[extra FCFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_LDFLAGS,
	[extra LDFLAGS used in building MPICH2 libraries])
AC_ARG_VAR(MPICH2LIB_LIBS,
	[extra LIBS used in building MPICH2 libraries])
CFLAGS="$CFLAGS $MPICH2LIB_CFLAGS"
CPPFLAGS="$CPPFLAGS $MPICH2LIB_CPPFLAGS"
CXXFLAGS="$CXXFLAGS $MPICH2LIB_CXXFLAGS"
FFLAGS="$FFLAGS $MPICH2LIB_FFLAGS"
FCFLAGS="$FCFLAGS $MPICH2LIB_FCFLAGS"
LDFLAGS="$LDFLAGS $MPICH2LIB_LDFLAGS"
LIBS="$LIBS $MPICH2LIB_LIBS"


AC_ARG_ENABLE(lib-depend,
	AC_HELP_STRING([--enable-lib-depend], [Turn on library dependencies (experimental)]),,
	[enable_lib_depend=no])

AC_ARG_ENABLE(echo, 
	AC_HELP_STRING([--enable-echo], [Turn on strong echoing. The default is enable=no.]),
	set -x)

AC_ARG_ENABLE(coverage,
	AC_HELP_STRING([--enable-coverage], [Turn on coverage analysis using gcc and gcov]),,
	enable_coverage=no)

AC_ARG_ENABLE(dynamiclibs,
	AC_HELP_STRING([--enable-dynamiclibs], [Enable the use of dynamic libraries
                       by the devices that support them]),,enable_dynamiclibs=no)

AC_ARG_ENABLE(error-checking,
[  --enable-error-checking=level
      Control the amount of error checking.  
        no        - no error checking
        runtime   - error checking controllable at runtime through environment 
                    variables
        all       - error checking always enabled (default)
],,enable_error_checking=default)

AC_ARG_ENABLE(error-messages,
[  --enable-error-messages=level - Control the amount of detail in error messages.
        all       - Maximum amount of information
        generic   - Only generic messages (no information about the specific
                    instance)
        class     - One message per MPI error class
        none      - No messages
],,enable_error_messages=all)

AC_ARG_ENABLE(timing,
[  --enable-timing=level - Control the amount of timing information
                           collected by the MPICH implementation.
        none    - Collect no data (default)
        all     - Collect lots of data
        runtime - Runtime control of data collected
],,enable_timing=default)

AC_ARG_ENABLE(g,
[  --enable-g=option - Control the level of debugging support in the
                      MPICH implementation.  option is a list of comma
                      separated names including
        none     - No debugging
        handle   - Trace handle operations
        handlealloc - Trace handle allocations
        dbg      - Add compiler flag, -g, to all internal
                   compiler flags, i.e. MPICH2LIB_CFLAGS, MPICH2LIB_CXXFLAGS,
                   MPICH2LIB_FFLAGS, and MPICH2LIB_FCFLAGS.
        debug    - Synonym for dbg
        instr    - Enable instrumentation
        log      - Enable debug event logging
        mem      - Memory usage tracing
        meminit  - Preinitialize memory associated structures and unions to
                   eliminate access warnings from programs like valgrind
        memarena - Check for overwrite errors in memory allocation arena
        mutex    - Enable error checking on pthread mutexes
        mutexnesting - Check for non-nesting of mutexes
        all      - All of the above choices
],,enable_g=none)

dnl We may want to force MPI_Aint to be the same size as MPI_Offset, 
dnl particularly on 32 bit systems with large (64 bit) file systems.
AC_ARG_WITH(aint-size,
	AC_HELP_STRING([--with-aint-size], [Override the size of MPI_AINT (in bytes)]),,
	with_aint_size=0)

AC_ARG_ENABLE(fast,
[  --enable-fast=option - Control the level of fast execution in the
                         MPICH implementation.  option is a list of
                         comma separated names including
        defopt   - Default compiler optimization -O2 for all language bindings,
                   i.e. --enable-fast=O2, when neither --enable-fast
                   nor --disable-fast is specified. (default)
        O<n>     - Appends default optimization flags, -O<n>, to all internal
                   compiler flags, i.e. MPICH2LIB_CFLAGS, MPICH2LIB_CXXFLAGS,
                   MPICH2LIB_FFLAGS, and MPICH2LIB_FCFLAGS.
        nochkmsg - No error checking, i.e. --disable-error-checking
        notiming - No timing collection, i.e. --disable-timing.
        ndebug   - Appends -DNDEBUG to MPICH2LIB_CFLAGS.
        all|yes  - "defopt", "nochkmsg", "notiming" and "ndebug" are enabled
                   when --enable-fast is specified without any option.
        none     - None of above options, i.e. --disable-fast. Note that
                   --enable-strict will add the -O2 option even if
                   --enable-fast=none is given.
],,enable_fast=defopt)

AC_ARG_ENABLE(check-compiler-flags,
	AC_HELP_STRING([--enable-check-compiler-flags], [enable the checks for all compiler
                       options, xxxFLAGS, MPICH2_xxxFLAGS. Default is on.]),,
		       enable_check_compiler_flags=yes)

dnl We enable f77 and fc if we can find compilers for them.
dnl In addition, we check whether f77 and fc can work together.
AC_ARG_ENABLE(f77,
	AC_HELP_STRING([--enable-f77], [Enable Fortran 77 bindings]),,enable_f77=yes)

AC_ARG_ENABLE(fc,
	AC_HELP_STRING([--enable-fc], [Enable Fortran 90 bindings]),,enable_fc=yes)

AC_ARG_ENABLE(f90,
	AC_HELP_STRING([--enable-f90],
		[Obsolete option: Use --enable-fc or --disable-fc instead]),
	[AC_MSG_ERROR([
--enable-f90 and --disable-f90 are NO longer valid configure options,
use --enable-fc or --disable-fc instead])]
)

AC_ARG_ENABLE(cxx,
	AC_HELP_STRING([--enable-cxx], [Enable C++ bindings]),,enable_cxx=default)

AC_ARG_ENABLE(romio,
	AC_HELP_STRING([--enable-romio], [Enable ROMIO MPI I/O implementation]),,
	enable_romio=yes)

AC_ARG_ENABLE(debuginfo,
	AC_HELP_STRING([--enable-debuginfo], [Enable support for debuggers]),,
	enable_debuginfo=no)

AC_ARG_ENABLE(smpcoll,
	AC_HELP_STRING([--enable-smpcoll],
			[Enable support for SMP/multi-core aware collectives]),
	smpcoll=$enableval,smpcoll=yes)
if test $smpcoll = "yes" ; then
   AC_DEFINE(USE_SMP_COLLECTIVES,1,[define to enable SMP/multi-core aware collectives])
fi

dnl The environment variable MPICH_DEBUGLIBNAME may be used to
dnl override the default name of the library that the debugger will
dnl load to access the MPICH2 internal data structures.
AC_ARG_ENABLE(nmpi-as-mpi,
	AC_HELP_STRING([--enable-nmpi-as-mpi], [Use MPI rather than PMPI routines for MPI
                       routines, such as the collectives, that may be
                       implemented in terms of other MPI routines]),,
	enable_nmpi_as_mpi=no)

dnl "default" is a special device that allows MPICH to choose one
dnl based on the environment.
AC_ARG_WITH(device,
	AC_HELP_STRING([--with-device=name], [Specify the communication device for MPICH]),,
	with_device=default)

AC_ARG_WITH(pmi,
	AC_HELP_STRING([--with-pmi=name], [Specify the pmi interface for MPICH]),,
	with_pmi=default)

AC_ARG_WITH(pm, 
	AC_HELP_STRING([--with-pm=name],
		[Specify the process manager for MPICH.  "no" or "none" are
                 valid values.  Multiple process managers may be specified as
                 long as they all use the same pmi interface by separating them
                 with colons.  The mpiexec for the first named process manager
                 will be installed.  Example: "--with-pm=hydra:mpd:gforker"
                 builds the three process managers hydra, mpd and gforker;
                 only the mpiexec from hydra is installed into the bin
                 directory.]),,with_pm=default)

AC_ARG_WITH(logging,
	AC_HELP_STRING([--with-logging=name], [Specify the logging library for MPICH]),
	[if test -z "$withval" ; then with_logging=rlog ; fi],with_logging=none)

dnl both --without-mpe and --disable-mpe are supported
dnl AC_ARG_ENABLE(mpe) is used only when --with(out)-mpe is not used.
AC_ARG_WITH(mpe,
	AC_HELP_STRING([--with-mpe], [Build the MPE (MPI Parallel Environment) routines]),,
	with_mpe=default)
if test "$with_mpe" = "default" ; then
    AC_ARG_ENABLE(mpe,
	AC_HELP_STRING([--enable-mpe], [Build the MPE (MPI Parallel Environment) routines]),
	with_mpe=$enableval,with_mpe=default)
fi

dnl
dnl The default option needs to be defined in terms of a specific choice 
dnl (runtime in this case).  Note that the default choice is the same as
dnl runtime only for certain devices - not for every device.
AC_ARG_ENABLE(threads,
[  --enable-threads=level - Control the level of thread support in the 
                           MPICH implementation.  The following levels
                           are supported.
        single          - No threads (MPI_THREAD_SINGLE)
        funneled        - Only the main thread calls MPI (MPI_THREAD_FUNNELED)
        serialized      - User serializes calls to MPI (MPI_THREAD_SERIALIZED)
        runtime         - The level of thread support is determined by 
                          the arguments to MPI_Init_thread, with
                          MPI_THREAD_MULTIPLE available.  The default option
                          for many communication devices.
        multiple        - Fully multi-threaded (MPI_THREAD_MULTIPLE) always. 
                          DO NOT select this option. The option runtime is more
                          efficient and also supports thread_multiple. 
                          (multiple aliased to runtime now)
        default         - Make a good choice depending on the communication
                          device.  For ch3:nemesis, this is runtime.

        See also the --enable-thread-cs option for controlling the granularity of
        the concurrency inside of the library
],,enable_threads=default)

AC_ARG_ENABLE(thread-cs,
	AC_HELP_STRING([--enable-thread-cs=type],
			[Choose the method used for critical sections
                         and other atomic updates when multiple
                         threads are present.  Values may be global
                         (default), per-object, lock-free]),,enable_thread_cs=global)

AC_ARG_ENABLE(refcount,
	AC_HELP_STRING([--enable-refcount=type],
			[Choose the method for ensuring atomic updates
                         to the reference counts for MPI objects.
                         Values may be lock, lock-free, none.  The
                         default depends on the thread-cs choice; for
                         global it is none (because none is required),
                         for per-object it is lock, and for lock-free
                         it is lock-free]),,enable_refcount=default)

AC_ARG_ENABLE(mutex-timing,
	AC_HELP_STRING([--enable-mutex-timing], [calculate the time spent waiting on mutexes]),
	AC_DEFINE(MPIU_MUTEX_WAIT_TIME,1,[Define to enable timing mutexes]))

AC_ARG_ENABLE(handle-allocation,
	AC_HELP_STRING([--enable-handle-allocation=type],
			[Choose the method used for allocating MPI
			 object handles.  Values may be 'tls' for
			 thread-local storage or 'mutex' for simple
			 locking.  'mutex' is the default.]),,enable_handle_allocation=default)

AC_ARG_ENABLE([predefined-refcount],
	AS_HELP_STRING([--enable-predefined-refcount],
                       [control whether predefined objects like
		       MPI_COMM_WORLD are reference counted (default
		       depends on --enable-thread-cs choice)]),[],
              [enable_predefined_refcount=default])

AC_ARG_ENABLE(weak-symbols,
	AC_HELP_STRING([--enable-weak-symbols],
			[Use weak symbols to implement PMPI routines (default)]),,
		enable_weak_symbols=yes)

AC_ARG_ENABLE(multi-aliases,
	AC_HELP_STRING([--enable-multi-aliases],
		[Multiple aliasing to support multiple fortran compilers (default)]),,
		enable_multi_aliases=yes)

AC_ARG_WITH(cross,
	AC_HELP_STRING([--with-cross=file],
		[Specify the values of variables that configure cannot
                 determine in a cross-compilation environment]),,with_cross=no)

AC_ARG_WITH(namepublisher,
[  --with-namepublisher=name   Choose the system that will support 
                              MPI_PUBLISH_NAME and MPI_LOOKUP_NAME.  Options
                              include
                                   no (no service available)
                                   mpd
			           file[:directory] (optional directory)
                                   pmi],,with_namepublisher=default)
AC_ARG_WITH(name-publisher,
    [],
    with_namepublisher=$with_name_publisher,)

AC_SUBST(MPIFLIBNAME)
AC_SUBST(PMPIFLIBNAME)

dnl The default is a special wrapper library
AC_ARG_WITH(fwrapname,
	AC_HELP_STRING([--with-fwrapname=name],
		[Specify name of library containing Fortran interface routines]),
	[FWRAPNAME=$withval;set_FWRAPNAME="yes"],FWRAPNAME=fmpich)
AC_SUBST(FWRAPNAME)

# Find a C compiler.
# We also need to do this before the F77 and FC test to ensure that we
# find the C preprocessor reliably.
PAC_PROG_CC
PAC_PUSH_FLAG([CFLAGS])
AC_PROG_CPP
# Bug in autoconf.  Restore cross settings
if test "$pac_cross_compiling" = "yes" -a "$ac_cv_prog_cc_cross" = "no" ; then
    AC_MSG_RESULT([Resetting cross compilation to yes])
    cross_compiling=yes
    ac_cv_prog_cc_cross=yes
    ac_cv_prog_f77_cross=yes
    ac_cv_prog_fc_cross=yes
    ac_cv_prog_cxx_cross=yes
fi
PAC_POP_FLAG([CFLAGS])

# compute canonical system types
AC_CANONICAL_BUILD
AC_CANONICAL_HOST
# TARGET not needed, MPICH2 isn't a compiler

# Enable better caching control
PAC_ARG_CACHING

# Set CFLAGS for enable strict if necessary.  Do this *first* because
# it may influence the output of the other tests
PAC_ARG_STRICT

# Check for shared library support
PAC_ARG_SHAREDLIBS


# -----------------------------------------------------------------------------
# First check that we have a clean build if we are doing a VPATH build
PAC_VPATH_CHECK(src/include/mpi.h src/env/mpicc src/env/mpicc.conf,lib)

# ----------------------------------------------------------------------------
# This test is complicated by the fact that top_srcdir is not set until
# the very end of configure.  Instead, we get it ourselves
if test -z "$top_srcdir" ; then
   use_top_srcdir=$srcdir   
else
   use_top_srcdir=$top_srcdir
fi
if test -z "$master_top_srcdir" ; then 
    # This needs to be an absolute pathname
    case "$use_top_srcdir" in
    /*) ;;
    *)
        use_top_srcdir=`(cd $use_top_srcdir && pwd)`
	;;	
    esac
    master_top_srcdir=$use_top_srcdir
fi
# Get the directory that we're running in...
if test -z "$master_top_builddir" ; then
   master_top_builddir="`pwd`"
fi
AC_SUBST(master_top_builddir)
AC_SUBST(master_top_srcdir)
export master_top_builddir
export master_top_srcdir
# ----------------------------------------------------------------------------
# We create this file to allow other configures to find the "master" 
# top builddir
rm -f .mpich2
date > .mpich2
# ----------------------------------------------------------------------------
# with-device
if test "$with_device" = "default" ; then
    # Pick the device.  For now, always choose ch3
    with_device=ch3
fi
# Extract the device name from any options
# Allow the device to specify a directory; if no directory, use the
# included directories
# 
DEVICE=$with_device
AC_SUBST(DEVICE)

device_name=`echo $with_device | sed -e 's/:.*$//'`
changequote(<<,>>)
device_args=`echo $with_device | sed -e 's/^[^:]*//' -e 's/^://'`
changequote([,])

devicedir=$use_top_srcdir/src/mpid/$device_name
devicereldir=src/mpid/$device_name
case "$device_name" in
     /*) 
     devicedir=$DEVICE
     # Get the name from the leaf
     device_name=`echo $device_name ~ sed -e 's%.*/%%'`
     # FIXME: should the devicereldir be different (perhaps not -
     # this allows use to build within our tree, even when other data
     # is outside of the tree)
     ;;
     *) 
     ;;
esac
export device_name
export device_args
export devicedir
# Make the device base name and args available to generated files
DEVICE_NAME=$device_name
AC_SUBST(DEVICE_NAME)
DEVICE_ARGS=$device_args
AC_SUBST(DEVICE_ARGS)
#
# Give the device an opportunity to include a header file in mpi.h.  The
# default value of INCLUDE_MPIDDEFS_H is set prior to the inclusion of the
# device's mpich2prereq script.  The device's script may override the value
# if needed.
INCLUDE_MPIDDEFS_H='/* ... no device specific definitions ... */'
AC_SUBST(INCLUDE_MPIDDEFS_H)

#
# See if the device wants to say something about the compilers (for example,
# the globus device may need to do this)
if test -f $devicedir/mpich2prereq ; then
    . $devicedir/mpich2prereq
fi

# ----------------------------------------------------------------------------
# Set default library names if names haven't already been provided
MPILIBNAME=${MPILIBNAME:-"mpich"}
PMPILIBNAME_set=no
if test -n "$PMPILIBNAME" ; then 
   PMPILIBNAME_set=yes
fi
PMPILIBNAME=${PMPILIBNAME:-"p$MPILIBNAME"}
# Note that the name for this library may be updated after we check for 
# enable_shmem
# Fortran names are set later.
# We use a different library for the C++ wrappers to avoid problems when
# creating shared libraries
if test -z "$MPICXXLIBNAME" ; then MPICXXLIBNAME="${MPILIBNAME}cxx" ; fi
export MPIFLIBNAME
export PMPIFLIBNAME
export MPICXXLIBNAME
AC_SUBST(MPICXXLIBNAME)

# We'll set FORTRAN_BINDING to 1 if we support Fortran 
FORTRAN_BINDING=0

# Set up default compiler optimization
MPI_DEFAULT_COPTS="-O2"
MPI_DEFAULT_CXXOPTS="-O2"
MPI_DEFAULT_FOPTS="-O2"
MPI_DEFAULT_FCOPTS="-O2"

# enable-fast
# strip off multiple options, separated by commas
save_IFS="$IFS"
IFS=","
for option in $enable_fast ; do
    case "$option" in
        defopt)
        enable_default_optimize=yes
        ;;
        nochkmsg)
        enable_fast_nochkmsg=yes
        ;;
        notiming)
        enable_timing=no
        ;;
        ndebug)
        enable_append_ndebug=yes
        ;;
#
# [BRT] removed the reseting of enable_g so that --with-enable=dbg,meminit
# can be specified with -enable-fast.  This change was largely made for the
# PETSc folks who want to use --enable-fast to eliminate parameter checking
# overhead, but also wish to use meminit to eliminate initialization
# warnings from valgrind.
#
        all|yes)
        enable_default_optimize=yes
        enable_fast_nochkmsg=yes
        # Disable timing/logging stuffs
        enable_timing=no
        enable_append_ndebug=yes
        ;;
        O*)
        # Allows O<n> where <n> can be [0-9] or ' '.
        opt_flags=`echo $option | sed -e 's%\(O[0-9] \)%\1%g'`
        if test -n "$opt_flags" ; then
            enable_default_optimize=yes
            MPI_DEFAULT_COPTS="-$option"
            MPI_DEFAULT_CXXOPTS="-$option"
            MPI_DEFAULT_FOPTS="-$option"
            MPI_DEFAULT_FCOPTS="-$option"
        else
	    IFS="$save_IFS"
            AC_MSG_WARN([Unknown value $option for --enable-fast])
	    IFS=","
        fi
        ;;
        none|no)
        enable_default_optimize=no
        enable_fast_nochkmsg=no
        # Reset timing/logging stuffs to when --enable-timing isn't specified.
        enable_timing=default
        enable_append_ndebug=no
        ;;
        *)
	IFS="$save_IFS"
        AC_MSG_WARN([Unknown value $option for --enable-fast])
	IFS=","
        ;;
    esac
done
IFS="$save_IFS"

# ----------------------------------------------------------------------------
# Process any enable or with values
# We must do enable-fast first, because it changes the other enable values
if test "$enable_fast_nochkmsg" = "yes" ; then
    # 
    if test "$enable_error_checking" != "default" -a "$enable_error_checking" != "no" ; then
        AC_MSG_ERROR([enable-fast overrides enable-error-checking; error-checking option $enable_error_checking ignored])
    fi
    enable_error_checking=no
    # Export a variable that will allow the test suite to detect that
    # MPICH has no error testing
    MPICH_FAST=yes
    export MPICH_FAST
fi

# error-checking
# Change default into the specific value of the default
if test "$enable_error_checking" = "default" ; then
   enable_error_checking=all
fi
case "$enable_error_checking" in 
    no)
    # if error checking has been disabled, then automatically disable the error
    # checking tests in the test suite
    ac_configure_args="${ac_configure_args} --disable-checkerrors"
    ;;
    all|yes|runtime)
    error_checking_kind=`echo $enable_error_checking | \
    tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
    error_checking_kind=MPID_ERROR_LEVEL_$error_checking_kind
    AC_DEFINE_UNQUOTED(HAVE_ERROR_CHECKING,$error_checking_kind,[Define to enable error checking])
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_error_checking for enable-error-checking])
    ;;
esac

# error-messages
case "$enable_error_messages" in 
    no|none)
        error_message_kind="MPICH_ERROR_MSG_NONE"
    ;;
    all|yes)
	error_message_kind="MPICH_ERROR_MSG_ALL"
    ;;
    generic)
	error_message_kind="MPICH_ERROR_MSG_GENERIC"
    ;;
    class)
	error_message_kind="MPICH_ERROR_MSG_CLASS"
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_error_messages for enable-error-messages])
    ;;
esac
AC_DEFINE_UNQUOTED(MPICH_ERROR_MSG_LEVEL,$error_message_kind,[define to enable error messages])

# ----------------------------------------------------------------------------
#
# enable-timing and with-logging
#
# Still to do: add subsets: e.g., class=pt2pt,class=coll.  See mpich2 doc
#
# Logging and timing are intertwined.  If you select logging, you
# may also need to select a timing level.  If no timing is selected 
# but logging with rlog is selected, make "all" the default timing level.
#
# FIXME: make timing and logging options work more cleanly together,
# particularly when other logging options are selected (e.g., logging is not
# rlog).
# ----------------------------------------------------------------------------
collect_stats=false
logging_required=false
if test "$enable_timing" = "default" ; then
    if test "$with_logging" = "rlog" ; then
        enable_timing=all
    fi
fi
timing_name=$enable_timing
case "$enable_timing" in
    no)
    timing_name=none
    ;;
    time)
    collect_stats=true
    ;;
    log|log_detailed)
    logging_required=true
    ;;
    yes)
    timing_name=all
    collect_stats=true
    logging_required=true
    ;;
    all|runtime)
    collect_stats=true
    logging_required=true
    ;;
    none|default)
    timing_name=none
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_timing for enable-timing])
    enable_timing=no
    timing_name=none
    ;; 
esac
#
# The default logging package is rlog; you can get it by 
# specifying --with-logging or --with-logging=rlog
#
case $with_logging in 
    yes)
    logging_name=rlog
    ;;
    no|none)
    logging_name=none
    ;;
    default)
    if test "$logging_required" = "true" ; then
        logging_name=rlog
    else
        logging_name=none
    fi
    ;;
    *)
    logging_name=$with_logging
    ;;
esac
# 
# Include the selected logging subsystem
#
# Choices:
# 1) A subdir of src/util/logging
#     This directory must contain a configure which will be executed
#     to build the 
# 2) An external directory
#     This directory must contain 
#          a mpilogging.h file
#     It may contain 
#          a setup_logging script
#          a configure
#     
#   
logging_subsystems=
if test "$logging_name" != "none" ; then
    # Check for an external name (directory containing a /)
    hasSlash=`echo A$logging_name | sed -e 's%[[^/]]%%g'`
    if test -n "$hasSlash" ; then
        # Check that the external logging system is complete.
	# Any failure will cause configure to abort
        if test ! -d $logging_name ; then
	    AC_MSG_ERROR([External logging directory $logging_name not found.  Configure aborted])
	    logging_name=none
        elif test ! -s $logging_name/mpilogging.h ; then
	    AC_MSG_ERROR([External logging header $logging_name/mpilogging.h not found.  Configure aborted])
	    logging_name=none
        fi

        logdir=$logging_name
	# Force the logdir to be absolute
	logdir=`cd $logdir && pwd`
	# Switch name to "external" because that is how the MPICH2
	# code will know it
	logging_name=external
	# Add the dir to the include paths
	#CPPFLAGS="$CPPFLAGS -I$logdir"
	CPPFLAGS="$CPPFLAGS -I$logdir"
	EXTERNAL_SRC_DIRS="$EXTERNAL_SRC_DIRS $logdir"
	# Add to the list of external modules to setup
	if test -x $logdir/setup_logging ; then
	     EXTERNAL_SETUPS="$EXTERNAL_SETUPS $logdir/setup_logging"
	fi
    else
        logdir=$srcdir/src/util/logging
        logreldir=src/util/logging/$logging_name
        logging_subsystems="$logging_subsystems $logreldir"
        logging_subdirs=$logging_name
        for dir in $logging_subdirs ; do
            if test ! -d $logdir/$dir ; then
	        AC_MSG_ERROR([$logdir/$dir does not exist.  Configure aborted])
	        logging_name=none
            fi
        done
        for dir in $logging_subsystems ; do
            if test ! -x $srcdir/$dir/configure ; then
	        AC_MSG_ERROR([$logdir/$dir has no configure (required).  Configure aborted])
	        logging_name=none
            fi
            other_install_dirs="${other_install_dirs} $logreldir"
        done
    fi
fi
#
# FIXME: Logging doesn't necessarily require timing (e.g., simply logging the 
# sequence of routines).  
if test "$logging_name" != "none" ; then
    if test "$enable_timing" != "no" ; then
	if test "$enable_timing" = "default" -o "$enable_timing" = "none" ; then
	    enable_timing=log
	    timing_name=log
    	fi
	logging_dir=logging
	subsystems="$subsystems $logging_subsystems"
    else
	AC_MSG_WARN([Timing was disabled.  Logging has been disabled as well.])
	with_logging=no
	logging_name=none
        logging_dir=
        logging_subdirs=
    fi
else
    if test "$logging_required" = "true" ; then
	AC_MSG_WARN([Timing was enabled with log option but no logging library is available.  Timing has been disabled.])
	enable_timing=no
	timing_name=none
    fi
    logging_dir=
    logging_subdirs=
fi
if test "$timing_name" != "none" ; then
    timing_kind=`echo $timing_name | \
       tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
    timing_kind=MPID_TIMING_KIND_$timing_kind
    AC_DEFINE_UNQUOTED(HAVE_TIMING,$timing_kind,[define to enable timing collection])
    if test "$collect_stats" = "true" ; then
        AC_DEFINE(COLLECT_STATS,1,[define to enable collection of statistics])
    fi
fi
#
AC_SUBST(logging_dir)
AC_SUBST(logging_name)
AC_SUBST(logging_subdirs)
use_logging_variable="MPID_LOGGING_`echo $logging_name | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
AC_DEFINE_UNQUOTED(USE_LOGGING,$use_logging_variable,[define to choose logging library])
# ----------------------------------------------------------------------------
# End of logging tests
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Check to see if the device does not support spawn.  
# FIXME: This should provide the option of not building the dynamic
# process routines.  It could also allow us to specialize support
# for all processes are members of MPI_COMM_WORLD (only one comm_world).
# ----------------------------------------------------------------------------
if test "$MPID_NO_SPAWN" = yes ; then
    AC_MSG_WARN([The device $with_device does not support MPI dynamic process routines])   
fi

# MPL
PAC_CONFIG_SUBDIR(src/mpl,,AC_ERROR(MPL configure failed))
PAC_PREPEND_FLAG([-lmpl], [WRAPPER_LIBS])
PAC_APPEND_FLAG([-I${master_top_builddir}/src/mpl/include], [CPPFLAGS])
PAC_APPEND_FLAG([-I${use_top_srcdir}/src/mpl/include], [CPPFLAGS])
EXTERNAL_SRC_DIRS="$EXTERNAL_SRC_DIRS src/mpl"
other_install_dirs="$other_install_dirs src/mpl"

# OpenPA
AC_ARG_WITH([openpa-prefix],
            [AS_HELP_STRING([[--with-openpa-prefix[=DIR]]],
                            [use the OpenPA atomics library installed in DIR,
                             rather than the one included in src/openpa.  Pass
                             "embedded" to force usage of the OpenPA source
                             distributed with MPICH2.])],
            [],
            [# see if OPA is already installed on the system
             PAC_PUSH_FLAG([LIBS])
             PAC_PREPEND_FLAG([-lopa],[LIBS])
             AC_LINK_IFELSE([AC_LANG_PROGRAM([dnl
#include "opa_primitives.h"
],[
OPA_int_t i;
OPA_store_int(i,10);
OPA_fetch_and_incr_int(&i,5);
])dnl
                             ],
                            [with_openpa_prefix=system],[with_openpa_prefix=embedded])
             PAC_POP_FLAG([LIBS])
             ])
# @opadir@ is used in src/Makefile.sm to control whether or not the OPA in
# src/openpa is built and installed
opadir=""
AC_SUBST([opadir])

if test "$with_openpa_prefix" = "embedded" ; then
    if test -e "${use_top_srcdir}/src/openpa" ; then
        opadir="openpa"
        EXTERNAL_SRC_DIRS="$EXTERNAL_SRC_DIRS src/openpa"
        PAC_APPEND_FLAG([-I${use_top_srcdir}/src/openpa/src],[CPPFLAGS])
        PAC_APPEND_FLAG([-I${master_top_builddir}/src/openpa/src],[CPPFLAGS])

        # OPA defaults to "auto", but in MPICH2 we want "auto_allow_emulation" to
        # easily permit using channels like ch3:sock that don't care about atomics
        AC_ARG_WITH([atomic-primitives],
                    [AS_HELP_STRING([--with-atomic-primitives],
                                    [Force OPA to use a specific atomic primitives
                                     implementation.  See the src/openpa directory
                                     for more info.])],
                    [],[with_atomic_primitives=not_specified])
        opa_subdir_args=""
        if test "$with_atomic_primitives" = "not_specified" ; then
            opa_subdir_args="--with-atomic-primitives=auto_allow_emulation"
        fi
        PAC_CONFIG_SUBDIR_ARGS([src/openpa],[$opa_subdir_args],[],[AC_ERROR([OpenPA configure failed])])
        PAC_PREPEND_FLAG([-lopa],[WRAPPER_LIBS])

        other_install_dirs="$other_install_dirs src/openpa"
    else
        AC_MSG_WARN([Attempted to use the embedded OpenPA source tree in "src/openpa", but it is missing.  Configuration or compilation may fail later.])
    fi
elif test "$with_openpa_prefix" = "system" ; then
    PAC_PREPEND_FLAG([-lopa],[WRAPPER_LIBS])
elif test "$with_openpa_prefix" = "no" ; then
    # The user doesn't want to use OPA.  This may or may not cause MPICH2 to
    # fail to configure/build, depending on many other factors.
    :
else
    # The user specified an already-installed OPA; just sanity check, don't
    # subconfigure it
    AS_IF([test -s "${with_openpa_prefix}/include/opa_primitives.h" -a -s "${with_openpa_prefix}/include/opa_config.h"],
          [:],[AC_MSG_ERROR([the OpenPA installation in "${with_openpa_prefix}" appears broken])])
    PAC_APPEND_FLAG([-I${with_openpa_prefix}/include],[CPPFLAGS])
    PAC_PREPEND_FLAG([-lopa],[WRAPPER_LIBS])
    if test -d ${with_openpa_prefix}/lib64 ; then
        PAC_APPEND_FLAG([-L${with_openpa_prefix}/lib64],[WRAPPER_LDFLAGS])
    fi
    PAC_APPEND_FLAG([-L${with_openpa_prefix}/lib],[WRAPPER_LDFLAGS])
fi

# ----------------------------------------------------------------------------
# Threads
# ----------------------------------------------------------------------------
#
# Threads must be supported by the device.  First, set the default to
# be the highest supported by the device
if test "$enable_threads" = default ; then
    if test -n "$MPID_MAX_THREAD_LEVEL" ; then
        case $MPID_MAX_THREAD_LEVEL in
            MPI_THREAD_SINGLE)     enable_threads=single ;;
            MPI_THREAD_FUNNELED)   enable_threads=funneled ;;
            MPI_THREAD_SERIALIZED) enable_threads=serialized ;;
            MPI_THREAD_MULTIPLE)   enable_threads=runtime ;;
            *) AC_MSG_ERROR([Unrecognized thread level from device $MPID_MAX_THREAD_LEVEL])
    	    ;;
        esac
    else
        enable_threads=single
    fi
fi

if test "$enable_threads" = "yes" ; then 
    enable_threads=multiple
elif test "$enable_threads" = "no" ; then
    enable_threads=single
elif test "$enable_threads" = "default"; then
    if test "$with_device" = "default" -o "$with_device" = "ch3:sock" ; then
        enable_threads=runtime
    fi
fi

# Runtime is an alias for multiple with an additional value
if test "$enable_threads" = "runtime" ; then
    AC_DEFINE(HAVE_RUNTIME_THREADCHECK,1,[Define if MPI supports MPI_THREAD_MULTIPLE with a runtime check for thread level])
    enable_threads=multiple
fi

MPICH_THREAD_LEVEL=MPI_THREAD_FUNNELED
case "$enable_threads" in 
    single)
    thread_pkg_required=no
    MPICH_THREAD_LEVEL=MPI_THREAD_SINGLE
    ;;
    funneled)
    thread_pkg_required=no
    MPICH_THREAD_LEVEL=MPI_THREAD_FUNNELED
    ;;
    serialized)
    # FIXME: Why does serialized require a thread package?
    thread_pkg_required=yes
    MPICH_THREAD_LEVEL=MPI_THREAD_SERIALIZED
    ;;
    multiple)
    thread_pkg_required=yes
    MPICH_THREAD_LEVEL=MPI_THREAD_MULTIPLE
    ;;
    *)
    AC_MSG_ERROR(["$enable_threads" is not a valid value for --enable-threads])     
    ;;
esac
# Check that the requested thread level is available.
threadLevelOK=yes
if test -z "$MPID_MAX_THREAD_LEVEL" ; then
    if test "$MPICH_THREAD_LEVEL" = "MPI_THREAD_MULTIPLE" -o "$MPICH_THREAD_LEVEL" = "MPI_THREAD_SERIALIZED" ; then
        threadLevelOK=no
    fi
else
    # Check that MPID_MAX_THREAD_LEVEL is at least as large as the
    # selected MPICH_THREAD_LEVEL
    case $MPICH_THREAD_LEVEL in 
        MPI_THREAD_MULTIPLE)
	if test "$MPID_MAX_THREAD_LEVEL" != "MPI_THREAD_MULTIPLE" ; then
	    threadLevelOK=no
        fi
	;;
	MPI_THREAD_SERIALIZED)
	if test "$MPID_MAX_THREAD_LEVEL" != "MPI_THREAD_MULTIPLE" -a \
	        "$MPID_MAX_THREAD_LEVEL" != "MPI_THREAD_SERIALIZED" ; then
            threadLevelOK=no
        fi
	;;
	MPI_THREAD_FUNNELED)
        if test "$MPID_MAX_THREAD_LEVEL" = "MPI_THREAD_SINGLE" ; then
            threadLevelOK=no
        fi
	;;
	MPI_THREAD_SINGLE)
	;;
    esac
fi
if test "$threadLevelOK" != yes ; then
   AC_MSG_ERROR([The device $with_device does not support $MPICH_THREAD_LEVEL])
fi

export MPICH_THREAD_LEVEL
AC_DEFINE_UNQUOTED(MPICH_THREAD_LEVEL,$MPICH_THREAD_LEVEL,[Level of thread support selected at compile time])

if test "$thread_pkg_required" = "no" ; then
    MPIU_THREAD_DEFAULT=${MPIU_THREAD_DEFAULT:-none}
fi
export MPIU_THREAD_DEFAULT

# Check for value thread_cs choice; set the refcount default if necessary
thread_granularity=MPIU_THREAD_GRANULARITY_SINGLE
thread_refcount=MPIU_REFCOUNT_NONE
if test "$enable_threads" = "multiple" ; then
    case $enable_thread_cs in 
    global)
    thread_granularity=MPIU_THREAD_GRANULARITY_GLOBAL
    if test "$enable_refcount" = "default" ; then enable_refcount=none ; fi
    ;;
    brief-global|brief_global)
    AC_MSG_ERROR([--enable-thread-cs=brief-global is no longer supported, please select a different granularity])
    ;;
    per-object|per_object)
    thread_granularity=MPIU_THREAD_GRANULARITY_PER_OBJECT
    if test "$enable_refcount" = "default" ; then enable_refcount=lock ; fi
    ;;
    lock-free|lock_free|lockfree)
    thread_granularity=MPIU_THREAD_GRANULARITY_LOCK_FREE
    if test "$enable_refcount" = "default" ; then enable_refcount=lock-free ; fi
    if test "$enable_predefined_refcount" = "default" ; then enable_predefined_refcount=no ; fi
    ;;
    *)
    AC_MSG_ERROR([Unrecognized value $enable_thread_cs for --enable-thread-cs])
    ;;
    esac

    case $enable_refcount in
    lock)
    thread_refcount=MPIU_REFCOUNT_LOCK
    ;;
    lock-free|lock_free|lockfree)
    thread_refcount=MPIU_REFCOUNT_LOCKFREE
    ;;
    none)
    thread_refcount=MPIU_REFCOUNT_NONE
    ;;
    *)
    AC_MSG_ERROR([Unrecognized value $enable_refcount for --enable-refcount])
    ;;
    esac
fi
AC_DEFINE_UNQUOTED([MPIU_THREAD_GRANULARITY],$thread_granularity,[Method used to implement atomic updates and access])

if test "$enable_predefined_refcount" = "no" ; then
    AC_DEFINE([MPIU_THREAD_SUPPRESS_PREDEFINED_REFCOUNTS],[1],[define to disable reference counting predefined objects like MPI_COMM_WORLD])
fi

case $enable_handle_allocation in
    mutex|default)
        handle_allocation_method=MPIU_HANDLE_ALLOCATION_MUTEX
    ;;
    tls)
        handle_allocation_method=MPIU_HANDLE_ALLOCATION_THREAD_LOCAL
    ;;
    *)
        AC_MSG_ERROR([Unrecognized value $enable_handle_allocation for --enable-handle-allocation])
    ;;
esac
AC_DEFINE_UNQUOTED([MPIU_HANDLE_ALLOCATION_METHOD],$handle_allocation_method,[Method used to allocate MPI object handles])


AC_DEFINE_UNQUOTED([MPIU_THREAD_REFCOUNT],$thread_refcount,[Method used to implement refcount updates])

# enable-g
# strip off multiple options, separated by commas
save_IFS="$IFS"
IFS=","
for option in $enable_g ; do
    case "$option" in 
        debug|dbg)
        enable_append_g=yes
	;;
        no|none)
	;;
	handlealloc)
	perform_handlealloc=yes
	;;
	handle)
	AC_DEFINE(MPICH_DEBUG_HANDLES,1,[Define to enable handle checking])
	;;
	instr)
	perform_instr=yes
	;;
	meminit)
	perform_meminit=yes
	;;
	memarena)
	perform_memarena=yes
	perform_memtracing=yes
	;;
	mem)
	perform_memtracing=yes
	;;
	log)
	perform_dbglog=yes
	;;
	mutex)
	perform_dbgmutex=yes
	;;
	mutexnesting)
	perform_mutexnesting=yes
	;;
	all|yes)
	perform_memtracing=yes
	perform_dbglog=yes
	enable_append_g=yes
	perform_meminit=yes
	perform_instr=yes
	perform_dbgmutex=yes
	perform_mutexnesting=yes
	perform_handlealloc=yes
	;;
	*)
	IFS=$save_IFS
	AC_MSG_WARN([Unknown value $option for enable-g])
	IFS=","
	;;
    esac
done
IFS="$save_IFS"

if test "$enable_append_g" = "yes" ; then
    CFLAGS="$CFLAGS -g"
    CXXFLAGS="$CXXFLAGS -g"
    FFLAGS="$FFLAGS -g"
    FCFLAGS="$FCFLAGS -g"
fi
if test "$enable_append_ndebug" = "yes" ; then
    CFLAGS="$CFLAGS -DNDEBUG -DNVALGRIND"
    CXXFLAGS="$CXXFLAGS -DNDEBUG -DNVALGRIND"
    # MPICH2 do NOT assume any preprocessing support from the Fortran compiler,
    # so no Fortran files contain any preprocessing statements.
    # Don't set FFLAGS or FCFLAGS with any -D.
fi
if test -n "$perform_meminit" ; then
    AC_DEFINE(MPICH_DEBUG_MEMINIT,1,[Define to enable preinitialization of memory used by structures and unions])
fi
if test "$perform_handlealloc" = yes ; then
    AC_DEFINE(MPICH_DEBUG_HANDLEALLOC,1,[Define to enable checking of handles still allocated at MPI_Finalize])
fi
if test "$perform_instr" = yes ; then
    AC_DEFINE(USE_MPIU_INSTR,1,[Define this to enable internal instrumentation] )
fi

if test -n "$perform_memtracing" ; then
    enable_g_mem=yes
    AC_DEFINE(USE_MEMORY_TRACING,1,[Define to enable memory tracing])
    if test -n "$perform_memarena" ; then
        AC_DEFINE(MPICH_DEBUG_MEMARENA,1,[Define if each function exit should confirm memory arena correctness])
    fi
fi
if test -n "$perform_mutexnesting" ; then 
    AC_DEFINE(MPICH_DEBUG_MUTEXNESTING,1,[Define to check nesting in mutexes])
fi
if test -n "$perform_dbglog" ; then
   if test "$with_logging" != "none" ; then
       AC_MSG_WARN([--with-logging overrides --enable-g=log])
   else
       AC_DEFINE(USE_DBG_LOGGING,1,[Define to enable logging macros])
   fi
fi

if test -n "$perform_dbgmutex" ; then 
   AC_DEFINE(MPICH_DEBUG_MUTEX,1,[Define to enable mutex debugging])
fi

pac_cross_compiling=no
if test "$with_cross" != "no" ; then
    if test -s "$with_cross" ; then
        AC_MSG_RESULT([Reading values from cross-compilation file $with_cross])
        . $with_cross
	# Autoconf 2.52 no longer sets cross_compiling except with the
	# awkward "targethost" options.
	pac_cross_compiling=yes
	cross_compiling=yes
	ac_cv_prog_cc_cross=yes
	ac_cv_prog_f77_cross=yes
 	ac_cv_prog_fc_cross=yes
        ac_cv_prog_cxx_cross=yes
        export cross_compiling
	# Export all cross variables.  Any subsidiary configure should also
        # export CROSS_xxx
	rm -f confcross
	(set) 2>&1 | grep CROSS_ | \
	      sed -e 's/^/export /g' -e 's/=.*//g' > confcross
	. confcross
	rm -f confcross      
    fi
fi

if test "$enable_nmpi_as_mpi" = yes ; then
   AC_DEFINE(USE_MPI_FOR_NMPI,1,[Define if the NMPI names should use MPI instead of PMPI])
fi

# This goes here because we need the top_srcdir
if test "$enable_romio" = "yes" ; then
   if test -d $use_top_srcdir/src/mpi/romio ; then
       subsystems="$subsystems src/mpi/romio"
       AC_DEFINE(HAVE_ROMIO,1,[Define if ROMIO is enabled])
       # Set environment variables that the romio configure expects
       romio_dir=romio
       AC_SUBST(romio_dir)
       export use_top_srcdir
       top_build_dir=`pwd`
       export top_build_dir
       # if there is no $top_build_dir/lib, romio puts lib in wrong place
       # This test used -e under Linux, but not all test programs understand
       # -e
       if test ! -d lib ; then mkdir lib ; fi
       # tell mpi.h to include mpio.h
       PAC_HAVE_ROMIO
   else
       AC_MSG_WARN([ROMIO src directory is not available])
   fi
fi
#
# FIXME: If an external device, don't necessarily complain (e.g.,
# if the device is already built)
if test ! -d $devicedir ; then
dnl     WAIT UNTIL WE INCLUDE A DEVICE
dnl     AC_MSG_ERROR([Device $device_name is unknown)]
    AC_MSG_WARN([Device $device_name is unknown])
elif test ! -x $devicedir/configure ; then
    if test -s $devicedir/configure ; then
        AC_MSG_WARN([The configure in $devicedir exists but is not executable])
    else
        AC_MSG_WARN([Device $device_name has no configure])
    fi
    device_name=""
else 
    # Add the device to the configure list
    devsubsystems="$devsubsystems $devicereldir"
    # Make device_name available to subdirs
fi
#
# Allow the device to request that the install step invoke the install 
# target in the device's Makefile.
if test -n "$device_name" -a "$INSTALL_FROM_DEVICE" = yes ; then
    other_install_dirs="${other_install_dirs} $devicereldir"
fi
AC_SUBST(device_name)
#
# with-pm
if test "$with_pm" = "none" ; then
    # add "none" as synonym for "no" to agree with older erroneous docs
    with_pm="no"
fi
if test "$MPID_NO_PM" = yes ; then
    if test "$with_pm" != "default" -a "$with_pm" != no ; then
        AC_MSG_ERROR([The PM chosen ($with_pm) is is not valid for the selected device ($with_device)])
    fi
    # This is used to change with_pm=default to with_pm=no in the case
    # where the device does not want a PM
    with_pm=no
fi
if test -z "$with_pm" ; then
    with_pm="no"
fi
if test "$with_pmi" = "uni" -a "$with_pm" = "default" ; then
    with_pm="no"
fi
if test "$with_pm" = "default" -o "$with_pm" = "yes" ; then
    with_pm=hydra
fi

# We allow multiple pm names, separated by : or ,
# If multiple PMs are provided, we set the value MANY_PM to yes
MANY_PM=no
AC_SUBST(MANY_PM)
if test "$with_pm" != "no" ; then
    pm_names="`echo $with_pm | sed -e 's/:/ /g' -e 's/,/ /g'`"
else
    pm_names=""
fi
#
hasError=no
# We need to be careful about PM's that have either conflicting 
# requirements (e.g., different PMI implementations) or different
# optional features (e.g., MPID_PM_NAMESERVER).
# In addition, we need to interleave the setup of the PMI and PM
# modules.  The order is as follows:
#
# For each PM, execute the mpich2prereq script for that pm (if present).  
# This script provides information about the PM, including which PMI
# implementations are supported.
# 
# Then, for the selected PMI, the setup script (if any) is run.  This is
# necessary because the setup of the PM may require information discovered
# or provided duing the PMI setup step (e.g., smpd requires this)
#
# Finally, for each PM, the setup script is executed.
# 
# Step 1: invoke the mpich2prereq for each PM
for pm_name in $pm_names ; do
    if test -z "$first_pm_name" ; then
       first_pm_name=$pm_name
    else 
       # Only add to other_pm_names if the directory exists,
       # since the Makefile in src/pm/Makefile will try to cd to
       # that directory
       if test -d $use_top_srcdir/src/pm/$pm_name ; then
           other_pm_names="$other_pm_names $pm_name"
       fi
    fi
    if test ! -d $use_top_srcdir/src/pm/$pm_name ; then
        AC_MSG_WARN([$use_top_srcdir/src/pm/$pm_name does not exist. PM is unknown])
	hasError=yes
    elif test ! -x $use_top_srcdir/src/pm/$pm_name/configure ; then
        if test -s $use_top_srcdir/src/pm/$pm_name/configure ; then
	    AC_MSG_WARN([The configure in $use_top_srcdir/src/pm/$pm_name exists but is not executable])
        else
            AC_MSG_WARN([pm $pm_name has no configure])
        fi
        pm_name=""
	hasError=yes
    else
	nameserver=$MPID_PM_NAMESERVER
        if test -f $use_top_srcdir/src/pm/$pm_name/mpich2prereq ; then 
	    echo sourcing $use_top_srcdir/src/pm/$pm_name/mpich2prereq
	    . $use_top_srcdir/src/pm/$pm_name/mpich2prereq
	fi
	# Check for a change; if found, we'll take the default
	if test "$MPID_PM_NAMESERVER" != "$nameserver" ; then
            if test "$first_pm_name" != "$pm_name" ; then
	        # Reject suggestion (use the default, common mode)
		MPID_PM_NAMESERVER=""
	    fi
	fi
    fi
done
if test "$hasError" != no ; then
    AC_MSG_ERROR([Aborting configure because an error was seen in the selection of process managers])
fi
#
# pm_name is the *primary* pm
pm_name=$first_pm_name
AC_SUBST(pm_name)
AC_SUBST(other_pm_names)

# Some versions of PM and PMI require a special definition (currently, only
# smpd requires this)
if test "$PMI_REQUIRES_READABLE_TOKENS" = "yes" ; then
    AC_DEFINE(USE_HUMAN_READABLE_TOKENS,1,[Define to use ='s and spaces in the string utilities.])
fi

if test -n "$first_pm_name" ; then
    other_install_dirs="${other_install_dirs} src/pm/$first_pm_name"
fi
# Step 2:
# Once we've selected the process manager (or managers), we can
# check that we have a compatible PMI implemenatation.
# with-pmi
if test "$MPID_NO_PMI" = yes ; then
    if test "$with_pmi" != "default" -a "$with_pmi" != no ; then
        AC_MSG_ERROR([The PMI chosen ($with_pmi) is is not valid for the selected device ($with_device)])
    fi
    # This is used to change with_pmi=default to with_pmi=no in the case
    # where the device does not want a PMI
    with_pmi=no
elif test "$with_pmi" != "no" ; then
    if test "$with_pmi" = "default" -o "$with_pmi" = "yes" ; then
        if test -n "$PM_REQUIRES_PMI" ; then
	    with_pmi=$PM_REQUIRES_PMI
        else
            with_pmi=simple
        fi
    elif test -n "$PM_REQUIRES_PMI" ; then
        # Test for compatibility between pm and pmi choices
        if test "$PM_REQUIRES_PMI" != "$with_pmi" ; then
	    AC_MSG_ERROR([The PM chosen ($with_pm) requires the PMI implementation $PM_REQUIRES_PMI but $with_pmi was selected as the PMI implementation.])
        fi
    fi
    pmi_name=$with_pmi
    
    if test ! -d $use_top_srcdir/src/pmi/$pmi_name ; then
        AC_MSG_WARN([$use_top_srcdir/src/pmi/$pmi_name does not exist. PMI is unknown])
    elif test ! -x $use_top_srcdir/src/pmi/$pmi_name/configure ; then
        AC_MSG_WARN([pmi $pmi_name has no configure or Makefile])
        pmi_name=""
    else
        subsystems="$subsystems src/pmi/$pmi_name"
    fi
else
    AC_MSG_ERROR([A PMI implementation must be selected or the default used.])
fi
AC_SUBST(pmi_name)

# Step 3: complete pm setup.
# Note that checks for errors have already been performed, so this
# loop does not need to perform any extra error checks.
# Note that this uses this_pm_name because pm_name must be the *first*
# of the PM names
for this_pm_name in $pm_names ; do
    subsystems="$subsystems src/pm/$this_pm_name"
    if test -f $use_top_srcdir/src/pm/$this_pm_name/setup_pm ; then 
	echo sourcing $use_top_srcdir/src/pm/$this_pm_name/setup_pm
	. $use_top_srcdir/src/pm/$this_pm_name/setup_pm
    fi
done

# ----------------------------------------------------------------------------
if test $with_mpe != no ; then
    if test ! -d $use_top_srcdir/src/mpe2 ; then
        if test $with_mpe = yes ; then
	    # No warning message on the default
            AC_MSG_WARN([No MPE directory available])
        fi
    elif test ! -x $use_top_srcdir/src/mpe2/configure ; then
        if test $with_mpe = yes ; then
	    # No warning message on the default
            AC_MSG_WARN([No configure available for MPE])
        fi
    else
        subsystems="$subsystems src/mpe2"
	other_install_dirs="$other_install_dirs src/mpe2"
	mpe_dir=mpe2
	# Temporarily replace the default NONE value for exec_prefix
	# and prefix with the actual, default values.
	savePrefix=$prefix
	saveExecprefix=$exec_prefix
	test "x$prefix" = xNONE && prefix=$ac_default_prefix
	test "x$exec_prefix" = xNONE && exec_prefix=$prefix
	eval actualbindir=$bindir
	# MPI_CC and MPIF77 must use the local (build) bin dir, not
	# the installation bin dir
	#MPI_CC=$actualbindir/mpicc
	#MPI_F77=$actualbindir/mpif77
	#eval actuallibdir=$libdir
	#MPI_LIBS="-L$actuallibdir -lmpich -lpmpich"
	buildbindir=`pwd`/bin
	MPI_CC=$buildbindir/mpicc
	MPI_F77=$buildbindir/mpif77
	prefix=$savePrefix
	exec_prefix=$saveExecprefix
	# NOTE: You must append LIBS to MPI_LIBS before invoking the mpe
	# configure
	export MPI_CC
	export MPI_F77
	#export MPI_LIBS
        export use_top_srcdir
        top_build_dir=`pwd`
        export top_build_dir
    fi
fi
AC_SUBST(mpe_dir)
AC_SUBST(other_install_dirs)

# Check whether shared libraries are enabled.  We need to know this
# before we start chosing the Fortran, Fortran 90, and C++ compilers
ENABLE_SHLIB=$enable_sharedlibs
if test -z "$ENABLE_SHLIB" -o "$ENABLE_SHLIB" = "no" ; then
    ENABLE_SHLIB=none
fi
# We need the script that is used to create shared libraries if either
# we are creating shared libraries for MPICH2 or we are creating the
# dynamically loadable library for the debugger interface
CREATESHLIB=false
if test "$ENABLE_SHLIB" != "none" -o "$enable_debuginfo" != "no" ; then
   CREATESHLIB=`pwd`/src/util/createshlib
fi
AC_SUBST(CREATESHLIB)

# Check for whether the compiler defines a symbol that contains the 
# function name.  The MPICH2 code, for greater portability, defines
# its own symbols, FCNAME (a string) and FUNCNAME (a token that is not a 
# string).  Code should use these symbols where possible.  However, 
# some debugging macros may want to use a compiler-provided symbol
# for the function name, and this check makes it possible to 
# define such macros in a way that is always correct.
PAC_CC_FUNCTION_NAME_SYMBOL

# Check if $MPI_DEFAULT_COPTS is valid with $CC
if test "$enable_default_optimize" = "yes" \
     -a -n "$MPI_DEFAULT_COPTS" ; then
    if test "$enable_check_compiler_flags" = "yes" ; then
        PAC_C_CHECK_COMPILER_OPTION( [$MPI_DEFAULT_COPTS], [
        CFLAGS="$CFLAGS $MPI_DEFAULT_COPTS"
                                   ] )
    else
        CFLAGS="$CFLAGS $MPI_DEFAULT_COPTS"
    fi
fi

# Check for support for weak symbols.  If not found, set NO_WEAK_SYM
# to the Make target name understood by simplemake.
# Set NEEDSPLIB to yes if link commands need both -l$MPILIBNAME
# and -lp$MPILIBNAME.
NEEDSPLIB=yes
NO_WEAK_SYM_TARGET=build_proflib
if test $enable_weak_symbols = yes ; then
    # Turn off weak symbols if they aren't available
    PAC_PROG_C_WEAK_SYMBOLS(,enable_weak_symbols=no)
fi
if test $enable_weak_symbols = "yes" ; then
    AC_DEFINE(USE_WEAK_SYMBOLS,1,[Define if weak symbols should be used])
    NEEDSPLIB=no
    # Check for the ability to support multiple weak symbols
    if test "$pac_cv_prog_c_weak_symbols" = "pragma weak" ; then
       PAC_PROG_C_MULTIPLE_WEAK_SYMBOLS(AC_DEFINE(HAVE_MULTIPLE_PRAGMA_WEAK,1,[Define if multiple weak symbols may be defined]))
    fi
else
    NO_WEAK_SYM=build_proflib
    PROFILE_DEF_MPI="-DMPICH_MPI_FROM_PMPI"
fi
export NEEDSPLIB
export NO_WEAK_SYM
export NO_WEAK_SYM_TARGET
export PROFILE_DEF_MPI
AC_SUBST(NEEDSPLIB)
AC_SUBST(NO_WEAK_SYM)
AC_SUBST(NO_WEAK_SYM_TARGET)
AC_SUBST(PROFILE_DEF_MPI)

# ---------------------------------------------------------------------------
# Support for the language bindings: Fortran 77, Fortran 90, and C++
#
# First, we handle the case of no explicit enable/disable option.  In that
# case, we look for a usable compiler.  We cannot use the ac macros for this
# because they abort the configure step if they fail to find a compiler 
# (earlier versions of autoconf did not have this behavior!).
#
# Second, we perform the langugage-specific tests, if necessary.  This may
# be relatively simple (C++) or complex (Fortran 77, including formation of 
# the encoded MPI handles).
#
# Note that the bindings support needs to know some of the properties of
# the C compiler, so those tests (particularly for weak symbols)
# must come first.
# ----------------------------------------------------------------------------

#
# First, determine whether we are/can support the language bindings
#
# Since F90/F90FLAGS are replaced by FC/FCFLAGS, rather than silently
# substituting them, i.e. FC=$F90 and FCFLAGS=$F90FLAGS, we choose to emit
# an error message and abort to avoid any ambiguous/hidden bug in choosing
# Fortran90 compilers.
if test -n "$F90" -o -n "$F90FLAGS" ; then
    AC_MSG_ERROR([F90 and F90FLAGS are replaced by FC and FCFLAGS respectively in this configure, please unset F90/F90FLAGS and set FC/FCFLAGS instead and rerun configure again.])
fi
# ----------------------------------------------------------------------------
# Handle default choices for the Fortran compilers
if test "$enable_f77" = "yes" ; then
    # Check for a Fortran compiler
    PAC_PROG_F77
fi

if test "$enable_f77" = "yes" -a "$F77" = "" ; then
   # No Fortran 77 compiler found; abort
   AC_MSG_ERROR([No Fortran 77 compiler found. If you don't need to
   build any Fortran programs, you can disable Fortran support using
   --disable-f77 and --disable-fc. If you do want to build Fortran
   programs, you need to install a Fortran compiler such as gfortran
   or ifort before you can proceed.])
fi

if test "$enable_f77" = yes ; then
    # Check if $MPI_DEFAULT_FOPTS is valid with $F77
    if test "$enable_default_optimize" = "yes" \
         -a -n "$MPI_DEFAULT_FOPTS" ; then
        if test "$enable_check_compiler_flags" = "yes" ; then
            PAC_F77_CHECK_COMPILER_OPTION( [$MPI_DEFAULT_FOPTS], [
            FFLAGS="$FFLAGS $MPI_DEFAULT_FOPTS"
                                         ] )
        else
            FFLAGS="$FFLAGS $MPI_DEFAULT_FOPTS"
        fi
    fi
fi

#
# We need to know the name mangling for Fortran before testing for FC
# compatibility (we need this because of the way we decide to generate
# the Fortran 77 bindings)
if test "$enable_f77" = yes ; then
    FLIBS_save="$FLIBS"
    FLIBS=""
    AC_F77_LIBRARY_LDFLAGS
    # The autoconf macro for finding FLIBS sometimes makes mistakes
    # (particularly with the Fujitsu frt compiler).  This next step
    # first sees if the FLIBS is valid with the Fortran compiler
    PAC_PROG_F77_FLIBS_VALID
    # Now see if FLIBS works with the C compiler
    PAC_PROG_F77_CHECK_FLIBS

    # Check F77+FLAGS is compatible with CC+CFLAGS before using F77+CC.
    PAC_PROG_F77_OBJ_LINKS_WITH_C

    PAC_PROG_F77_LINKER_WITH_C
    # For name mangle, we need the library flags
    PAC_PROG_F77_NAME_MANGLE
    # Check whether additional libraries are needed when linking with C
    PAC_PROG_F77_AND_C_STDIO_LIBS
    AC_SUBST(F77_OTHER_LIBS)

    # Warn about mixed name mangling, since many of the tests will fail
    if test "$pac_cv_prog_f77_name_mangle" = "mixed" ; then
        AC_MSG_WARN([The compiler $F77 uses mixed case names.  Fortran is monocase
and many Fortran programs may use either upper or lower case names for MPI
calls.  Consider specifying a particular parameter to your Fortran compiler
to select either upper or lower case names.  For the Absoft compiler, 
-f selects lower case and -N109 selects upper case (if you use -f, also use 
-B108 to enable the iargc and getarg routines, which are needed for some
tests and by many user programs).  Specify new command
line options by setting the environment variable FFLAGS to include
the options (e.g., setenv FFLAGS "-f -B108").  In addition, make sure that your
Fortran 90 compiler uses a compatible naming choice.  For the 
Absoft Fortran 90, -YALL_NAMES=LCS selects lower case names and -B108 
adds underscores to names, as required for iargc and getarg.  Pass this
information to configure with the FCFLAGS environment variable.])
        # If Fortran implicitly enabled, disable it now.  Otherwise,
	# abort the configure since warning messages are often lost in
	# the output.
	AC_MSG_ERROR([Aborting configure because of mixed case names in Fortran.  Either select --disable-f77 or set FFLAGS to force the compiler to select monocase names])
    fi

    # The MPI standard requires that MPI_Init in any language initialize
    # MPI in all languages.  This can be a problem when objects produced 
    # by the Fortran compiler require symbols from the Fortran runtime
    # (making linking C-only programs unnecessarily difficult).  What we test 
    # here is whether the much more restricted needs of the Fortran 
    # initialize can be met with no special use of the Fortran runtime
   PAC_F77_INIT_WORKS_WITH_C
   if test "$pac_f_init_works_with_c" = "yes" ; then
       AC_DEFINE(HAVE_MPI_F_INIT_WORKS_WITH_C,1,[Define if the Fortran init code for MPI works from C programs without special libraries])
   fi

fi

# FC requires F77 as well.  If the user disabled f77, do not run the
# next test; instead, drop into the warning message
# Set a default value for fc works with f77.  This value is
# set to no *only* if fc was selected but was not compatible with f77
fc_with_f77=yes
if test "$enable_fc" = "yes" -a "$enable_f77" = yes ; then
    enable_fc=no
    # Check for a Fortran compiler.  Work around bug in autoconf that 
    # adds -g to FCFLAGS
    saveFCFLAGS="$FCFLAGS"
    PAC_PROG_FC
    FCFLAGS=$saveFCFLAGS
    if test -n "$FC" ; then 
        if test -z "$F77" ; then
	    PAC_PROG_F77
	fi
	#
	# If we allow multiple weak symbols, we should test a name
	# that does not contain an underscore.  The Fortran binding uses
	# this rule for enabling multiple weak symbols:
	# if defined(USE_WEAK_SYMBOLS) && !defined(USE_ONLY_MPI_NAMES) &&
	#    defined(HAVE_MULTIPLE_PRAGMA_WEAK) && 
	#    defined(F77_NAME_LOWER_2USCORE)
	# 
	testRoutine="t1_2"
	if test "$pac_cv_prog_c_multiple_weak_symbols" = "yes" -a \
               "$enable_weak_symbols" = "yes" -a \
	       "$pac_cv_prog_f77_name_mangle" = "lower doubleunderscore" ; then
	    testRoutine="t12"
        fi
        PAC_FC_AND_F77_COMPATIBLE(fc_with_f77=yes,fc_with_f77=no,$testRoutine)
        if test "$fc_with_f77" != yes ; then
	    enable_fc=no
	    AC_MSG_WARN([The selected Fortran 90 compiler $FC does not work with the selected Fortran 77 compiler $F77.  Use the environment variables FC and F77 respectively to select compatible Fortran compilers.  The check here tests to see if a main program compiled with the Fortran 90 compiler can link with a subroutine compiled with the Fortran 77 compiler.])
        elif test "$fc_with_f77" = "yes" ; then
            # If we got here, there is a Fortran 90 compiler that we can use
            enable_fc=yes
        fi
    elif test "$pac_cv_prog_fc_works" = no; then
        AC_MSG_WARN([Use --disable-fc to keep configure from searching for a Fortran 90 compiler])
    fi

    if test "$enable_fc" = "yes" -a "$FC" = "" ; then
       # No Fortran 90 compiler found; abort
       AC_MSG_ERROR([No Fortran 90 compiler found. If you don't need
       to build any Fortran 90 programs, you can disable Fortran 90
       support using --disable-fc. If you do want to build Fortran 90
       programs, you need to install a Fortran 90 compiler such as
       gfortran or ifort before you can proceed.])
    fi
fi

if test "$enable_fc" = "yes" -a "$enable_f77" != "yes" ; then
   # Fortran 90 support requires compatible Fortran 77 support
   AC_MSG_ERROR([
Fortran 90 support requires compatible Fortran 77 support.
To force the use of the Fortran 90 compiler for Fortran 77,
do not use configure option --disable-f77, and set the environment
variable F77 to the name of the Fortran 90 compiler, or \$FC.
If you do not want any Fortran support, use configure options
--disable-f77 and --disable-fc.])
   # We should probably do the compatibility test as well
   enable_f77=yes
fi

# ----------------------------------------------------------------------------
# Now test for Fortran compiler characteristics
# ----------------------------------------------------------------------------
if test "$enable_f77" = "yes" ; then
    AC_LANG_FORTRAN77
    PAC_PROG_F77_EXCLAIM_COMMENTS(has_exclaim="yes",has_exclaim="no")
    PAC_PROG_F77_HAS_INCDIR(src)
    if test -n "$F77_INCDIR" ; then
        # For building the Fortran files, add the directory where we are building 
        # the object to the include list.  This is needed for g77, which makes
        # includes relative to the source directory of the file, not the 
        # directory that the command is executed in
        FINCLUDES="$F77_INCDIR`pwd`/src"
    fi
    AC_SUBST(FINCLUDES)
    #
    PAC_PROG_F77_LIBRARY_DIR_FLAG

    AC_SUBST(MPIFPMPI)
    if test "$MPI_WITH_PMPI" = "no" ; then
        # If the PMPI routines are not in the same library with the MPI
        # routines, we may need to remove the pmpi declarations
        PAC_PROG_F77_ALLOWS_UNUSED_EXTERNALS([MPIFPMPI=",PMPI_WTIME,PMPI_WTICK"],[
        MPIFPMPI=""; 
        AC_MSG_WARN([Removed PMPI_WTIME and PMPI_WTICK from mpif.h])])
    else
        MPIFPMPI=",PMPI_WTIME,PMPI_WTICK"
    fi

    # Once we have name mangle, we can try to limit the number of needed libs
    dnl F77_IN_C_LIBS is not needed currently because mpirinitf_() in setbotf.f
    dnl is called in initthread.c only when FLIBS is not needed to initialize
    dnl Fortran constants from a C main, See PAC_F77_INIT_WORKS_WITH_C.
    dnl PAC_PROG_F77_IN_C_LIBS
    dnl AC_SUBST(F77_IN_C_LIBS)

    # ------------------------------------------------
    # Shared library support
    # ------------------------------------------------
# Note that USE_GCC_G77_DECLS is not used anywhere within the code, so
# this check has been commented out.
dnl    # If both C and Fortran are gnu, define the following to simplify 
dnl    # shared library support.  
dnl    AC_MSG_CHECKING([whether using gcc and g77 together])
dnl    if test "$ac_cv_prog_gcc" = "yes" -a "$ac_cv_prog_g77" = "yes" ; then
dnl        # FIXME: Who uses this definition?
dnl        AC_DEFINE(USE_GCC_G77_DECLS,1,[Define if using gcc and g77 together])
dnl        AC_MSG_RESULT(yes)
dnl    else 
dnl        AC_MSG_RESULT(no)
dnl    fi
    AC_SUBST(F77_SHL)
    AC_SUBST(F77_LINKPATH_SHL)
    case "$ENABLE_SHLIB" in
	 gcc-osx|osx-gcc)
	 F77_SHL="$F77 -fPIC"
	 F77_LINKPATH_SHL=""
	 ;;
	 gcc)
	 # Assume that the compiler is g77 if gcc style shared libraries chosen
	 # (unfortunately, the name may be g77 or f77)
	 # To make this a little more robust, only add the -shared
	 # if the compiler allows it (e.g., building with gcc but
	 # a different Fortran compiler. Another option is to
	 # *require* g77.
         AC_LANG_PUSH([Fortran 77])
         AC_LANG_CONFTEST([
             AC_LANG_SOURCE([
                program main
                end
             ])
         ])
         saved_FFLAGS="$FFLAGS"
         F77_SHL=false
         for sh_arg in "-shared -fPIC" "-fPIC" "-shared -fpic" "-fpic" "-KPIC" ; do
 	     AC_MSG_CHECKING([whether $F77 allows $sh_arg])
             FFLAGS="$sh_arg $saved_FFLAGS"
             AC_LINK_IFELSE([],[
	         F77_SHL="$F77 $sh_arg"
                 AC_MSG_RESULT(yes)
                 break
             ],[
                 AC_MSG_RESULT(no)
             ])
	 done
         FFLAGS="$saved_FFLAGS"
	 if test "$F77_SHL" = "false" ; then
	     AC_ERROR([Cannot build shared libraries for Fortran with this compiler])
         fi
         rm -f confest.$ac_ext
         AC_LANG_POP([Fortran 77])
	 if test "$enable_rpath" = yes ; then 
	      F77_LINKPATH_SHL="-Wl,-rpath -Wl,"
	 fi
	 ;;

	 cygwin|cygwin-gcc)
	 F77_SHL="$F77 -shared"
	 F77_LINKPATH_SHL=""
	 ;;

	 solaris|solaris-cc)
	 F77_SHL="$F77 -xcode=pic32"
	 if test "$enable_rpath" = yes ; then 
             F77_LINKPATH_SHL=-R
         fi
	 ;;

	 # Do we need a solaris-64 with -xcode=pic64?

	 libtool)
	 F77_SHL='${LIBTOOL} --mode=compile ${F77}'
	 if test "$enable_rpath" = yes ; then 
             F77_LINKPATH_SHL="-rpath "
         fi
	 ;;

	 *)
	 F77_SHL=false
	 ;;
    esac
    # ------------------------------------------------

    #
    # Most systems allow the Fortran compiler to process .F and .F90 files
    # using the C preprocessor.  However, some systems either do not
    # allow this or have serious bugs (OSF Fortran compilers have a bug
    # that generates an error message from cpp).  The following test
    # checks to see if .F works, and if not, whether "cpp -P -C" can be used
    # This is needed for Mac OSX 10.5
    PAC_F77_WORKS_WITH_CPP([F77CPP])
    AC_SUBST(F77CPP)

    bindings="$bindings f77"
    bindings_dirs="$bindings_dirs src/binding/f77"
    AC_DEFINE(HAVE_FORTRAN_BINDING,1,[Define if Fortran is supported])
    # Also define the name FORTRAN_BINDING for use in #if @FORTRAN_BINDING@..
    FORTRAN_BINDING=1

fi

dnl By modifying mpif.h to use ! for comments, it can work with many f90 
dnl compilers without creating a separate version.  
dnl Note that this is run AFTER the AC_OUTPUT actions
AC_OUTPUT_COMMANDS([if test "$enable_f77" = yes ; then 
if test "$bashWorks" = yes ; then cp -f src/env/mpif77.bash src/env/mpif77 ; fi
chmod a+x src/env/mpif77
if test "$has_exclaim" = "yes" ; then
    sed -e 's/^C/\!/g' src/binding/f77/mpif.h > src/include/mpif.h
	cp src/include/mpif.h src/binding/f77/mpif.h
else
    cp src/binding/f77/mpif.h src/include
fi
if test "$has_fort_real8" = "yes" ; then
    sed -e 's/DOUBLE PRECISION/REAL*8/g' src/include/mpif.h > src/include/mpif.h.new
    mv src/include/mpif.h.new src/include/mpif.h
    cp src/include/mpif.h src/binding/f77/mpif.h
fi

if test ! -d bin  ; then mkdir bin ; fi 
sed -e 's%includedir=.*%includedir='$includebuild_dir% \
    -e 's%libdir=.*%libdir='$libbuild_dir% \
    src/env/mpif77 > bin/mpif77 ;
chmod a+x bin/mpif77
else
    rm -f src/env/mpif77 src/env/mpif77.conf
fi],
master_top_srcdir=$master_top_srcdir
enable_f77=$enable_f77
enable_fc=$enable_fc
has_exclaim=$has_exclaim
has_fort_real8=$pac_cv_fort_real8
includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir
bashWorks=$bashWorks)

if test "$enable_fc" = "yes" ; then
    if test "$enable_f77" != "yes" ; then
        AC_MSG_WARN([Fortran 90 requires Fortran 77])
        enable_fc=no
    else 
        bindingsubsystems="$bindingsubsystems src/binding/f90"
        bindings="$bindings f90"
        bindings_dirs="$bindings_dirs src/binding/f90"
    fi
fi

# Set defaults for these values so that the Makefile in src/bindings/f90
# is valid even if fc is not enabled (this is necessary for the 
# distclean target)
MPIMODNAME=mpi
MPICONSTMODNAME=mpi_constants
MPISIZEOFMODNAME=mpi_sizeofs
MPIBASEMODNAME=mpi_base
if test "$enable_fc" = "yes" ; then
    # Determine characteristics of the Fortran 90 compiler
    # Find a Fortran 90 compiler.  Sets FC
    # Work around bug in autoconf that adds -g to FCFLAGS
    saveFCFLAGS="$FCFLAGS"
    PAC_PROG_FC
    PAC_PROG_FC_WORKS
    FCFLAGS=$saveFCFLAGS
    if test "$pac_cv_prog_fc_works" = no ; then 
        # Reject this compiler
        if test -n "$FC" ; then
            fc_rejected=yes
            oldFC="$FC"
            FC=""
        fi
    fi

    # Determine the extension for Fortran 90 files (it isn't always .f90)
    FCEXT=$ac_fc_srcext
    AC_SUBST(FCEXT)

    if test -z "$FC" ; then
        if test "$fc_rejected" = "yes" ; then
            AC_MSG_ERROR([Could not find a usable Fortran 90 compiler.  The compiler $oldFC may be incompatible with the Fortran 77 compiler $F77; check the output of configure and consult the installation manuals])
        else
            AC_MSG_ERROR([Could not find a usable Fortran 90 compiler.])
        fi
    fi

    # Find the extension that this compiler uses for modules.
    # Sets FCMODEXT (and adds it to the list substed)
    # Sets FCMODINCFLAG (and adds it to the list substed)
    PAC_FC_MODULE
    AC_SUBST(FCMODINCSPEC)
    if test "$pac_cv_fc_module_case" = "upper" ; then
        MPIMODNAME=MPI
        MPICONSTMODNAME=MPI_CONSTANTS
	MPISIZEOFMODNAME=MPI_SIZEOFS
	MPIBASEMODNAME=MPI_BASE
    else
        MPIMODNAME=mpi
        MPICONSTMODNAME=mpi_constants
	MPISIZEOFMODNAME=mpi_sizeofs
	MPIBASEMODNAME=mpi_base
    fi
    AC_SUBST(MPIMODNAME)
    AC_SUBST(MPICONSTMODNAME)
    AC_SUBST(MPISIZEOFMODNAME)
    AC_SUBST(MPIBASEMODNAME)
    if test -z "$modincdir" ; then
        # The default module include dir is the same as the include dir
        modincdir=$includedir
    fi
    AC_SUBST(modincdir)    
    #
    # Assume that all Fortran 90 compilers accept -I for include directories
    FCINC=-I
    AC_SUBST(FCINC)
    FCINCFLAG=-I
    AC_SUBST(FCINCFLAG)

    # Check if $MPI_DEFAULT_FCOPTS is valid with $F90
    if test "$enable_default_optimize" = "yes" \
         -a -n "$MPI_DEFAULT_FCOPTS" ; then
        if test "$enable_check_compiler_flags" = "yes" ; then
            PAC_FC_CHECK_COMPILER_OPTION( [$MPI_DEFAULT_FCOPTS], [
            FCFLAGS="$FCFLAGS $MPI_DEFAULT_FCOPTS"
                                     ] )
        else
            FCFLAGS="$FCFLAGS $MPI_DEFAULT_FCOPTS"
        fi
    fi

    # Most systems allow the Fortran compiler to process .F and .F90 files
    # using the C preprocessor.  However, some systems either do not
    # allow this or have serious bugs (OSF Fortran compilers have a bug
    # that generates an error message from cpp).  The following test
    # checks to see if .F works, and if not, whether "cpp -P -C" can be used
    PAC_FC_WORKS_WITH_CPP([FCCPP])
    AC_SUBST(FCCPP)

    # Check whether additional libraries are needed when linking with C
    PAC_PROG_FC_AND_C_STDIO_LIBS
    AC_SUBST(FC_OTHER_LIBS)

    # ------------------------------------------------
    # ------------------------------------------------
    # Here are the commands to substitute the compilers to be used to create
    # shared libraries.  The choices for the first two come down from the
    # top-level configure.  FC_SHL must be determined in this configure
    AC_SUBST(FC_SHL)
    AC_SUBST(FC_LINKPATH_SHL)

    # Try to get a version string for the F90 compiler.  We may
    # need this to find likely command-line arguments for accessing
    # shared libraries
    PAC_FC_VENDOR

    if test "$ENABLE_SHLIB" != none ; then
        AC_MSG_CHECKING([for how to build shared libraries for Fortran 90])
        case "$ENABLE_SHLIB" in
	 gcc-osx|osx-gcc)
	 FC_SHL="$FC -fPIC"
	 FC_LINKPATH_SHL=""
	 ;;
         gcc)
         if test "$pac_cv_fc_vendor" = gnu -o "$FC" = "g95" ; then
            # If we have the GNU Fortran 95 compiler (untested)
            FC_SHL="$FC -shared -fPIC"
	    if test "$enable_rpath" = yes ; then 
                FC_LINKPATH_SHL="-Wl,-rpath -Wl,"
            fi
         else
            case "$pac_cv_fc_vendor" in 
	        absoft)
	        FC_SHL="$FC -fPIC"
		if test "$enable_rpath" = yes ; then 
                    FC_LINKPATH_SHL="-X -rpath -X "
                fi
	        ;;

	        intel)
	        # Intel implements the GNU options
	        FC_SHL="$FC -shared -fPIC"
		if test "$enable_rpath" = yes ; then 
                    FC_LINKPATH_SHL="-Wl,-rpath -Wl,"
		fi
	        ;;

	        pgi)
	        # Portland Group implements the GNU options
	        FC_SHL="$FC -shared -fPIC"
		if test "$enable_rpath" = yes ; then 
                    FC_LINKPATH_SHL="-Wl,-rpath -Wl,"
		fi
	        ;;
		
		sun)
		# Sun studio compiler on Linux
		FC_SHL="$FC -KPIC"
		if test "$enable_rpath" = yes ; then 
		    FC_LINKPATH_SHL="-Qoption ld -rpath,"
		fi
		;;

	        *)
	        # Unknown, ignore
	        ;;
            esac
            fi
            ;;
         solaris|solaris-cc)
            # Assume the Solaris F90 compiler, in 32-bit mode
            FC_SHL="$FC -xcode=pic32"
            FC_LINKPATH_SHL=-R
         ;;

	 libtool)
	 FC_SHL='${LIBTOOL} --mode=compile ${FC}'
	 if test "$enable_rpath" = yes ; then 
             FC_LINKPATH_SHL="-rpath "
         fi
	 ;;

         *)
         # Unknown, ignore
         ;;
        esac
	if test -n "$FC_SHL" ; then 
	    AC_MSG_RESULT([Compile with $FC_SHL and link using path argument $FC_LINKPATH_SHL])
        else
            AC_MSG_WARN([Unable to determine how to link Fortran 90 compiler with shared libraries])
 	    FC_SHL=false
	fi
    fi

dnl  Some systems don't require or accept linkpath arguments.
dnl    if test "$ENABLE_SHLIB" != "none" -a -z "$FC_LINKPATH_SHL" -a \
dnl        -n "$C_LINKPATH_SHL" ; then
dnl        AC_MSG_WARN([Unable to determine how to pass the shared-library link path to the Fortran 90 compiler $FC.  Set the environment variable FC_LINKPATH_SHL and rerun configure (the corresponding value for the C compiler is $C_LINKPATH_SHL)])
dnl    fi
    # ------------------------------------------------
fi

AC_OUTPUT_COMMANDS([if test $enable_fc = yes ; then 
if test "$bashWorks" = yes ; then cp -f src/env/mpif90.bash src/env/mpif90 ; fi
chmod a+x src/env/mpif90
if test ! -d bin  ; then mkdir bin ; fi 
sed -e 's%includedir=.*%includedir='$includebuild_dir% \
    -e 's%modincdir=.*%modincdir='$modincbuild_dir% \
    -e 's%libdir=.*%libdir='$libbuild_dir% \
    src/env/mpif90 > bin/mpif90 ;
chmod a+x bin/mpif90 
else
    rm -f src/env/mpif90 src/env/mpif90.conf bin/mpif90
fi
],
enable_fc=$enable_fc
modincbuild_dir=$modincbuild_dir
includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir
bashWorks=$bashWorks)

# ----------------------------------------------------------------------------
# By default, only build C++ if there is a C++ compiler (if we don't 
# test here, the configure can fail if there is no C++ compiler available)
if test "$enable_cxx" = "default" ; then
    # This test uses the list from a recent PROG_CXX, but with the
    # addition of the Portland group, IBM, and Intel C++ compilers
    # (While the Intel icc compiler will compile C++ programs, it will
    # not *link* C++ object files unless there is at least one C++ source
    # file present on the command that performs the linking.  icpc is the
    # Intel C++ compiler that both compiles and links C++ programs)
    AC_CHECK_PROGS(CXX,$CCC c++ g++ gcc CC cxx cc++ cl pgCC xlC icpc pathCC)
    if test -n "$CXX" ; then
        enable_cxx=yes
    fi
fi

if test "$enable_cxx" = "yes" ; then
    PAC_PROG_CXX
    # Another bug in autoconf.  The checks for the C++ compiler do not
    # ensure that you can link a program that is built with the C++ 
    # compiler.  We've seen this error with gcc and icc, particularly
    # when those compilers accept C++ language elements but are unable
    # to link programs that are really C++.  For that reason,
    # we've added a test to see if the C++ compiler can produce
    # an executable.
    AC_CACHE_CHECK([whether the C++ compiler $CXX can build an executable],
    pac_cv_cxx_builds_exe,[
 AC_LANG_SAVE
 AC_LANG_CPLUSPLUS
 AC_TRY_LINK([
class mytest { 
  int a;
public:
  mytest(void) : a(1) {}
  ~mytest(void) {}
};],[mytest a;],
 pac_cv_cxx_builds_exe=yes, ac_cv_builds_exe=no)
 AC_LANG_RESTORE
])
    if test "$pac_cv_cxx_builds_exe" != yes ; then
        AC_MSG_ERROR([Aborting because C++ compiler does not work.  If you do not need a C++ compiler, configure with --disable-cxx])
    fi
    # Recent failures have come when a standard header is loaded
    # The Intel icpc 10.x compiler fails with <string> if gcc 4.2 is installed. 
    AC_CACHE_CHECK([whether C++ compiler works with string],pac_cv_cxx_compiles_string,[
    AC_LANG_SAVE
    AC_LANG_CPLUSPLUS
    AC_TRY_COMPILE([#include <string>],[return 0;],pac_cv_cxx_compiles_string=yes,pac_cv_cxx_compiles_string=no)
    AC_LANG_RESTORE
])
    if test "$pac_cv_cxx_compiles_string" != yes ; then 
        AC_MSG_WARN([The C++ compiler $CXX cannot compile a program containing the <string> header - this may indicate a problem with the C++ installation.  Consider configuing with --disable-cxx])
    fi

    AC_LANG_CPLUSPLUS
    AC_CXX_EXCEPTIONS
    AC_CXX_BOOL
    AC_CXX_NAMESPACES
    if test "$ac_cv_cxx_namespaces" != "yes" ; then
        AC_MSG_ERROR([Namespaces are required for the MPI C++ interface])
    fi
    HAVE_CXX_EXCEPTIONS=0
    AC_SUBST(HAVE_CXX_EXCEPTIONS)
    if test "$ac_cv_cxx_exceptions" = "yes" ; then
        HAVE_CXX_EXCEPTIONS=1
    fi
    # iostream and math are needed for examples/cxx/cxxpi.cxx
    AC_CACHE_CHECK([whether <iostream> available],pac_cv_cxx_has_iostream,[
    AC_TRY_COMPILE([
#include <iostream>
],[using namespace std;],pac_cv_cxx_has_iostream=yes,pac_cv_cxx_has_iostream=no)])
    if test "$pac_cv_cxx_has_iostream" = yes ; then
        CXX_DEFS="$CXX_DEFS -DHAVE_CXX_IOSTREAM"
    fi
    AC_CXX_NAMESPACE_STD
    if test "$ac_cv_cxx_namespace_std" = "yes" ; then
        CXX_DEFS="$CXX_DEFS -DHAVE_NAMESPACE_STD"
    fi
   
    AC_CACHE_CHECK([whether <math> available],pac_cv_cxx_has_math,[
    AC_TRY_COMPILE([
#include <math>
],[using namespace std;],pac_cv_cxx_has_math=yes,pac_cv_cxx_has_math=no)])
    if test "$pac_cv_cxx_has_math" = yes ; then
        CXX_DEFS="$CXX_DEFS -DHAVE_CXX_MATH"
    fi
    AC_SUBST(CXX_DEFS)

    # Add support for shared libraries if possible
    AC_SUBST(CXX_SHL)
    AC_SUBST(CXX_LINKPATH_SHL)
    case "$ENABLE_SHLIB" in
        gcc-osx|osx-gcc)
        # Assume that the compiler is g++ if gcc style shared libraries chosen
        CXX_SHL="$CXX -fPIC -dynamiclib -undefined suppress -single_module -flat_namespace"
        CXX_LINKPATH_SHL=""
	;;
	gcc)
        # Assume that the compiler is g++ if gcc style shared libraries chosen
        CXX_SHL="$CXX -shared -fPIC"
	if test "$enable_rpath" = yes ; then 
            CXX_LINKPATH_SHL="-Wl,-rpath -Wl,"
        fi
	;;
	cygwin|cygwin-gcc)
        CXX_SHL="$CXX -shared"
        CXX_LINKPATH_SHL=""
	;;
	solaris|solaris-cc)
        CXX_SHL="$CXX -xcode=pic32"
	if test "$enable_rpath" = yes ; then 
            CXX_LINKPATH_SHL=-R
        fi
	;;
	libtool)
	CXX_SHL='${LIBTOOL} --mode=compile ${CXX}'
        if test "$enable_rpath" = yes ; then 
	    CXX_LINKPATH_SHL="-rpath "
        fi
	;;
	*)
	CXX_SHL=false
	;;
    esac
    # GNU changed the calling conventions between minor releases (!!!)
    # This is too hard to detect, but we should be able to detect
    # the version mismatch.  By default, we set the GNU version to 0.
    # In a cross-compiling environment, these can be set with environment
    # variables, either directly or through the standard "CROSS" variable.
    if test -z "$GNUCXX_VERSION" ; then
        if test -n "$CROSS_GNUCXX_VERSION" ; then 
	     GNUCXX_VERSION=$CROSS_GNUCXX_VERSION
        else
             GNUCXX_VERSION=0
        fi
    fi
    if test -z "$GNUCXX_MINORVERSION" ; then 
	if test -n "$CROSS_GNUCXX_MINORVERSION" ; then
	     GNUCXX_MINORVERSION=$CROSS_GNUCXX_MINORVERSION
       	else
             GNUCXX_MINORVERSION=0
        fi
    fi
    if test "$cross_compiling" = "no" -a "$ac_compiler_gnu" = "yes" -a \
       "$GNUCXX_VERSION" = 0 -a "$GNUCXX_MINORVERSION" = 0 ; then
         ac_vals=""
	 AC_MSG_CHECKING([for GNU g++ version])
         AC_TRY_RUN([#include <stdio.h>
int main() {
    int v = -1, m = -1;
    FILE *fp = fopen("conftest.out","w");
#ifdef __GNUC_MINOR__
    m = __GNUC_MINOR__;
#endif
#ifdef __GNUC__
    v = __GNUC__;
#endif
    fprintf( fp, "v=%d, m=%d\n", v, m );
    fclose( fp );
    return 0;
}],ac_vals=`cat conftest.out`)
         if test -n "$ac_vals" ; then
             v=`echo "$ac_vals" | sed -e 's/v=\(.*\),.*/\1/'`
             m=`echo "$ac_vals" | sed -e 's/.*m=\(.*\)/\1/'`
             AC_MSG_RESULT([$v . $m])
             GNUCXX_VERSION=$v
             GNUCXX_MINORVERSION=$m
         else
             AC_MSG_RESULT([unknown])
         fi 
    fi    
    AC_SUBST(GNUCXX_VERSION)
    AC_SUBST(GNUCXX_MINORVERSION)

    bindings="$bindings cxx"
    bindings_dirs="$bindings_dirs src/binding/cxx"
    AC_DEFINE(HAVE_CXX_BINDING,1,[Define if C++ is supported])
    INCLUDE_MPICXX_H='#include "mpicxx.h"'
    AC_SUBST(INCLUDE_MPICXX_H)

    # In order to support the Fortran datatypes within C++, 
    # 
    # FORTRAN_BINDING always has a CPP-time value of either 0 or 1,
    # so that it may be used in #if statements without adding to 
    # the CPP name space
    AC_SUBST(FORTRAN_BINDING)

    # Special C++ datatypes.  Set to DATATYPE NULL first; we'll 
    # replace the ones that we have later, after we have determined
    # the C datatypes
    MPIR_CXX_BOOL=0x0c000000
    MPIR_CXX_COMPLEX=0x0c000000
    MPIR_CXX_DOUBLE_COMPLEX=0x0c000000
    MPIR_CXX_LONG_DOUBLE_COMPLEX=0x0c000000
    AC_SUBST(MPIR_CXX_BOOL)
    AC_SUBST(MPIR_CXX_COMPLEX)
    AC_SUBST(MPIR_CXX_DOUBLE_COMPLEX)
    AC_SUBST(MPIR_CXX_LONG_DOUBLE_COMPLEX)

fi

if test "$enable_cxx" = yes; then
    # Check if $MPI_DEFAULT_CXXOPTS is valid with $CXX
    if test "$enable_default_optimize" = "yes" \
         -a -n "$MPI_DEFAULT_CXXOPTS" ; then
        if test "$enable_check_compiler_flags" = "yes" ; then
            PAC_CXX_CHECK_COMPILER_OPTION( [$MPI_DEFAULT_CXXOPTS], [
            CXXFLAGS="$CXXFLAGS $MPI_DEFAULT_CXXOPTS"
                                     ] )
        else
            CXXFLAGS="$CXXFLAGS $MPI_DEFAULT_CXXOPTS"
        fi
    fi
fi

# Copy the mpicxx.h file to the main include directory
# Move a working version of the mpicxx script to the bin directory
AC_OUTPUT_COMMANDS([if test $enable_cxx = yes ; then 
if test "$bashWorks" = yes ; then cp -f src/env/mpicxx.bash src/env/mpicxx ; fi
chmod a+x src/env/mpicxx 
cp src/binding/cxx/mpicxx.h src/include 
if test ! -d bin  ; then mkdir bin ; fi 
sed -e 's%includedir=.*%includedir='$includebuild_dir% \
    -e 's%libdir=.*%libdir='$libbuild_dir% \
    src/env/mpicxx > bin/mpicxx ;
chmod a+x bin/mpicxx
else
    rm -f src/env/mpicxx src/env/mpicxx.conf
fi
],
enable_cxx=$enable_cxx
includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir
bashWorks=$bashWorks)

AC_SUBST(bindings)
# Bindings dirs is used for the installation target
AC_SUBST(bindings_dirs)
#
# ----------------------------------------------------------------------------
# End of the bindings support
# ----------------------------------------------------------------------------

AC_LANG_C
#
# ----------------------------------------------------------------------------
# Done with the basic argument processing and decisions about which 
# subsystems to build
# ----------------------------------------------------------------------------

# Look for perl.  Perl is used *only* in the tests of the commands such as
# mpiexec, mpicc, etc, in test/commands, and in some of the utility
# programs for processing log files .  If perl is not found,
# MPICH2 may still be built and used.
# We need the full path to perl since we'll use it as the interpreter for
# a shell script.
AC_PATH_PROG(PERL,perl)
# Look for ar.  If we fail, abort
AC_CHECK_PROGS(AR,ar)
if test -z "$AR" ; then
    AC_MSG_ERROR([The program ar is required for building MPICH2.  Make sure that your path includes ar])
fi

# AR_FLAGS provides a way to potentially improve build performance on Mac OSX
AR_FLAGS=cr
# this logic is lame, should really write a real test at some point
AS_CASE([$host],
    # Barry proposes AR_FLAGS="Scq" in trac#754, but that won't work correctly for re-builds
    [*-*-darwin*], [AR_FLAGS=Scr]
)
AC_ARG_VAR(AR_FLAGS,[AR command flags]) # causes AC_SUBST too

# Note that we set RANLIB to true if we don't find it (some systems neither
# need it nor provide it)
AC_CHECK_PROGS(RANLIB,ranlib,true)

# Check for the killall program; this can be used in some of the tests
# in test/commands
AC_CHECK_PROGS(KILLALL,killall,true)

# Does xargs need the -r option to handle the case where the input 
# is empty (gnu utils do, Mac OSX does not accept -r)
xargs_out=`echo "" | xargs ls | wc -l | sed -e 's/ //g'`
if test "$xargs_out" != "0" ; then
    XARGS_NODATA_OPT=-r
fi
AC_SUBST(XARGS_NODATA_OPT)

AC_PROG_INSTALL
PAC_PROG_CHECK_INSTALL_WORKS
#
# On Mac OS/X, install breaks libraries unless used with the -p switch
PAC_PROG_INSTALL_BREAKS_LIBS
# We also need mkdir -p.
PAC_PROG_MKDIR_P
PAC_PROG_MAKE

#
# Check for bash to allow more robust shell scripts
AC_PATH_PROG(BASH_SHELL,bash)
#
# Confirm that bash has working arrays.  We can use this to 
# build more robust versions of the scripts (particularly the 
# compliation scripts) by taking advantage of the array features in 
# bash.
bashWorks=no
if test -x "$BASH_SHELL" ; then
changequote(%%,::)dnl
    cat >>conftest <<EOF
#! $BASH_SHELL
A[0]="b"
A[1]="c"
rc=1
if test \${A[1]} != "c" ; then rc=2 ; else rc=0 ; fi
exit \$rc
EOF
changequote([,])dnl
    AC_MSG_CHECKING([whether $BASH_SHELL supports arrays])
    chmod +x conftest
    if ./conftest 2>&1 >/dev/null ; then
        bashWorks=yes
    else
        bashWorks=no
    fi
    rm -f conftest*
    AC_MSG_RESULT($bashWorks)
fi
BUILD_BASH_SCRIPTS=no
if test "$bashWorks" = yes ; then
    BUILD_BASH_SCRIPTS=yes
fi
AC_SUBST(BUILD_BASH_SCRIPTS)

# ----------------------------------------------------------------------------
# Check for the routines and libraries needed for accessing dynamically
# loaded libraries.
# This is very approximate for now; it is enough to allow use to experiment
# with this feature under Linux.
# ----------------------------------------------------------------------------
BUILD_DLLS=no
if test "$enable_dynamiclibs" = "yes" ; then
    AC_CHECK_HEADERS(dlfcn.h)
    AC_SEARCH_LIBS(dlopen,dl)
    AC_CHECK_FUNCS(dlopen dlsym)
    if test "$ac_cv_func_dlopen" = yes -a \
            "$ac_cv_func_dlsym"  = yes -a \
	    "$ac_cv_header_dlfcn_h" = yes ; then
        AC_DEFINE(USE_DYNAMIC_LIBRARIES,1,[Define if dynamic libraries are available and should be used])
	if test "$enable_sharedlibs" = no -o "$enable_sharedlibs" = none -o \
	   -z "$enable_sharedlibs" ; then
            AC_MSG_ERROR([You must specify --enable-sharedlibs=type when building with dynamic libraries])
dnl 	    # We still need to determine how to build shared libraries
dnl   	    AC_MSG_CHECKING([for how to build shared library for dynamically loaded libraries])
dnl         PAC_CC_SHAREDLIBS(,CC_SHL,C_LINK_SHL)
dnl 	    PAC_CC_SHLIB_EXT
dnl 	    if test "$SHLIB_EXT" = "unknown" ; then
dnl 	        # Guess that the extension is .so
dnl 	        SHLIB_EXT=so
dnl 	    fi
dnl 	    if test "$CC_SHL" = true ; then
dnl 	        AC_MSG_RESULT([none found])
dnl                 AC_MSG_WARN([Dynamic library support requires shared libraries])      
dnl 	    else
dnl 	        AC_MSG_RESULT($CC_SHL)
dnl 	        BUILD_DLLS=yes
dnl         fi
        fi
    fi
    AC_SUBST(BUILD_DLLS)

    # Let the DLL code know where we plan to install the libraries. 
    # This will make it easier for the user, who may not need 
    # to set a search path for the library.
    savePrefix=$prefix
    saveExecprefix=$exec_prefix
    test "x$prefix" = xNONE && prefix=$ac_default_prefix
    test "x$exec_prefix" = xNONE && exec_prefix=$prefix
    eval MPICH2_LIBDIR=$libdir
    prefix=$savePrefix
    exec_prefix=$saveExecprefix
    MPICH2_LIBDIR='"'$MPICH2_LIBDIR'"'
    AC_DEFINE_UNQUOTED(MPICH2_LIBDIR,$MPICH2_LIBDIR,[Name of installation directory intended for MPICH2])
fi

# Special restrictions for some shared libraries
# It is difficult to import/export symbols from some shared libraries, so
# in that case, we require PMPILIBNAME and MPILIBNAME be the same
case $ENABLE_SHLIB in 
     osx-gcc)
         # By default OSX doesn't resolve symbols in dynamic libraries the same
         # way that Linux does, especially in the presence of a mixture of
         # static and dynamic.  If we have a dynamic lib "libA.dylib" that needs
         # a symbol "foo" from a static lib "libB.a" and we build a program with
         # a command like "$CC main.o -lA -lB" then we will get a linking
         # error at *runtime* that looks like this:
         #
         # -------8<-------
         # dyld: lazy symbol binding failed: Symbol not found: _foo
         #   Referenced from: /path/to/lib/libA.dylib
         #   Expected in: flat namespace
         # -------8<-------
         #
         # There might be a better solution for this, but what I've found seems
         # to work so far is to force the OSX static linker to use a "flat
         # namespace" model instead of the default "two-level namespace" model.
         # See the ld(1) and dyld(1) man pages, as well as this Apple document:
         #
         # http://developer.apple.com/mac/library/DOCUMENTATION/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html
         #
         # The alternative solution is to avoid our mixture of static and
         # dynamic libraries altogether and make sure that we provide all
         # dynamic libs for all libraries (including MPL and OPA).
         #
         # [goodell@ 2010-02-09]
         PAC_APPEND_FLAG([-Wl,-flat_namespace], [LDFLAGS])
     ;;
     cygwin-gcc)
	if test "$PMPILIBNAME_set" = "no" ; then
            # Rename PMPILIBNAME
            PMPILIBNAME=$MPILIBNAME
        else
            if test "$PMPILIBNAME" != "$MPILIBNAME" ; then
                AC_MSG_ERROR([The PMPI and MPI libraries must have the same name when building shared libraries of type $ENABLE_SHLIB])
            fi
        fi
    ;;
esac
AC_SUBST(ENABLE_SHLIB)
AC_SUBST(C_LINKPATH_SHL)
# Now that CC is defined, get these values 
# eval C_LINK_SHL=$C_LINK_SHL
# eval CC_SHL=$CC_SHL
# Ensure that all subdir configures get the shared library items
export CC_SHL
export C_LINK_SHL
export C_LINKPATH_SHL
export SHLIB_EXT
export ENABLE_SHLIB
export LIBTOOL

# ----------------------------------------------------------------------------
# At this point, we've finally settled on the value of PMPILIBNAME.  We
# can now set NEEDSPLIB.
if test "$NEEDSPLIB" = yes -a "$PMPILIBNAME" = "$MPILIBNAME" ; then
    NEEDSPLIB=no
fi
# Set the defaults for the Fortran libraries to be the same as the C libraries
if test -z "$MPIFLIBNAME" ; then 
    MPIFLIBNAME=$MPILIBNAME 
fi
if test -z "$PMPIFLIBNAME" ; then
    PMPIFLIBNAME=$PMPILIBNAME
fi

# ----------------------------------------------------------------------------
# 
# Add the steps for debugger support
BUILD_TVDLL=no
if test "$enable_debuginfo" = "yes" ; then
   # We can build the Totalview interface DLL only if we know how to build
   # shared libraries.  For now, require that enable_sharedlibs is not none
   # Also, we may want to put some of this into a configure in the debugger
   # directory
   if test "$ENABLE_SHLIB" != "none" ; then
        BUILD_TVDLL=yes
	CC_SHL_DBG="$CC_SHL"
	C_LINK_SHL_DBG="$C_LINK_SHL"
	DBG_SHLIB_TYPE=$ENABLE_SHLIB
   else
        # Try to determine how to build the tv shared library
	AC_MSG_RESULT([for how to build shared library for debugger interface])
        PAC_CC_SHAREDLIBS(,CC_SHL_DBG,C_LINK_SHL_DBG,DBG_SHLIB_TYPE)
	PAC_CC_SHLIB_EXT
	if test "$SHLIB_EXT" = "unknown" ; then
	    # Guess that the extension is .so
	    SHLIB_EXT=so
	fi
	if test "$CC_SHL_DBG" = true ; then
	    AC_MSG_RESULT([none found])
            AC_MSG_WARN([Debugger support requires shared libraries])      
	else
	    AC_MSG_RESULT([Use this to build the debugger shared library: $CC_SHL_DBG])
	    BUILD_TVDLL=yes
        fi
   fi
   AC_SUBST(DBG_SHLIB_TYPE)
   # One more nasty problem.  Totalview relies on debugger symbols 
   # being present in the executable.  Some experimental versions of
   # gcc (3.2 20020329 for ia64) do *not* include the object symbols
   # when debugging.  For HPUX, the necessary linking options are
   #    +noobjdebug
   # for C, Fortran, and C++.  We don't have a good test for this yet,
   # so we add a warning
   if test "$ac_cv_prog_gcc" = "yes" ; then
       AC_MSG_WARN([Some versions of gcc do not include debugging information
within the executable.  Totalview requires this information to detect
an MPICH code.  If you have trouble, try linking with the additional
option 
    +noobjdebug
on all link lines (consider adding it to LDFLAGS)])
   fi
   AC_SUBST(BUILD_TVDLL)
   AC_SUBST(CC_SHL_DBG)
   AC_SUBST(C_LINK_SHL_DBG)

    # The debugger library name cannot be set until we know the extension
    # of shared libraries - the name is so on most Unix system, dylib on OS X.
    debugger_dir=debugger
    AC_DEFINE(HAVE_DEBUGGER_SUPPORT,1,[Define if debugger support is included])
    # The debugger support requires a shared library.  This is handled 
    # below, after we check for compiler support for shared libraries
    # Note: if libdir contains exec_prefix, handle the fact that the
    # default exec_prefix is NONE, which (much later in configure)
    # gets turned into the value of prefix
    ##ENVVAR: MPICH_DEBUGLIBNAME - Set this environment variable to 
    ## override the default name of the debugger support library.
    ## The default name is libtvmpich2.$SHLIB_EXT (e.g., libtvmpich2.so for
    ## most Unix versions, libtvmpich2.dylib for Mac OSX).
    ##ENVVAR END:
    if test -z "$MPICH_DEBUGLIBNAME" ; then
        DEBUGLIBNAME=libtvmpich2.$SHLIB_EXT
    else
        DEBUGLIBNAME=$MPICH_DEBUGLIBNAME
    fi
    if test "x$exec_prefix" = xNONE ; then
        saveExecPrefix=$exec_prefix
	exec_prefix=$prefix
        eval dlldir=$libdir/$DEBUGLIBNAME
	exec_prefix=$saveExecPrefix
    else
        eval dlldir=$libdir/$DEBUGLIBNAME
    fi
    dlldir='"'$dlldir'"'
    AC_DEFINE_UNQUOTED(MPICH_INFODLL_LOC,$dlldir,[Define as the name of the debugger support library])
fi
AC_SUBST(debugger_dir)

# ----------------------------------------------------------------------------

nameserv_name=""
AC_SUBST(nameserv_name)
# 
# Get the default nameserver, if no nameserver was selected.  A process
# manager may advertise a nameserver name by setting the variable
# MPID_PM_NAMESERVER.
if test "$with_namepublisher" = "default" ; then
   if test -n "$MPID_PM_NAMESERVER" ; then
       with_namepublisher=$MPID_PM_NAMESERVER
   else
       # The default is to use a file to communicate published names
       with_namepublisher=file
   fi
fi

if test "$with_namepublisher" != no -a "$with_namepublisher" != "none" ; then
    case "$with_namepublisher" in 
    none|no) ;;
    # Removed ldap namepublisher hook - we no longer support or distribute
    # the ldap-based name server
    file*)
    # Note that we always build the Makefile for the file version because
    # this name publisher is really too simple to require a 
    # separate configure, and we might as well include a basic
    # name publisher with any MPICH2 distribution
    # We DO need to extract the directory name that is used for writing 
    # the files, with the User's home directory as the default
    nameserv_name="file"
    basedir=`echo $with_namepublisher | sed -e 's/file://'`
    if test "$basedir" = "$with_namepublisher" ; then
        # Reset since no directory was set.
	basedir='"."';
    fi
    AC_DEFINE_UNQUOTED(FILE_NAMEPUB_BASEDIR,$basedir,[Directory to use in namepub])
    AC_DEFINE(USE_FILE_FOR_NAMEPUB,1,[Define if file should be used for name publisher])
    ;;

    mpd)
    nameserv_name="mpd"
    # The mpd nameserver is specific to the mpd process manager
    foundMPD=no
    for pm_name in $pm_names ; do
        if test "$pm_name" = "mpd" ; then 
	    foundMPD=yes
	    break
	fi
    done
    if test "$foundMPD" = no ; then
        AC_MSG_ERROR([The mpd nameserver requires the mpd process manager])
    fi
    ;;

    *)
    # Check for a new namepublisher
    dir=$with_namepublisher
    # If we later need args, here is where we can strip them off of the
    # with argument
    if test -d "$use_top_srcdir/src/nameserv/$dir" ; then
        if test -x "$use_top_srcdir/src/nameserv/$dir/configure" ; then
	    # Run the configure in this directory if necessary
            subsystems="$subsystems src/nameserv/$dir"
        fi
	nameserv_name=$dir
    else
        AC_MSG_WARN([Unknown name publisher $with_namepublisher])
    fi
    ;;
    esac    
fi
if test -n "$nameserv_name" ; then
   AC_DEFINE(HAVE_NAMEPUB_SERVICE,1,[Define if a name publishing service is available])
fi

# In case the documentation targets are used, find doctext and attempt to 
# find the source for the doctext LaTeX style files.  Use "false" if
# doctext is not found
AC_PATH_PROG(DOCTEXT,doctext,false)
if test -n "$DOCTEXT" ; then
    if test -z "$DOCTEXTSYTLE" ; then
        AC_MSG_CHECKING([for location of doctext style files])
        dpath=`doctext -debug_paths 2>&1 | grep 'default path' | \
	      sed -e 's%.*default path\(.*\),%\1:%g'`
        saveIFS="$IFS"
        IFS=": "
	for dir in $dpath ; do
	    if test -s $dir/refman.sty ; then
	       DOCTEXTSTYLE=$dir
	       break
	    fi
	done
        IFS="$saveIFS"
	if test -n "$DOCTEXTSTYLE" ; then
	    AC_MSG_RESULT($DOCTEXTSTYLE)
        else
	    AC_MSG_RESULT([unavailable])
        fi
    fi
fi
export DOCTEXT
export DOCTEXTSTYLE
AC_SUBST(DOCTEXT)
AC_SUBST(DOCTEXTSTYLE)

# ----------------------------------------------------------------------------
# Check for C compiler characteristics
AC_C_CONST
AC_C_VOLATILE
AC_C_RESTRICT
AC_C_INLINE

PAC_C_GNU_ATTRIBUTE
# We need to check for the endianess in order to implement the
# "external32" representations.  This defines "WORDS_BIGENDIAN when
# the system is bigendian.
# As of autoconf 2.62, this macro takes an additional argument for systems
# that can produce object files for either endianess.  
# With the as-always-incompatible-with-every-version autoconf, the 
# arguments for this macro *changed* in 2.62 to
# (if-bigendian,if-littleendian,unknown,universal)
# The fourth argument is new.
# Also note that the definition emitted by autoheader requires that gcc
# be used to compile the programs - other compilers may not define the 
# non-standard __BIG_ENDIAN__ or __LITTLE_ENDIAN__ CPP names on which 
# autoconf 2.62 now depends.
byteOrdering=unknown
AC_C_BIGENDIAN(byteOrdering=big,byteOrdering=little,,byteOrdering=universal)
case $byteOrdering in
    big)
    # Nothing to do - the c_bigendian macro takes care of it
    :
    ;;
    little)
    AC_DEFINE(WORDS_LITTLEENDIAN,1,[Define if words are little endian])
    ;;
    universal)
    AC_DEFINE(WORDS_UNIVERSAL_ENDIAN,1,[Define if configure will not tell us, for universal binaries])
    ;;
    unknown)
    AC_MSG_ERROR([Unable to determine endianess])
    ;;
esac

# We only need this test if we are using Fortran
if test "$enable_f77" ; then
    PAC_PROG_C_UNALIGNED_DOUBLES(,
[AC_MSG_WARN(Your C compiler $CC does not support unaligned accesses
to doubles.  This is required for interoperation with 
Fortran (the Fortran standard requires it).
You may need to specify an additional argument to your C compiler to 
force it to allow unaligned accesses.)])
fi
# Check for __func__ (defined in C99) or __FUNCTION__ (defined in older GCC)
AC_CACHE_CHECK([whether $CC supports __func__],pac_cv_cc_has___func__,
[AC_TRY_COMPILE([],
 [const char *cp = __func__; ],pac_cv_cc_has___func__=yes,
pac_cv_cc_has___func__=no)])
if test "$pac_cv_cc_has___func__" != "yes" ; then
    AC_CACHE_CHECK([whether $CC supports __FUNCTION__],pac_cv_cc_has___FUNCTION__,
[AC_TRY_COMPILE([],
 [const char *cp = __FUNCTION__;],pac_cv_cc_has___FUNCTION__=yes,
pac_cv_cc_has___FUNCTION__=no)])
fi

# ----------------------------------------------------------------------------
# Attempt to support dependency handling
# ----------------------------------------------------------------------------
# Set a default for MAKE_DEPEND_C
MAKE_DEPEND_C=true
AC_SUBST(MAKE_DEPEND_C)
AC_ARG_ENABLE(dependencies,
	AC_HELP_STRING([--enable-dependencies],
		[Generate dependencies for sourcefiles.  This requires
		that the Makefile.in files are also created to support
		dependencies (see maint/updatefiles)]),,enable_dependencies=default)

if test -z "$enable_dependencies" ; then 
   enable_dependencies=default
fi
if test "$enable_dependencies" = "default" ; then
    # Try to use gcc if available
    enable_dependencies=no
    if test "$ac_cv_prog_gcc" != "yes" ; then 
         # See if gcc is available
	 AC_CHECK_PROGS(GCC,gcc)
	 if test -n "$GCC" ; then 
	     enable_dependencies=gcc
         else 
	     # Try for another form, based on the stock compiler on the
	     # given system
	     ostype=`uname -s`
	     case "$ostype" in
	         SunOS)
		 enable_dependencies=solaris
		 ;;
	         *)
		 # Unrecognized; ignore
		 ;;
	     esac
         fi
    else
	enable_dependencies=gcc
    fi
    # We use this to indicate that we use gcc for dependencies,
    # even if a different compiler (e.g., pgcc) is selected for
    # compiling the code.  This will normally be adequate, even
    # if gcc points to different system header files, we're really
    # only interested in dependencies on the MPICH2 source files.
    if test "$enable_dependencies" = "gcc" ; then
        AC_MSG_RESULT([Using gcc to determine dependencies])
    fi
fi
if test "$enable_dependencies" != "no" ; then
   case "$enable_dependencies" in
   gcc|yes)
        # Ensure that the profiling libraries get their targets into
	# the files.  Use -MMD if you want the file in the build directory
	# instead of a subdirectory
        MAKE_DEPEND_C="gcc -MM"
    ;;
    solaris)
        # At least some Solaris SunPro compilers accept -xM1 -MT name, though
	# they ignore the -MT name argument.
        MAKE_DEPEND_C="cc -xM1"
    ;;
    *)	
        AC_MSG_RESULT([Using $enable_dependencies for MAKE_DEPEND_C])
        MAKE_DEPEND_C="$enable_dependencies"
    ;;	
    esac		
fi
export MAKE_DEPEND_C
# ----------------------------------------------------------------------------
# Check on support for long double and long long types.  Do this before the
# structure alignment test because it will test for including those
# types as well.  In addition, allow the device to suppress support for these
# optional C types by setting MPID_NO_LONG_DOUBLE and/or MPID_NO_LONG_LONG
# to yes.
if test "$MPID_NO_LONG_DOUBLE" != "yes" ; then
    AC_CACHE_CHECK([whether long double is supported],
    pac_cv_have_long_double,[
    AC_TRY_COMPILE(,[long double a;],
    pac_cv_have_long_double=yes,pac_cv_have_long_double=no)])
    if test "$pac_cv_have_long_double" = "yes" ; then
        AC_DEFINE(HAVE_LONG_DOUBLE,1,[Define if long double is supported])
    fi
fi
if test "$MPID_NO_LONG_LONG" != "yes" ; then
    AC_CACHE_CHECK([whether long long is supported],
    pac_cv_have_long_long,[
    AC_TRY_COMPILE(,[long long a;],
    pac_cv_have_long_long=yes,pac_cv_have_long_long=no)])
    if test "$pac_cv_have_long_long" = "yes" ; then
        AC_DEFINE(HAVE_LONG_LONG_INT,1,[Define if long long is supported])
    fi
fi
# ----------------------------------------------------------------------------
# Get default structure alignment for integers
dnl PAC_C_MAX_INTEGER_ALIGN places the default alignment into
dnl pac_cv_c_max_integer_align, with possible values including
dnl packed (byte), largest, two, four, eight (or other failure message).
PAC_C_MAX_INTEGER_ALIGN

if test "$pac_cv_c_max_integer_align" = "packed" ; then
    pac_cv_c_struct_align_nr=1
elif test "$pac_cv_c_max_integer_align" = "two" ; then
    pac_cv_c_struct_align_nr=2
elif test "$pac_cv_c_max_integer_align" = "four" ; then
    pac_cv_c_struct_align_nr=4
elif test "$pac_cv_c_max_integer_align" = "eight" ; then
    pac_cv_c_struct_align_nr=8
elif test "$pac_cv_c_max_integer_align" = "largest" ; then
    AC_DEFINE(HAVE_LARGEST_STRUCT_ALIGNMENT,1,[Define when alignment of structures is based on largest component])
fi

if test -n "$pac_cv_c_struct_align_nr" ; then
    AC_DEFINE_UNQUOTED(HAVE_MAX_INTEGER_ALIGNMENT,$pac_cv_c_struct_align_nr,[Controls byte alignment of integer structures (for MPI structs)])
    AC_DEFINE_UNQUOTED(HAVE_MAX_STRUCT_ALIGNMENT,$pac_cv_c_struct_align_nr,[Controls byte alignment of structures (for aligning allocated structures)])
fi
# Get default structure alignment for floating point types
dnl PAC_C_MAX_FP_ALIGN places the default alignment into
dnl pac_cv_c_max_fp_align, with possible values including
dnl packed (byte), largest, two, four, eight (or other failure message).
PAC_C_MAX_FP_ALIGN

if test "$pac_cv_c_max_fp_align" = "packed" ; then
    pac_cv_c_fp_align_nr=1
elif test "$pac_cv_c_max_fp_align" = "two" ; then
    pac_cv_c_fp_align_nr=2
elif test "$pac_cv_c_max_fp_align" = "four" ; then
    pac_cv_c_fp_align_nr=4
elif test "$pac_cv_c_max_fp_align" = "eight" ; then
    pac_cv_c_fp_align_nr=8
elif test "$pac_cv_c_max_fp_align" = "sixteen" ; then
    pac_cv_c_fp_align_nr=16
elif test "$pac_cv_c_max_fp_align" = "largest" ; then
    AC_MSG_ERROR([Configure detected unsupported structure alignment rules.])
fi

if test -n "$pac_cv_c_fp_align_nr" ; then
    AC_DEFINE_UNQUOTED(HAVE_MAX_FP_ALIGNMENT,$pac_cv_c_fp_align_nr,[Controls byte alignment of structures with floats, doubles, and long doubles (for MPI structs)])
fi

# Test for the alignment of structs containing only long doubles.
if test "$pac_cv_have_long_double" = yes ; then
    # Check for alignment of just float and double (no long doubles)
    PAC_C_MAX_DOUBLE_FP_ALIGN
    PAC_C_MAX_LONGDOUBLE_FP_ALIGN
    # FIXME: If this alignment is not the same as that for all float types,
    # we need to do something else in the alignment rule code.
    if test "$pac_cv_c_max_fp_align" != "$pac_cv_c_max_longdouble_fp_align" -o \
            "$pac_cv_c_max_fp_align" != "$pac_cv_c_max_double_fp_align" ; then
        AC_MSG_WARN([Structures containing long doubles may be aligned differently from structures with floats or longs.  MPICH2 does not handle this case automatically and you should avoid assumed extents for structures containing float types.])

	double_align=-1
	case $pac_cv_c_max_double_fp_align in 
	packed) double_align=1 ;;
	two)    double_align=2 ;;
	four)   double_align=4 ;;
	eight)  double_align=8 ;;
	esac
	longdouble_align=-1
	case $pac_cv_c_max_longdouble_fp_align in 
	packed) longdouble_align=1 ;;
	two)    longdouble_align=2 ;;
	four)   longdouble_align=4 ;;
	eight)  longdouble_align=8 ;;
	sixteen)longdouble_align=16 ;;
	esac
	
	AC_DEFINE_UNQUOTED(HAVE_MAX_DOUBLE_FP_ALIGNMENT,$double_align,[Controls byte alignment of structs with doubles])
	AC_DEFINE_UNQUOTED(HAVE_MAX_LONG_DOUBLE_FP_ALIGNMENT,$longdouble_align,[Controls byte alignment of structs with long doubles])
    fi
fi

# Test for weird struct alignment rules that vary padding based on
# size of leading type only.
PAC_C_DOUBLE_POS_ALIGN
if test "$pac_cv_c_double_pos_align" = "yes" ; then
    AC_DEFINE_UNQUOTED(HAVE_DOUBLE_POS_ALIGNMENT,1,[Controls how alignment is applied based on position of doubles in the structure])
fi

# Test for same weird issues with long long int.
PAC_C_LLINT_POS_ALIGN
if test "$pac_cv_c_llint_pos_align" = "yes" ; then
   AC_DEFINE_UNQUOTED(HAVE_LLINT_POS_ALIGNMENT,1,[Controls how alignment is applied based on position of long long ints in the structure])
fi

# Test for double alignment not following all our other carefully constructed rules
PAC_C_DOUBLE_ALIGNMENT_EXCEPTION
if test "$pac_cv_c_double_alignment_exception" = "four" ; then
   AC_DEFINE_UNQUOTED(HAVE_DOUBLE_ALIGNMENT_EXCEPTION,4,[Controls how alignment of doubles is performed, separate from other FP values])
fi

# Test whether pointers can be aligned on a int boundary or require
# a pointer boundary.
AC_MSG_CHECKING([for alignment restrictions on pointers])
AC_TRY_RUN(
changequote(<<,>>)
struct foo { int a; void *b; };
int main() {
    int buf[10];
    struct foo *p1;
    p1=(struct foo*)&buf[0];
    p1->b = (void *)0;
    p1=(struct foo*)&buf[1];
    p1->b = (void *)0;
    return 0;
changequote([,])
},pac_cv_pointers_have_int_alignment=yes,pac_cv_pointers_have_int_alignment=no,pac_cv_pointers_have_int_alignment=unknown)

if test "$pac_cv_pointers_have_int_alignment" != "yes" ; then
   AC_DEFINE(NEEDS_POINTER_ALIGNMENT_ADJUST,1,[define if pointers must be aligned on pointer boundaries])
   AC_MSG_RESULT([pointer])
else
   AC_MSG_RESULT([int or better])
fi

# There are further alignment checks after we test for int64_t etc. below.

# Get the size of the C types for encoding in the basic datatypes and for
# the specific-sized integers
AC_CHECK_SIZEOF(char)
AC_CHECK_SIZEOF(unsigned char)
AC_CHECK_SIZEOF(short)
AC_CHECK_SIZEOF(unsigned short)
AC_CHECK_SIZEOF(int)
AC_CHECK_SIZEOF(unsigned int)
AC_CHECK_SIZEOF(long)
AC_CHECK_SIZEOF(unsigned long)
AC_CHECK_SIZEOF(long long)
AC_CHECK_SIZEOF(unsigned long long)
AC_CHECK_SIZEOF(float)
AC_CHECK_SIZEOF(double)
AC_CHECK_SIZEOF(long double)
AC_CHECK_SIZEOF(void *)

AC_HEADER_STDC
AC_CHECK_HEADERS([stddef.h])
AC_CHECK_SIZEOF(wchar_t, 0, [
#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif
])

AC_CHECK_SIZEOF(float_int, 0, [typedef struct { float a; int b; } float_int; ])
AC_CHECK_SIZEOF(double_int, 0, [typedef struct { double a; int b; } double_int; ])
AC_CHECK_SIZEOF(long_int, 0, [typedef struct { long a; int b; } long_int; ])
AC_CHECK_SIZEOF(short_int, 0, [typedef struct { short a; int b; } short_int; ])
AC_CHECK_SIZEOF(two_int, 0, [typedef struct { int a; int b; } two_int; ])
AC_CHECK_SIZEOF(long_double_int, 0, [typedef struct { long double a; int b;} long_double_int; ])

# sys/bitypes.h defines the int16_t etc. on some systems (e.g., OSF1).
# Include it when testing for these types
AC_CHECK_HEADER(sys/bitypes.h,[use_bitypes="#include <sys/bitypes.h>"
AC_DEFINE(HAVE_SYS_BITYPES_H,1,[Define if sys/bitypes.h exists])])
# A C99 compliant compiler should have inttypes.h for fixed-size int types
AC_CHECK_HEADERS(inttypes.h stdint.h)

# Check for types
AC_TYPE_INT8_T
AC_TYPE_INT16_T
AC_TYPE_INT32_T
AC_TYPE_INT64_T

# Temporary issue in autoconf integer type checking (remove when
# autoconf fixes this or provides a workaround for it)
if test "$ac_cv_c_int8_t" != no ; then
    AC_DEFINE(HAVE_INT8_T,1,[Define if int8_t is supported by the C compiler])
fi
if test "$ac_cv_c_int16_t" != no ; then
    AC_DEFINE(HAVE_INT16_T,1,[Define if int16_t is supported by the C compiler])
fi
if test "$ac_cv_c_int32_t" != no ; then
    AC_DEFINE(HAVE_INT32_T,1,[Define if int32_t is supported by the C compiler])
fi
if test "$ac_cv_c_int64_t" != no ; then
    AC_DEFINE(HAVE_INT64_T,1,[Define if int64_t is supported by the C compiler])
fi

# The following make these definitions:
#   define _UINT<n>_T 1 
# if uint<n>_t is available.  E.g., define _UINT8_T as 1 if uint8_t is available
# if not available, define uint<n>_t as the related C type, e.g.,
#   define uint8_t unsigned char
#
AC_TYPE_UINT8_T
AC_TYPE_UINT16_T
AC_TYPE_UINT32_T
AC_TYPE_UINT64_T

# Temporary issue in autoconf integer type checking (remove when
# autoconf fixes this or provides a workaround for it)
if test "$ac_cv_c_uint8_t" != no ; then
    AC_DEFINE(HAVE_UINT8_T,1,[Define if uint8_t is supported by the C compiler])
fi
if test "$ac_cv_c_uint16_t" != no ; then
    AC_DEFINE(HAVE_UINT16_T,1,[Define if uint16_t is supported by the C compiler])
fi
if test "$ac_cv_c_uint32_t" != no ; then
    AC_DEFINE(HAVE_UINT32_T,1,[Define if uint32_t is supported by the C compiler])
fi
if test "$ac_cv_c_uint64_t" != no ; then
    AC_DEFINE(HAVE_UINT64_T,1,[Define if uint64_t is supported by the C compiler])
fi

# Other C99 types.
AC_CHECK_HEADERS([stdbool.h complex.h])
AC_CHECK_SIZEOF([_Bool],0,[
#ifdef HAVE_STDBOOL_H
#include <stdbool.h>
#endif
])
AC_CHECK_SIZEOF([float _Complex],0,[
#ifdef HAVE_COMPLEX_H
#include <complex.h>
#endif
])
AC_CHECK_SIZEOF([double _Complex],0,[
#ifdef HAVE_COMPLEX_H
#include <complex.h>
#endif
])
AC_CHECK_SIZEOF([long double _Complex],0,[
#ifdef HAVE_COMPLEX_H
#include <complex.h>
#endif
])
# we need really could just use the result of AC_CHECK_SIZEOF, but having a
# HAVE_typename macro is useful for consistency
AC_CHECK_TYPES([_Bool, float _Complex, double _Complex, long double _Complex])

# Generate a hex version of the size of each type
for type in short int long long_long float double long_double wchar_t \
    float_int double_int long_int short_int two_int long_double_int     \
    _Bool float__Complex double__Complex long_double__Complex ; do
    eval len=\$ac_cv_sizeof_$type
    if test -z "$len" ; then 
       len=0
       # Check for sizes from the CHECK_SIZEOF_DERIVED macro
       eval pclen=\$ac_cv_sizeof_$type
       if test -n "$pclen" ; then
           len=$pclen
       else
           # check for a non-optional type
           if test $type != long_long -a \
                   $type != long_double -a \
                   $type != long_double_int -a \
                   $type != _Bool -a \
                   $type != float__Complex -a \
                   $type != double__Complex -a \
                   $type != long_double__Complex ; then
               AC_MSG_ERROR([Configure was unable to determine the size of $type ; if cross compiling,
use the environment variables CROSS_SIZEOF_typename, e.g., CROSS_SIZEOF_SHORT,
or use the --with-cross=file configure option to specify a file containing
Bourne (sh) shell assignments to CROSS_SIZEOF_typename for all datatype 
types.  The program maint/getcross.c can be compiled and run on the target
system; this program outputs an appropriate file for the --with-cross option])
	   fi
       fi
    fi
    #
    # Take len and turn it into two hex digits (there are 8 bits available
    # in the built-in datatype handle for the length; see
    # src/mpid/common/datatype/mpid_datatype.h)
    if test "$len" -gt 255 ; then
         AC_MSG_ERROR([Type sizes greater than 255 bytes are not supported (type $type is $len bytes)]) 
    fi
    tmplen=$len
    hexlen=""
    while test $tmplen -gt 0 ; do
        lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
	case $lowdigit in 
         10) char=a ;;
	 11) char=b ;;
	 12) char=c ;;
	 13) char=d ;;
	 14) char=e ;;
	 15) char=f ;;
	  *) char=$lowdigit ;;
	esac
	hexlen="$char$hexlen"
	tmplen=`expr $tmplen / 16`
    done
    if test $len -lt 16 ; then
        hexlen="0$hexlen"
    fi
    if test $len = 0 ; then
        # This sometimes happens for wchar_t
        hexlen="00";
    fi
    eval len_$type=$hexlen
done
# By definition, sizeof char is 1
MPI_CHAR="0x4c000101"
MPI_UNSIGNED_CHAR="0x4c000102"
MPI_SHORT="0x4c00${len_short}03"
MPI_UNSIGNED_SHORT="0x4c00${len_short}04"
MPI_INT="0x4c00${len_int}05"
MPI_UNSIGNED_INT="0x4c00${len_int}06"
MPI_LONG="0x4c00${len_long}07"
MPI_UNSIGNED_LONG="0x4c00${len_long}08"
if test "$len_long_long" != 0 -a "$MPID_NO_LONG_LONG" != yes ; then
    MPI_LONG_LONG="0x4c00${len_long_long}09"
else 
    MPI_LONG_LONG=MPI_DATATYPE_NULL;
fi
MPI_FLOAT="0x4c00${len_float}0a"
MPI_DOUBLE="0x4c00${len_double}0b"
if test "$len_long_double" != 0 -a "$MPID_NO_LONG_DOUBLE" != yes ; then
    MPI_LONG_DOUBLE="0x4c00${len_long_double}0c"
else
    MPI_LONG_DOUBLE=MPI_DATATYPE_NULL
fi
# If you change MPI_BYTE, you must change it in src/binding/f77/buildiface
MPI_BYTE="0x4c00010d"
MPI_WCHAR="0x4c00${len_wchar_t}0e"
MPI_PACKED="0x4c00010f"
MPI_LB="0x4c000010"
MPI_UB="0x4c000011"
#
# These should define the mixed types *only* for contiguous data.
# For example, MPI_SHORT_INT may have a gap; it will need to be defined
# as a derived type instead.  For IA32, this only affects short_int.
MPI_2INT="0x4c00${len_two_int}16"
#
# For now we aren't being too clever about figuring out which of these
# are in fact contiguous, so these are all allocated as "real" types.
#
# These values correspond to direct types 0..5.
#
dnl MPI_FLOAT_INT="0x4c00${len_float_int}12"
dnl MPI_DOUBLE_INT="0x4c00${len_double_int}13"
dnl MPI_LONG_INT="0x4c00${len_long_int}14"
dnl MPI_SHORT_INT="0x4c00${len_short_int}15"
dnl MPI_LONG_DOUBLE_INT="0x4c00${len_long_double_int}17"
MPI_FLOAT_INT="0x8c000000"
MPI_DOUBLE_INT="0x8c000001"
MPI_LONG_INT="0x8c000002"
MPI_SHORT_INT="0x8c000003"
if test "$MPID_NO_LONG_DOUBLE" != yes ; then
    MPI_LONG_DOUBLE_INT="0x8c000004"
else
    MPI_LONG_DOUBLE_INT=MPI_DATATYPE_NULL
fi

# 2 additional predefined types named in MPI-2
MPI_SIGNED_CHAR="0x4c000118"
if test "$len_long_long" != 0 -a "$MPID_NO_LONG_LONG" != yes ; then
    MPI_UNSIGNED_LONG_LONG="0x4c00${len_long_long}19"
else
    MPI_UNSIGNED_LONG_LONG=MPI_DATATYPE_NULL
fi

AC_SUBST(MPI_CHAR)
AC_SUBST(MPI_UNSIGNED_CHAR)
AC_SUBST(MPI_SHORT)
AC_SUBST(MPI_UNSIGNED_SHORT)
AC_SUBST(MPI_INT)
AC_SUBST(MPI_UNSIGNED_INT)
AC_SUBST(MPI_LONG)
AC_SUBST(MPI_UNSIGNED_LONG)
AC_SUBST(MPI_LONG_LONG)
AC_SUBST(MPI_FLOAT)
AC_SUBST(MPI_DOUBLE)
AC_SUBST(MPI_LONG_DOUBLE)
AC_SUBST(MPI_BYTE)
AC_SUBST(MPI_WCHAR)
AC_SUBST(MPI_PACKED)
AC_SUBST(MPI_LB)
AC_SUBST(MPI_UB)
AC_SUBST(MPI_FLOAT_INT)
AC_SUBST(MPI_DOUBLE_INT)
AC_SUBST(MPI_LONG_INT)
AC_SUBST(MPI_SHORT_INT)
AC_SUBST(MPI_2INT)
AC_SUBST(MPI_LONG_DOUBLE_INT)
AC_SUBST(MPI_SIGNED_CHAR)
AC_SUBST(MPI_UNSIGNED_LONG_LONG)
#
# FIXME: Leftover from separate fortran system
## Export the basic C types so that the Fortran system can use them
#export MPI_CHAR
#export MPI_SHORT
#export MPI_INT
#export MPI_LONG
#export MPI_LONG_LONG
#export MPI_FLOAT
#export MPI_DOUBLE
#export MPI_LONG_DOUBLE
#
# Size-specific types.  Initialize as NULL
MPI_REAL4=MPI_DATATYPE_NULL
MPI_REAL8=MPI_DATATYPE_NULL
MPI_REAL16=MPI_DATATYPE_NULL
MPI_COMPLEX8=MPI_DATATYPE_NULL
MPI_COMPLEX16=MPI_DATATYPE_NULL
MPI_COMPLEX32=MPI_DATATYPE_NULL
MPI_INTEGER1=MPI_DATATYPE_NULL
MPI_INTEGER2=MPI_DATATYPE_NULL
MPI_INTEGER4=MPI_DATATYPE_NULL
MPI_INTEGER8=MPI_DATATYPE_NULL
MPI_INTEGER16=MPI_DATATYPE_NULL
AC_SUBST(MPI_REAL4)
AC_SUBST(MPI_REAL8)
AC_SUBST(MPI_REAL16)
AC_SUBST(MPI_COMPLEX8)
AC_SUBST(MPI_COMPLEX16)
AC_SUBST(MPI_COMPLEX32)
AC_SUBST(MPI_INTEGER1)
AC_SUBST(MPI_INTEGER2)
AC_SUBST(MPI_INTEGER4)
AC_SUBST(MPI_INTEGER8)
AC_SUBST(MPI_INTEGER16)
export MPI_REAL4
export MPI_REAL8
export MPI_REAL16
export MPI_COMPLEX8
export MPI_COMPLEX16
export MPI_COMPLEX32
export MPI_INTEGER1
export MPI_INTEGER2
export MPI_INTEGER4
export MPI_INTEGER8
export MPI_INTEGER16
#
# Try to find corresponding types for the size-specific types.
#
# Assume that the float/double/long double are simply spaced
# Datatypes used up through 26 in Fortran
# 27,28,29,2a,2b,2c
if test "$ac_cv_sizeof_float" = "4" ; then
    MPI_REAL4="0x4c000427"
    MPI_COMPLEX8="0x4c000828"
    MPIR_REAL4_CTYPE=float
fi
if test "$ac_cv_sizeof_double" = "8" ; then
    MPI_REAL8="0x4c000829"
    MPI_COMPLEX16="0x4c00102a"
    MPIR_REAL8_CTYPE=double
fi
if test "$ac_cv_sizeof_long_double" = "16" -a "$MPID_NO_LONG_DOUBLE" != yes ; then
    MPI_REAL16="0x4c00102b"
    MPI_COMPLEX32="0x4c00202c"
    MPIR_REAL16_CTYPE="long double"
fi
if test -n "$MPIR_REAL4_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL4_CTYPE,$MPIR_REAL4_CTYPE,[C type to use for MPI_REAL4])
fi
if test -n "$MPIR_REAL8_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL8_CTYPE,$MPIR_REAL8_CTYPE,[C type to use for MPI_REAL8])
fi
if test -n "$MPIR_REAL16_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL16_CTYPE,$MPIR_REAL16_CTYPE,[C type to use for MPI_REAL16])
fi
# For complex 8/16/32, we assume that these are 2 consequetive real4/8/16
#
# Search for the integer types
for type in char short int long long_long ; do
    # ctype is a valid C type which we can use to declare a C version of 
    # this item
    ctype=`echo $type | sed 's/_/ /'`
    eval len=\$ac_cv_sizeof_$type
    if test -n "$len" ; then 
    case $len in 
    1) if test "$MPI_INTEGER1" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER1="0x4c00012d"
	   MPIR_INTEGER1_CTYPE="$ctype"
       fi
       ;;
    2) if test "$MPI_INTEGER2" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER2="0x4c00022f"
	   MPIR_INTEGER2_CTYPE="$ctype"
       fi
       ;;
    4) if test "$MPI_INTEGER4" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER4="0x4c000430"
	   MPIR_INTEGER4_CTYPE="$ctype"
       fi
       ;;
    8) if test "$MPI_INTEGER8" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER8="0x4c000831"
	   MPIR_INTEGER8_CTYPE="$ctype"
       fi
       ;;
    16) if test "$MPI_INTEGER16" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER16="0x4c001032"
	   MPIR_INTEGER16_CTYPE="$ctype"
       fi
       ;;
    *)
    ;;
    esac
    fi
done
#
# Add the definitions of these types
if test -n "$MPIR_INTEGER1_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_INTEGER1_CTYPE,$MPIR_INTEGER1_CTYPE,[C type to use for MPI_INTEGER1])
fi
if test -n "$MPIR_INTEGER2_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER2_CTYPE,$MPIR_INTEGER2_CTYPE,[C type to use for MPI_INTEGER2])
fi
if test -n "$MPIR_INTEGER4_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER4_CTYPE,$MPIR_INTEGER4_CTYPE,[C type to use for MPI_INTEGER4])
fi
if test -n "$MPIR_INTEGER8_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER8_CTYPE,$MPIR_INTEGER8_CTYPE,[C type to use for MPI_INTEGER8])
fi
if test -n "$MPIR_INTEGER16_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER16_CTYPE,$MPIR_INTEGER16_CTYPE,[C type to use for MPI_INTEGER16])
fi

# ----------------------------------------------------------------------------

# C99 types
# The predefined types must be distinct types (as opposed to aliases to MPI_INT
# or MPI_WHATEVER) in order to correctly support MPI_Type_{get,set}_name.
#
# FIXME the "basic id" portion should be automatically assigned.  It's too easy
# to have a conflict when this is done by hand.
#
# Because we make up a matching type for the fixed-width types if one doesn't
# exist, we don't ever set these to MPI_DATATYPE_NULL.  If we come across a
# platform where 64-bit sizes aren't supported just add a test like the other
# types.
MPI_INT8_T=0x4c000137
MPI_INT16_T=0x4c000238
MPI_INT32_T=0x4c000439
MPI_INT64_T=0x4c00083a
MPI_UINT8_T=0x4c00013b
MPI_UINT16_T=0x4c00023c
MPI_UINT32_T=0x4c00043d
MPI_UINT64_T=0x4c00083e

# The compiler may or may not support these types, depending on its level of C99
# compliance.  We check for each one individually before assigning a handle
# number.
MPI_C_BOOL=$MPI_DATATYPE_NULL
MPI_C_FLOAT_COMPLEX=$MPI_DATATYPE_NULL
MPI_C_DOUBLE_COMPLEX=$MPI_DATATYPE_NULL
MPI_C_LONG_DOUBLE_COMPLEX=$MPI_DATATYPE_NULL
if test ${len__Bool} != 0 ; then
    MPI_C_BOOL=0x4c00${len__Bool}3f
fi
if test ${len_float__Complex} != 0 ; then
    MPI_C_FLOAT_COMPLEX=0x4c00${len_float__Complex}40
fi
if test ${len_double__Complex} != 0 ; then
    MPI_C_DOUBLE_COMPLEX=0x4c00${len_double__Complex}41
fi
if test ${len_long_double__Complex} != 0 ; then
    MPI_C_LONG_DOUBLE_COMPLEX=0x4c00${len_long_double__Complex}42
fi

AC_SUBST(MPI_INT8_T)
AC_SUBST(MPI_INT16_T)
AC_SUBST(MPI_INT32_T)
AC_SUBST(MPI_INT64_T)
AC_SUBST(MPI_UINT8_T)
AC_SUBST(MPI_UINT16_T)
AC_SUBST(MPI_UINT32_T)
AC_SUBST(MPI_UINT64_T)
AC_SUBST(MPI_C_BOOL)
AC_SUBST(MPI_C_FLOAT_COMPLEX)
AC_SUBST(MPI_C_DOUBLE_COMPLEX)
AC_SUBST(MPI_C_LONG_DOUBLE_COMPLEX)
export MPI_INT8_T
export MPI_INT16_T
export MPI_INT32_T
export MPI_INT64_T
export MPI_UINT8_T
export MPI_UINT16_T
export MPI_UINT32_T
export MPI_UINT64_T
export MPI_C_BOOL
export MPI_C_FLOAT_COMPLEX
export MPI_C_DOUBLE_COMPLEX
export MPI_C_LONG_DOUBLE_COMPLEX


# ----------------------------------------------------------------------------
# We can now create the Fortran versions of the datatype values, along with
# some of the other datatype-dependent sizes

# There are two parts to handling the datatypes:
#    Convert the C datatype values to their Fortran equivalent.  This
#    involves converting the hex values for the C version into decimal
#    since standard Fortran does not have hex constants
#
#    Determine the existence of the Fortran 'sized' types and set those
#    values.
#
# In addition, we need to look at a few additional constants that depend
# on how the compiler sizes some datatypes.  These are:
#    STATUS_SIZE, ADDRESS_KIND, and OFFSET_KIND
# 
# ----------------------------------------------------------------------------
if test "$enable_f77" = yes ; then
    # Up to size checking code in master configure.in (where it tries to 
    # find the matching C sizes) as part of defining mpi_integer8 etc.
    # The results are available in pac_cv_sizeof_f77_<type>
    # Size is 0 if unknown or unavailable (or cross-compiling)
    # Due to limitations in autoconf, we cannot put these into a loop.
    # We also check integer to find the type of MPI_Fint
    #
    # Cross-compilation results can be included with the --with-cross=file
    # option.
    CROSS_F77_SIZEOF_INTEGER=${CROSS_F77_SIZEOF_INTEGER:-0}
    CROSS_F77_SIZEOF_REAL=${CROSS_F77_SIZEOF_REAL:-0}
    CROSS_F77_SIZEOF_DOUBLE_PRECISION=${CROSS_F77_SIZEOF_DOUBLE_PRECISION:-0}
    PAC_PROG_F77_CHECK_SIZEOF_EXT(integer,$CROSS_F77_SIZEOF_INTEGER)
    PAC_PROG_F77_CHECK_SIZEOF_EXT(real,$CROSS_F77_SIZEOF_REAL)
    PAC_PROG_F77_CHECK_SIZEOF_EXT(double precision,$CROSS_F77_SIZEOF_DOUBLE_PRECISION)
    AC_LANG_FORTRAN77
    # If we have sizes for real and double, we do not need to call 
    # mpir_get_fsize at run time.
    # For the size-defined types (e.g., integer*2), we assume that if the
    # compiler allows it, it has the stated size.
    AC_CACHE_CHECK([whether integer*1 is supported],pac_cv_fort_integer1,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      integer*1 i])],
         pac_cv_fort_integer1=yes,
         pac_cv_fort_integer1=no)])
    AC_CACHE_CHECK([whether integer*2 is supported],pac_cv_fort_integer2,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      integer*2 i])],
        pac_cv_fort_integer2=yes,
        pac_cv_fort_integer2=no)])
    AC_CACHE_CHECK([whether integer*4 is supported],pac_cv_fort_integer4,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      integer*4 i])],
        pac_cv_fort_integer4=yes,
        pac_cv_fort_integer4=no)])
    AC_CACHE_CHECK([whether integer*8 is supported],pac_cv_fort_integer8,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      integer*8 i])],
        pac_cv_fort_integer8=yes,
        pac_cv_fort_integer8=no)])
    AC_CACHE_CHECK([whether integer*16 is supported],pac_cv_fort_integer16,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      integer*16 i])],
        pac_cv_fort_integer16=yes,
        pac_cv_fort_integer16=no)])
    AC_CACHE_CHECK([whether real*4 is supported],pac_cv_fort_real4,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      real*4 a])],
        pac_cv_fort_real4=yes,
        pac_cv_fort_real4=no)])
    AC_CACHE_CHECK([whether real*8 is supported],pac_cv_fort_real8,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      real*8 a])],
        pac_cv_fort_real8=yes,
        pac_cv_fort_real8=no)])
    AC_CACHE_CHECK([whether real*16 is supported],pac_cv_fort_real16,[
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,[      real*16 a])],
        pac_cv_fort_real16=yes,
        pac_cv_fort_real16=no)])

    # Create the default datatype names for the standard MPI Fortran types
    MPI_CHARACTER=0x4c00011a
    AC_SUBST(MPI_CHARACTER)

    if test -z "$pac_cv_f77_sizeof_integer" ; then
        AC_MSG_ERROR([Unable to configure with Fortran support because configure could not determine the size of a Fortran INTEGER.  Consider setting CROSS_F77_SIZEOF_INTEGER to the length in bytes of a Fortran INTEGER])
    fi
    len_integer=$pac_cv_f77_sizeof_integer
    # Convert to two digit hex
    len=$len_integer
    #
    # Take len and turn it into two hex digits (there are 8 bits available
    # in the built-in datatype handle for the length; see
    # src/mpid/common/datatype/mpid_datatype.h).  This code is taken
    # from the code in mpich2/configure.in 
    if test "$len" -gt 255 ; then
        AC_MSG_ERROR([Type sizes greater than 255 bytes are not supported (type INTEGER is $len bytes)]) 
    fi
    tmplen=$len
    hexlen=""
    while test $tmplen -gt 0 ; do
        lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
        case $lowdigit in 
        10) char=a ;;
        11) char=b ;;
        12) char=c ;;
        13) char=d ;;
        14) char=e ;;
        15) char=f ;;
         *) char=$lowdigit ;;
        esac
        hexlen="$char$hexlen"
        tmplen=`expr $tmplen / 16`
    done
    if test $len -lt 16 ; then
        hexlen="0$hexlen"
    fi
    len_integer=$hexlen
    if test "$len_integer" = 0 ; then
        # We have a problem
        AC_MSG_WARN([Unable to determine size of an INTEGER type; using 4])
        # We make the length 4
        len_integer="04"
    fi
    MPI_INTEGER=0x4c00${len_integer}1b
    MPI_REAL=0x4c00${len_integer}1c
    MPI_LOGICAL=0x4c00${len_integer}1d
    AC_SUBST(MPI_INTEGER)
    AC_SUBST(MPI_REAL)
    AC_SUBST(MPI_LOGICAL)

    if test -z "$pac_cv_f77_sizeof_double_precision" ; then
        AC_MSG_ERROR([Unable to configure with Fortran support because configure could not determine the size of a Fortran DOUBLE PRECISION.  Consider setting CROSS_F77_SIZEOF_DOUBLE_PRECISION to the length in bytes of a Fortran DOUBLE PRECISION])
    fi
    len_double=$pac_cv_f77_sizeof_double_precision
    # Convert to two digit hex
    len=$len_double
    #
    # Take len and turn it into two hex digits (there are 8 bits available
    # in the built-in datatype handle for the length; see
    # src/mpid/common/datatype/mpid_datatype.h).  This code is taken
    # from the code in mpich2/configure.in 
    if test "$len" -gt 255 ; then
        AC_MSG_ERROR([Type sizes greater than 255 bytes are not supported (type DOUBLE is $len bytes)]) 
    fi
    tmplen=$len
    hexlen=""
    while test $tmplen -gt 0 ; do
        lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
        case $lowdigit in 
        10) char=a ;;
        11) char=b ;;
        12) char=c ;;
        13) char=d ;;
        14) char=e ;;
        15) char=f ;;
         *) char=$lowdigit ;;
        esac
        hexlen="$char$hexlen"
        tmplen=`expr $tmplen / 16`
    done
    if test $len -lt 16 ; then
        hexlen="0$hexlen"
    fi 
    len_double=$hexlen
    if test "$len_double" = 0 ; then
       # We have a problem
       AC_MSG_WARN([Unable to determine size of a DOUBLE PRECISION type; using 8])
       # We make the length 8
       len_double="08"
    fi
    MPI_COMPLEX=0x4c00${len_double}1e
    MPI_DOUBLE_PRECISION=0x4c00${len_double}1f
    MPI_2INTEGER=0x4c00${len_double}20
    MPI_2REAL=0x4c00${len_double}21
    AC_SUBST(MPI_COMPLEX)
    AC_SUBST(MPI_DOUBLE_PRECISION)
    AC_SUBST(MPI_2INTEGER)
    AC_SUBST(MPI_2REAL)

    len_doublecplx=`expr $pac_cv_f77_sizeof_double_precision \* 2`
    if test "$len_doublecplx" = 0 ; then
        # We have a problem
        AC_MSG_WARN([Unable to determine size of a DOUBLE PRECISION type; using 8])
        # We make the length 8*2 (in hex)
        len_doublecplx="16"
    fi
    len=$len_doublecplx
    #
    # Take len and turn it into two hex digits (there are 8 bits available
    # in the built-in datatype handle for the length; see
    # src/mpid/common/datatype/mpid_datatype.h).  This code is taken
    # from the code in mpich2/configure.in 
    if test "$len" -gt 255 ; then
        AC_MSG_ERROR([Type sizes greater than 255 bytes are not supported (type DOUBLE COMPLEX is $len bytes)]) 
    fi
    tmplen=$len
    hexlen=""
    while test $tmplen -gt 0 ; do
        lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
        case $lowdigit in 
        10) char=a ;;
        11) char=b ;;
        12) char=c ;;
        13) char=d ;;
        14) char=e ;;
        15) char=f ;;
         *) char=$lowdigit ;;
        esac
        hexlen="$char$hexlen"
        tmplen=`expr $tmplen / 16`
    done
    if test $len -lt 16 ; then
        hexlen="0$hexlen"
    fi
    len_doublecplx=$hexlen

    MPI_DOUBLE_COMPLEX=0x4c00${len_doublecplx}22
    MPI_2DOUBLE_PRECISION=0x4c00${len_doublecplx}23
    MPI_2COMPLEX=0x4c00${len_doublecplx}24
    AC_SUBST(MPI_DOUBLE_COMPLEX)
    AC_SUBST(MPI_2DOUBLE_PRECISION)
    AC_SUBST(MPI_2COMPLEX)

    #
    # Temporary for the vast majority of systems that use 4 byte reals and
    # 8 byte doubles
    # Lengths at this point are in hex, hence "10" = 10 base 16 = 16 base 10.
    if test "$len_double" = "08" ; then
        F77_COMPLEX8=$MPI_COMPLEX
    fi
    if test "$len_doublecplx" = "10" ; then
        F77_COMPLEX16=$MPI_DOUBLE_COMPLEX
    fi
    if test "$len_long_double" = "10" -a "$MPID_NO_LONG_DOUBLE" != "yes" ; then
        F77_COMPLEX32="0x4c002025"
    else
        F77_COMPLEX32="MPI_DATATYPE_NULL"
    fi

    len_2dc=`expr $pac_cv_f77_sizeof_double_precision \* 4`
    firstdigit=0
    seconddigit=0
    while test $len_2dc -ge 16 ; do
        firstdigit=`expr $firstdigit + 1`
        len_2dc=`expr $len_2dc - 16`    
    done
    case $len_2dc in
        10) seconddigit=a ;;
        11) seconddigit=b ;;
        12) seconddigit=c ;;
        13) seconddigit=d ;;
        14) seconddigit=e ;;
        15) seconddigit=f ;;
         *) seconddigit=$len_2dc ;;
    esac
    len_2dc="$firstdigit$seconddigit"
    #echo "2double complex = $len_2dc"
    MPI_2DOUBLE_COMPLEX=0x4c00${len_2dc}25
    AC_SUBST(MPI_2DOUBLE_COMPLEX)
    MPI_F77_PACKED=$MPI_PACKED
    MPI_F77_UB=$MPI_UB
    MPI_F77_LB=$MPI_LB
    MPI_F77_BYTE=$MPI_BYTE
    AC_SUBST(MPI_F77_PACKED)
    AC_SUBST(MPI_F77_UB)
    AC_SUBST(MPI_F77_LB)
    AC_SUBST(MPI_F77_BYTE)
    #
    # We must convert all hex values to decimal (!)
    # It would be nice to use expr to extract the next character rather than
    # the heavier-weight sed, but expr under Tru64 Unix discards leading zeros,
    # even when used only with the match (:) command.  Rather than have 
    # configure figure out if expr works, we just use sed.  Sigh.
    for var in CHARACTER INTEGER REAL LOGICAL DOUBLE_PRECISION COMPLEX \
        DOUBLE_COMPLEX 2INTEGER 2REAL 2COMPLEX 2DOUBLE_PRECISION \
        2DOUBLE_COMPLEX F77_PACKED F77_UB F77_LB F77_BYTE; do  
        fullvar="MPI_$var"
        eval fullvarvalue=\$$fullvar
        #echo "$fullvar = $fullvarvalue"
        value=0
        fullvarvalue=`echo $fullvarvalue | sed -e 's/..\(.*\)/\1/'`
        for pos in 3 4 5 6 7 8 9 10 ; do
            # This works, even for Tru64, because only a single character
  	    # is extracted
            char=`expr $fullvarvalue : '\(.\)'`
	    # FIXME: Tru64 Unix eliminates leading zeros (!)
 	    # How do we fix something that broken?
	    fullvarvalue=`echo $fullvarvalue | sed -e 's/.\(.*\)/\1/'`
            case $char in 
                a) char=10 ;;
	        b) char=11 ;;
	        c) char=12 ;;
	        d) char=13 ;;
	        e) char=14 ;;
	        f) char=15 ;;
            esac
            value=`expr $value \* 16 + $char`
        done
        #echo "$fullvar = $value"
        eval $fullvar=$value
    done
    AC_LANG_C

    # Now, handle the sized types
    #
    # Preload the C mpi types
    # THESE MUST MATCH THE DEFINITIONS IN MPI.H and MPIF.H
    # We use these to match the optional Fortran types
    char_mpi=${MPI_CHAR:-0}
    short_mpi=${MPI_SHORT:-0}
    int_mpi=${MPI_INT:-0}
    long_mpi=${MPI_LONG:-0}
    long_long_mpi=${MPI_LONG_LONG:-0}
    float_mpi=${MPI_FLOAT:-0}
    double_mpi=${MPI_DOUBLE:-0}
    long_double_mpi=${MPI_LONG_DOUBLE:-0}

    #
    # The following code was correct for MPI-1, which allowed these datatypes
    # to be an alias for another MPI type.  MPI-2 requires these to 
    # be distinct types, so these are enumerated
    if test "$use_alias_types" = yes ; then
        for len in 1 2 4 8 16 ; do
            eval F77_INTEGER$len=0
            #eval testval=\$"pac_cv_f77_sizeof_integer_$len"
            eval testval=\$"pac_cv_fort_integer$len"
            if test "$testval" = no ; then continue ; fi
	    testval=$len
            noval="yes"
            AC_MSG_CHECKING([for C type matching Fortran integer*$len])
            for c_type in char short int long "long_long" ; do
	        eval ctypelen=\$"ac_cv_sizeof_$c_type"
  	        if test "$testval" = "$ctypelen" -a "$ctypelen" -gt 0 ; then
	            AC_MSG_RESULT($c_type)
  	            eval F77_INTEGER$len=\$"${c_type}_mpi"
	            noval="no"
	            break
                fi
            done
            if test "$noval" = "yes" ; then
                AC_MSG_RESULT([unavailable])
            fi
        done

        # Complex is set separately above
        for len in 4 8 16 ; do
            len2=`expr $len + $len`
            eval F77_REAL$len=0
            #eval F77_COMPLEX$len2=0
            #eval testval=\$"pac_cv_f77_sizeof_real_$len"
            eval testval=\$"pac_cv_fort_real$len"
            if test "$testval" = no ; then continue ; fi
	    testval=$len
            noval="yes"
            AC_MSG_CHECKING([for C type matching Fortran real*$len])
            for c_type in float double "long_double" ; do
	        eval ctypelen=\$"ac_cv_sizeof_$c_type"
	        if test "$testval" = "$ctypelen" -a "$ctypelen" -gt 0 ; then
	            AC_MSG_RESULT($c_type)
  	            eval F77_REAL$len=\$"${c_type}_mpi"
	            #eval F77_COMPLEX$len2=\$"${c_type}_cplx_mpi"
                    noval="no"
	            break
                fi
            done
            if test "$noval" = "yes" ; then
                AC_MSG_RESULT([unavailable])
            fi
        done
    else 
        # Simply determine which types exist.  These may have been set by the
        # toplevel configure
        for var in INTEGER1 INTEGER2 INTEGER4 INTEGER8 INTEGER16 \
            REAL4 REAL8 REAL16 COMPLEX8 COMPLEX16 COMPLEX32 ; do  
  	    eval varname=MPI_$var
            eval varvalue=\$$varname
	    #echo "$varname = $varvalue"
  	    if test "$varvalue" = MPI_DATATYPE_NULL ; then
	        eval F77_$var=0
  	    else
                eval F77_$var=\$$varname
  	    fi
       done
    fi
    # We must convert all hex values to decimal (!)
    for var in INTEGER1 INTEGER2 INTEGER4 INTEGER8 INTEGER16 \
        REAL4 REAL8 REAL16 COMPLEX8 COMPLEX16 COMPLEX32 ; do  
        fullvar="F77_$var"
        eval fullvarvalue=\$$fullvar
        if test "$fullvarvalue" = 0 -o -z "$fullvarvalue" ; then 
            eval $fullvar=MPI_DATATYPE_NULL
            continue
        fi
        #echo "$fullvar = $fullvarvalue"
        value=0
        # See the comments above on why expr with : cannot be used here
        fullvarvalue=`echo $fullvarvalue | sed -e 's/..\(.*\)/\1/'`
        for pos in 3 4 5 6 7 8 9 10 ; do
            #char=`expr substr $fullvarvalue $pos 1`
            char=`expr $fullvarvalue : '\(.\)'`
	    # We don't test for success of expr here because some expr's are
  	    # buggy and set the status to one on expressions like
            #    expr 00ccc : '\(.\)'
            # while both
            #    expr 00ccc : '\(..\)' 
            # and
            #    expr 100cc : '\(.\)'
            # return a zero status.  So the status is set even on success,
            # if the result is a single character that is a zero (!)
	    #rc=$?
    	    #if test "$rc" != 0 ; then
  	    dnl #    AC_MSG_WARN([Failure (status $rc) in extracting first char from $fullvarvalue])
  	    #    break
	    #fi
	    fullvarvalue=`echo $fullvarvalue | sed -e 's/.\(.*\)/\1/'`
            case $char in 
                a) char=10 ;;
	        b) char=11 ;;
	        c) char=12 ;;
	        d) char=13 ;;
	        e) char=14 ;;
	        f) char=15 ;;
            esac
            value=`expr $value \* 16 + $char`
	    if test $? != 0 ; then
	        AC_MSG_WARN([Failure to evaluate $value \* 16 + $char])
	    fi
        done
        #echo "$fullvar = $value"
        eval $fullvar=$value
    done
    AC_SUBST(F77_INTEGER1)
    AC_SUBST(F77_INTEGER2)
    AC_SUBST(F77_INTEGER4)
    AC_SUBST(F77_INTEGER8)
    AC_SUBST(F77_INTEGER16)
    AC_SUBST(F77_REAL4)
    AC_SUBST(F77_REAL8)
    AC_SUBST(F77_REAL16)
    AC_SUBST(F77_COMPLEX8)
    AC_SUBST(F77_COMPLEX16)
    AC_SUBST(F77_COMPLEX32)

    noval="yes"
    AC_MSG_CHECKING([for C type matching Fortran integer])
    for c_type in char short int long "long_long" ; do
        eval ctypelen=\$"ac_cv_sizeof_$c_type"
        if test "$pac_cv_f77_sizeof_integer" = "$ctypelen" -a \
          "$ctypelen" -gt 0 ; then
	    c_type=`echo $c_type | sed -e 's/_/ /g'`
	    AC_MSG_RESULT($c_type)
	    MPI_FINT=$c_type
	    noval="no"
	    break
        fi
    done
    if test "$noval" = "yes" ; then
        # Set a default
        MPI_FINT="int"
        AC_MSG_RESULT([unavailable])
    fi
    # We also need to check the size of MPI_Aint vs MPI_Fint, and
    # define AINT_LARGER_THAN_FINT if aint is larger (this 
    # affects code in MPI_Address)
    if test "$ac_cv_sizeof_void_p" != "0" -a \
        "$ac_cv_sizeof_void_p" -gt "$pac_cv_f77_sizeof_integer" ; then
        AC_DEFINE(HAVE_AINT_LARGER_THAN_FINT,1,[Define if addresses are larger than Fortran integers])
    fi
    if test "$ac_cv_sizeof_void_p" != 0 -a \
        "$ac_cv_sizeof_void_p" != "$pac_cv_f77_sizeof_integer" ; then
	AC_DEFINE(HAVE_AINT_DIFFERENT_THAN_FINT,1,[Define if addresses are a different size than Fortran integers])
    fi
    
    # Include a defined value for Fint is int
    if test "$MPI_FINT" = "int" ; then
        AC_DEFINE(HAVE_FINT_IS_INT,1,[Define if Fortran integer are the same size as C ints])
    elif test "$SIZEOF_F77_INTEGER" != "$ac_cv_sizeof_int" ; then
        # Make this fatal because we do not want to build a broken fortran
	# interface (was error)
        AC_MSG_WARN([Fortran integers and C ints are not the same size.  The current Fortran binding does not support this case.  Either force the Fortran compiler to use integers of $ac_cv_sizeof_int bytes, or use --disable-f77 on the configure line for MPICH2.])
    fi

    #
    # Set size of MPI_Status.  We may need sizeof_int here as well
    #

    #
    # The size of MPI_Status is needed for the Fortran interface. 
    # This is not quite right unless the device setup script, executed above,
    # sets the EXTRA_STATUS_DECL that will be used in defining a status.
    # The default size assumes that there are 5 ints
    AC_CACHE_CHECK([for size of MPI_Status],pac_cv_sizeof_mpi_status,[
        rm -f pac_mpi_status.h
        cat > pac_mpi_status.h <<_EOF
typedef struct {
    int count;
    int cancelled;
    int MPI_SOURCE;
    int MPI_TAG;
    int MPI_ERROR;
    $EXTRA_STATUS_DECL
} MPI_Status;
_EOF
        dnl another alternative is to use AC_CHECK_SIZEOF as follows:
        dnl AC_CHECK_SIZEOF([MPI_Status],[], [#include "pac_status.h"])
        dnl But AC_CHECK_SIZEOF has its own AC_MSG_CHECKING, so can't use
        dnl AC_CACHE_CHECK, so use AC_COMPUTE_INT here.
        default_status_size=`expr 5 \* $ac_cv_sizeof_int`
        AC_COMPUTE_INT([pac_cv_sizeof_mpi_status],
                       [sizeof(MPI_Status)],
                       [#include "pac_mpi_status.h"],
                       [pac_cv_sizeof_mpi_status=$default_status_size])
        rm -f pac_mpi_status.h
    ])

    SIZEOF_MPI_STATUS=$pac_cv_sizeof_mpi_status
    export SIZEOF_MPI_STATUS
    AC_SUBST(SIZEOF_MPI_STATUS)

    if test -z "$MPI_STATUS_SIZE" ; then
        if test -n "$SIZEOF_MPI_STATUS" ; then
            # compute from the C sizeof
            MPI_STATUS_SIZE=`expr $SIZEOF_MPI_STATUS / $ac_cv_sizeof_int`
            if test "$MPI_STATUS_SIZE" = "0" ; then
                AC_MSG_WARN([Could not compute the size of MPI_Status])
                MPI_STATUS_SIZE=5
            fi
        else
            AC_MSG_WARN([MPI_STATUS_SIZE was not defined!])
            # The default size is 5.  See mpi.h.in
            MPI_STATUS_SIZE=5
        fi
    fi
    AC_SUBST(MPI_STATUS_SIZE)

    # We must convert all hex values to decimal (!).
    # This is for the C types so they are also available in Fortran
    for var in CHAR SIGNED_CHAR UNSIGNED_CHAR WCHAR SHORT \
                  UNSIGNED_SHORT INT UNSIGNED_INT LONG UNSIGNED_LONG \
                  FLOAT DOUBLE LONG_DOUBLE LONG_LONG_INT \
                  UNSIGNED_LONG_LONG LONG_LONG FLOAT_INT DOUBLE_INT \
                  LONG_INT SHORT_INT "2INT" LONG_DOUBLE_INT \
                  INT8_T INT16_T INT32_T INT64_T            \
                  UINT8_T UINT16_T UINT32_T UINT64_T        \
                  C_BOOL C_FLOAT_COMPLEX C_DOUBLE_COMPLEX   \
                  C_LONG_DOUBLE_COMPLEX AINT OFFSET ; do
        fullvar="MPI_$var"
        fullf77var="MPI_F77_$var"
        eval fullvarvalue=\$$fullvar
        #echo "$fullvar = $fullvarvalue"
        if test "x$fullvarvalue" = "x" -o \
                "x$fullvarvalue" = "xMPI_DATATYPE_NULL" ; then
             eval $fullf77var="MPI_DATATYPE_NULL"
              continue
        fi
        value=0
        fullvarvalue=`echo $fullvarvalue | sed -e 's/..\(.*\)/\1/'`
        offset=0
        for pos in 3 4 5 6 7 8 9 10 ; do
            # This works, even for Tru64, because only a single character
            # is extracted
            char=`expr $fullvarvalue : '\(.\)'`
            # FIXME: Tru64 Unix eliminates leading zeros (!)
            # How do we fix something that broken?
            fullvarvalue=`echo $fullvarvalue | sed -e 's/.\(.*\)/\1/'`
            case $char in 
                a) char=10 ;;
                b) char=11 ;;
                c) char=12 ;;
                d) char=13 ;;
                e) char=14 ;;
                f) char=15 ;;
            esac
            # For Fortran, if the value is too big for an unsigned int, 
            # we need to make it a signed (negative) int. Currently, the
            # types in this class are the minloc/maxloc types.
            if test $pos = 3 -a $char -ge 8 ; then
                #echo "for $var in position $pos found a value >= 8"
                char=`expr $char - 8`
                offset=-2147483648
            fi
            value=`expr $value \* 16 + $char`
        done
        if test "$offset" != 0 ; then 
            #echo "$fullf77var: $value, $offset"
            value=`expr $value + $offset`
        fi
        #echo "$fullf77var = $value"
        eval $fullf77var=$value
    done
    AC_SUBST(MPI_F77_CHAR)
    AC_SUBST(MPI_F77_SIGNED_CHAR)
    AC_SUBST(MPI_F77_UNSIGNED_CHAR)
    AC_SUBST(MPI_F77_WCHAR)
    AC_SUBST(MPI_F77_SHORT)
    AC_SUBST(MPI_F77_UNSIGNED_SHORT)
    MPI_F77_UNSIGNED=$MPI_F77_UNSIGNED_INT
    AC_SUBST(MPI_F77_UNSIGNED)
    AC_SUBST(MPI_F77_INT)
    AC_SUBST(MPI_F77_LONG)
    AC_SUBST(MPI_F77_UNSIGNED_LONG)
    AC_SUBST(MPI_F77_FLOAT)
    AC_SUBST(MPI_F77_DOUBLE)
    AC_SUBST(MPI_F77_LONG_DOUBLE)
    AC_SUBST(MPI_F77_UNSIGNED_LONG_LONG)
    MPI_F77_LONG_LONG_INT=$MPI_F77_LONG_LONG
    AC_SUBST(MPI_F77_LONG_LONG_INT)
    AC_SUBST(MPI_F77_LONG_LONG)
    AC_SUBST(MPI_F77_FLOAT_INT)
    AC_SUBST(MPI_F77_DOUBLE_INT)
    AC_SUBST(MPI_F77_LONG_INT)
    AC_SUBST(MPI_F77_SHORT_INT)
    AC_SUBST(MPI_F77_2INT)
    AC_SUBST(MPI_F77_LONG_DOUBLE_INT)
    AC_SUBST(MPI_F77_INT8_T)
    AC_SUBST(MPI_F77_INT16_T)
    AC_SUBST(MPI_F77_INT32_T)
    AC_SUBST(MPI_F77_INT64_T)
    AC_SUBST(MPI_F77_UINT8_T)
    AC_SUBST(MPI_F77_UINT16_T)
    AC_SUBST(MPI_F77_UINT32_T)
    AC_SUBST(MPI_F77_UINT64_T)
    AC_SUBST(MPI_F77_C_BOOL)
    AC_SUBST(MPI_F77_C_FLOAT_COMPLEX)
    # C_COMPLEX is an alias for FLOAT_COMPLEX
    MPI_F77_C_COMPLEX=$MPI_F77_C_FLOAT_COMPLEX
    AC_SUBST(MPI_F77_C_COMPLEX)
    AC_SUBST(MPI_F77_C_DOUBLE_COMPLEX)
    AC_SUBST(MPI_F77_C_LONG_DOUBLE_COMPLEX)
    # these two are not yet defined, but AC_SUBST only cares about them at 
    # AC_OUTPUT-time
    AC_SUBST(MPI_F77_AINT)
    AC_SUBST(MPI_F77_OFFSET)

    # Try and compute the values of .true. and .false. in Fortran
    # This code has been removed because the Fortran binding code does
    # not yet support it.  
    PAC_F77_LOGICALS_IN_C([$MPI_FINT])

    # Check if multiple __attribute__((alias)) is available
    if test "$enable_multi_aliases" = "yes" ; then
        PAC_C_MULTI_ATTR_ALIAS
        if test "$pac_c_multi_attr_alias" = "yes" ; then
            PAC_F2C_ATTR_ALIGNED_SIZE([1],[CMB_1INT_ALIGNMENT])
            AC_SUBST(CMB_1INT_ALIGNMENT)
            PAC_F2C_ATTR_ALIGNED_SIZE([$MPI_STATUS_SIZE],[CMB_STATUS_ALIGNMENT],
                                      [32])
            AC_SUBST(CMB_STATUS_ALIGNMENT)
            if test "X$CMB_1INT_ALIGNMENT" != "X" \
                 -a "X$CMB_STATUS_ALIGNMENT" != "X" ; then
                AC_DEFINE(HAVE_C_MULTI_ATTR_ALIAS, 1,
                    [Define if multiple __attribute__((alias)) are supported])
            fi
        fi
    fi

    # Get the ADDRESS_KIND and OFFSET_KIND if possible
    #
    # For Fortran 90, we'll also need MPI_ADDRESS_KIND and MPI_OFFSET_KIND
    # Since our compiler might BE a Fortran 90 compiler, try and determine the
    # values.  
    if test -z "$FC" ; then
        PAC_F77_IS_FC([
            FC=$F77
            if test -z "$FCFLAGS" ; then
                FCFLAGS="$FFLAGS"
            fi
        ])
    fi
    if test -n "$FC" ; then
        # Offset kind should be for 8 bytes if possible (Romio prefers that)
        # address should be sizeof void * (unless --with-aint-size has
        # been set)
        # FIXME in the current configure implementation OFFSET_KIND and
        # MPI_Offset won't always agree, but generally will.  The MPI Standard
        # implies that these types must have identical size, so this is a bug
        # waiting to happen.
	if test "$with_aint_size" -gt 0 -a \
	        "$with_aint_size" -gt "$ac_cv_sizeof_void_p" ; then
	    testsize=$with_aint_size
        else
            testsize=$ac_cv_sizeof_void_p
        fi
        if test "$testsize" = 0 ; then
            # Set a default
            testsize=4
        fi  
        dnl Using the {} around testsize helps the comments work correctly
        PAC_PROG_FC_INT_KIND(ADDRESS_KIND,${testsize},$CROSS_F90_ADDRESS_KIND)
        if test "$testsize" = 8 ; then
            OFFSET_KIND=$ADDRESS_KIND
        else
            PAC_PROG_FC_INT_KIND(OFFSET_KIND,8,$CROSS_F90_OFFSET_KIND)
        fi
        #
        # Some compilers won't allow a -1 kind (e.g., absoft).  In this case, 
        # use a fallback (sizeof(int) kind)
        if test "$ADDRESS_KIND" = "-1" -o "$OFFSET_KIND" = "-1" ; then
            PAC_PROG_FC_INT_KIND(simpleintkind,${pac_cv_f77_sizeof_integer})
            if test "$simpleintkind" = "-1" ; then
	        # Wild guess; probably means that Fortran 90 is not available
		AC_MSG_WARN([Unable to determine Fortran 90 KIND values for either address-sized integers or offset-sized integers.  Using 4 in that case.])
                simpleintkind=4
            fi
            if test "$ADDRESS_KIND" = "-1" ; then
	        ADDRESS_KIND=$simpleintkind
            fi
            if test "$OFFSET_KIND" = "-1" ; then
	        OFFSET_KIND=$simpleintkind
            fi
        fi
	AC_LANG_PUSH([Fortran])
        AC_CACHE_CHECK([if real*8 is supported in Fortran 90],
                       [pac_cv_fort90_real8],[
            AC_COMPILE_IFELSE([
                AC_LANG_PROGRAM([],[      real*8 a])
            ],[
                pac_cv_fort90_real8=yes
            ],[
                pac_cv_fort90_real8=no
            ])
        ])
	AC_LANG_POP([Fortran])
	WTIME_DOUBLE_TYPE="DOUBLE PRECISION"
	# Save a copy of the original mpi_base.f90 file
	if test "$enable_fc" = "yes" -a "$pac_cv_fort90_real8" = "yes" ; then
	    WTIME_DOUBLE_TYPE="REAL*8"
        fi
	# WTIME_DOUBLE_TYPE is substituted into mpi_base.f90
	AC_SUBST(WTIME_DOUBLE_TYPE)
    fi
    # Make sure that address kind and offset kind have values.
    if test -z "$ADDRESS_KIND" ; then
        ADDRESS_KIND=0
    fi
    if test -z "$OFFSET_KIND" ; then
        OFFSET_KIND=0
    fi
    # Note, however, that zero value are (in all practical case) invalid 
    # for Fortran 90, and indicate a failure.  Test and fail if Fortran 90
    # enabled.
    if test "$enable_fc" = "yes" ; then
        if test "$ADDRESS_KIND" -le 0 -o "$OFFSET_KIND" -le 0 ; then
	    AC_MSG_ERROR([Unable to determine Fortran 90 integer kinds for MPI types.  If you do not need Fortran 90, add --disable-fc to the configure options.])
	    # If the above is converted to a warning, you need to change 
	    # enable_fc and remote f90 from the bindings
	    enable_fc=no
        fi
    fi
    AC_SUBST(ADDRESS_KIND)
    AC_SUBST(OFFSET_KIND)

    # Some compilers may require special directives to handle the common 
    # block in a library.  In particular, directives are needed for Microsoft 
    # Windows to support dynamic library import.  The following six
    # directives may be needed:
    #  CMS\$ATTRIBUTES DLLIMPORT::/MPIPRIV1/
    #  CMS\$ATTRIBUTES DLLIMPORT::/MPIPRIV2/
    #  CMS\$ATTRIBUTES DLLIMPORT::/MPIPRIVC/
    #  CDEC\$ATTRIBUTES DLLIMPORT::/MPIPRIV1/
    #  CDEC\$ATTRIBUTES DLLIMPORT::/MPIPRIV2/
    #  CDEC\$ATTRIBUTES DLLIMPORT::/MPIPRIVC/
    # CMS is for the Microsoft compiler,
    # CDEC is (we believe) for the DEC Fortran compiler.  
    # We need to make this a configure-time variable because some compilers
    # (in particular, a version of the Intel Fortran compiler for Linux)
    # will read directives for other compilers and then flag as fatal
    # errors directives that it does not support but does recognize.

    DLLIMPORT=""
    AC_SUBST(DLLIMPORT)

    # FIXME:
    # We also need to include
    # SIZEOF_FC_MPI_OFFSET
    # SIZEOF_FC_MPI_AINT
    # 
    # If other "kinds" are supported, MPI_SIZEOF needs to identify 
    # those as well.  This is very difficult to do in a general way.

    # To start with, we use the sizes determined for the Fortran 77 values.
    # These must be the same as for the Fortran 90 values.
    CROSS_F90_SIZEOF_INTEGER=${CROSS_F90_SIZEOF_INTEGER:-0}
    CROSS_F90_SIZEOF_REAL=${CROSS_F90_SIZEOF_REAL:-0}
    CROSS_F90_SIZEOF_DOUBLE_PRECISION=${CROSS_F90_SIZEOF_DOUBLE_PRECISION:-0}
    SIZEOF_FC_INTEGER=$CROSS_F90_SIZEOF_INTEGER
    SIZEOF_FC_REAL=$CROSS_F90_SIZEOF_REAL
    SIZEOF_FC_CHARACTER=1
    SIZEOF_FC_DOUBLE_PRECISION=$CROSS_F90_SIZEOF_DOUBLE_PRECISION
    if test "$pac_cv_f77_sizeof_integer" -gt 0 -a \
	    "$SIZEOF_FC_INTEGER" = "0" ; then
        SIZEOF_FC_INTEGER=$pac_cv_f77_sizeof_integer
    fi
    if test "$pac_cv_f77_sizeof_real" -gt 0 -a "$SIZEOF_FC_REAL" = "0" ; then
        SIZEOF_FC_REAL=$pac_cv_f77_sizeof_real
    fi
    if test "$pac_cv_f77_sizeof_double_precision" -gt 0 -a \
       "$SIZEOF_FC_DOUBLE_PRECISION" = "0" ; then
        SIZEOF_FC_DOUBLE_PRECISION=$pac_cv_f77_sizeof_double_precision
    fi
    AC_SUBST(SIZEOF_FC_INTEGER)
    AC_SUBST(SIZEOF_FC_REAL)
    AC_SUBST(SIZEOF_FC_DOUBLE_PRECISION)
    AC_SUBST(SIZEOF_FC_CHARACTER)

    # REQD is short for "real equal double precision" and is set to the
    # Fortran 90 comment character if true.  This is necessary to
    # allow the mpi_sizeofs module to be built, since if this part of the
    # Fortran standard is violated by the compiler (unfortunately common,
    # as some applications are written to require this non-standard 
    # version), the double precision versions of the MPI_SIZEOF routine
    # must be commented out of the module (!).
    REQD=
    if test "$SIZEOF_FC_REAL" = "$SIZEOF_FC_DOUBLE_PRECISION" ; then
        REQD="!"
    fi
    AC_SUBST(REQD)
    # Is integer*1 supported, and is it a different size than integer?
    REQI1="!"
    if test "$pac_cv_fort_integer1" = yes -a "$SIZEOF_FC_INTEGER" != 1 ; then
        REQI1=
    fi
    AC_SUBST(REQI1)
    # Is integer*2 supported, and is it a different size than integer?
    REQI2="!"
    if test "$pac_cv_fort_integer2" = yes -a "$SIZEOF_FC_INTEGER" != 2 ; then
        REQI2=
    fi
    AC_SUBST(REQI2)
    # Is integer*8 supported, and is it a different size than integer?
    REQI8="!"
    if test "$pac_cv_fort_integer8" = yes -a "$SIZEOF_FC_INTEGER" != 8 ; then
        REQI8=
    fi
    AC_SUBST(REQI8)
    # 

    AC_LANG_C
fi
# ----------------------------------------------------------------------------
# C++ types
if test "$enable_cxx" = "yes" ; then
    AC_LANG_CPLUSPLUS
    AC_CHECK_SIZEOF(bool)

    # Find a C type that matches the size of the C++ boolean type
    case "$ac_cv_sizeof_bool" in
    	 $ac_cv_sizeof__Bool)
		bool_type=_Bool
		;;
    	 $ac_cv_sizeof_unsigned_char)
		bool_type="unsigned char"
		;;
    	 $ac_cv_sizeof_unsigned_short)
		bool_type="unsigned short"
		;;
    	 $ac_cv_sizeof_unsigned_int)
		bool_type="unsigned int"
		;;
    	 $ac_cv_sizeof_unsigned_long)
		bool_type="unsigned long"
		;;
    	 $ac_cv_sizeof_unsigned_long_long)
		bool_type="unsigned long long"
		;;
         *)
		AC_MSG_ERROR([unable to determine matching C type for C++ bool])
		;;
    esac
    AC_DEFINE_UNQUOTED([MPIR_CXX_BOOL_CTYPE],[$bool_type],
			[a C type used to compute C++ bool reductions])

    AC_CHECK_HEADER(complex)
    if test "$ac_cv_header_complex" = "yes" ; then 
        # The C++ complex types are all templated.  We finagle this by 
        # defining a standin name
        AC_CHECK_SIZEOF(Complex,0,[#include <stdio.h>
#include <complex>
using namespace std;
#define Complex complex<float>
])
        AC_CHECK_SIZEOF(DoubleComplex,0,[#include <stdio.h>
#include <complex>
using namespace std;
#define DoubleComplex complex<double>
])
        if test "$MPID_NO_LONG_DOUBLE" != yes ; then
             AC_CHECK_SIZEOF(LongDoubleComplex,0,[#include <stdio.h>
#include <complex>
using namespace std;
#define LongDoubleComplex complex<long double>
])
        fi

        # If either complex or double complex have length 0, then mark
        # c++ complex as unavailable
        if test "$ac_cv_sizeof_Complex" != 0 -a \
                "$ac_cv_sizeof_DoubleComplex" != 0 ; then
            AC_DEFINE(HAVE_CXX_COMPLEX,1,[Define is C++ supports complex types])
        fi

        # Datatypes are given by
        # 0x4c00 <length in bytes> (1 byte) <unique num> (1 byte)    
        # where the unique nums are
        # 33,34,35,36
        case "$ac_cv_sizeof_bool" in 
           1)    MPIR_CXX_BOOL=0x4c000133 ;;
           2)    MPIR_CXX_BOOL=0x4c000233 ;;
           4)    MPIR_CXX_BOOL=0x4c000433 ;;
           8)    MPIR_CXX_BOOL=0x4c000833 ;;
           *) ;;
        esac
        case "$ac_cv_sizeof_Complex" in 
           8)    MPIR_CXX_COMPLEX=0x4c000834 ;;
           16)   MPIR_CXX_COMPLEX=0x4c001034 ;;
           *) ;;
        esac
        case "$ac_cv_sizeof_DoubleComplex" in 
           8)    MPIR_CXX_DOUBLE_COMPLEX=0x4c000835 ;;
           16)   MPIR_CXX_DOUBLE_COMPLEX=0x4c001035 ;;
           32)   MPIR_CXX_DOUBLE_COMPLEX=0x4c002035 ;;
           *) ;;
        esac
        case "$ac_cv_sizeof_LongDoubleComplex" in 
           8)    MPIR_CXX_LONG_DOUBLE_COMPLEX=0x4c000836 ;;
           16)   MPIR_CXX_LONG_DOUBLE_COMPLEX=0x4c001036 ;;
           24)   MPIR_CXX_LONG_DOUBLE_COMPLEX=0x4c001836 ;;
           32)   MPIR_CXX_LONG_DOUBLE_COMPLEX=0x4c002036 ;;
           *) ;;
        esac
    fi
    AC_LANG_C

    # Make these available to the collective operations and other code
    AC_DEFINE_UNQUOTED(MPIR_CXX_BOOL_VALUE,$MPIR_CXX_BOOL,[Define as the MPI Datatype handle for MPI::BOOL])
    AC_DEFINE_UNQUOTED(MPIR_CXX_COMPLEX_VALUE,$MPIR_CXX_COMPLEX,[Define as the MPI Datatype handle for MPI::COMPLEX])
    AC_DEFINE_UNQUOTED(MPIR_CXX_DOUBLE_COMPLEX_VALUE,$MPIR_CXX_DOUBLE_COMPLEX,[Define as the MPI Datatype handle for MPI::DOUBLE_COMPLEX])
    AC_DEFINE_UNQUOTED(MPIR_CXX_LONG_DOUBLE_COMPLEX_VALUE,$MPIR_CXX_LONG_DOUBLE_COMPLEX,[Define as the MPI Datatype handle for MPI::LONG_DOUBLE_COMPLEX])
    
fi

# ----------------------------------------------------------------------------

# Is char * the byte address?
AC_CACHE_CHECK([if char * pointers use byte addresses],
pac_cv_c_char_p_is_byte,[
AC_TRY_RUN([
int main(int argc, char **argv ){
char *a, buf;
a = &buf;
if ((long)(a-(char*)0) == (long)(a)) return 0; return 1;
}],pac_cv_c_char_p_is_byte=yes,pac_cv_char_p_is_byte=no,
pac_cv_char_p_is_byte=unknown)])
if test "$pac_cv_char_p_is_byte" = "yes" ; then
    AC_DEFINE(CHAR_PTR_IS_BYTE,1,[define if char * is byte pointer])
fi
# ----------------------------------------------------------------------------
#
# Check for the alignment rules moves with types int64_t etc.  These
# are used in the datatype code to perform pack and unpack operations.  
# These only determine if different alignments *work*, not whether they
# work efficiently.  The datatype pack code (should) allow the developer
# to include stricter alignment rules than are needed for correctness to
# get better performance.
if test "$ac_cv_c_int64_t" != "no" -o -n "$INT64_T" ; then
    default_int64_t_alignment=${CROSS_INT64_T_ALIGNMENT:-"unknown"}
    if test -z "$INT64_T" ; then
         if test "$ac_cv_c_int64_t" = yes ; then
	     INT64_T="int64_t"
         else
             INT64_T="$ac_cv_int64_t"
         fi
    fi
    # We use the type that we're going use for int64.
    AC_CACHE_CHECK([for alignment restrictions on $MYINT64_T],pac_cv_int64_t_alignment,[
    AC_TRY_RUN([
#include <sys/types.h>
#include <stdlib.h>
int main(int argc, char **argv )
{
    $INT64_T *p1, v;
    char    *buf_p = (char *)malloc( 64 ), *bp;
    bp = buf_p;
    /* Make bp aligned on 4, not 8 bytes */
    if (!( (long)bp & 0x7 ) ) bp += 4;
    p1 = ($INT64_T *)bp;
    v = -1;
    *p1 = v;
    if (!( (long)bp & 0x3 ) ) bp += 2;
    p1 = ($INT64_T *)bp;
    *p1 = 1;
    if (!( (long)bp & 0x1 ) ) bp += 1;
    p1 = ($INT64_T *)bp;
    *p1 = 1;
    return 0;
}
],pac_cv_int64_t_alignment=no,pac_cv_int64_t_alignment=yes,pac_cv_int64_t_alignment=$default_int64_t_alignment)
])
    if test "$pac_cv_int64_t_alignment" = "no" ; then
         AC_DEFINE(HAVE_ANY_INT64_T_ALIGNMENT,1,[Define if int64_t works with any alignment])
    fi
fi

if test "$ac_cv_int32_t" != "no" ; then
    default_int32_t_alignment=${CROSS_INT32_T_ALIGNMENT:-"unknown"}
    if test -z "$INT32_T" ; then
         if test "$ac_cv_c_int32_t" = yes ; then
	     INT32_T="int32_t"
         else
             INT32_T="$ac_cv_int32_t"
         fi
    fi
    
    AC_CACHE_CHECK([for alignment restrictions on int32_t],pac_cv_int32_t_alignment,[
    AC_TRY_RUN([
#include <sys/types.h>
#include <stdlib.h>
int main(int argc, char **argv )
{
    $INT32_T *p1, v;
    char    *buf_p = (char *)malloc( 64 ), *bp;
    bp = buf_p;
    /* Make bp aligned on 4, not 8 bytes */
    if (!( (long)bp & 0x7 ) ) bp += 4;
    p1 = ($INT32_T *)bp;
    v = -1;
    *p1 = v;
    if (!( (long)bp & 0x3 ) ) bp += 2;
    p1 = ($INT32_T *)bp;
    *p1 = 1;
    if (!( (long)bp & 0x1 ) ) bp += 1;
    p1 = ($INT32_T *)bp;
    *p1 = 1;
    return 0;
}
],pac_cv_int32_t_alignment=no,pac_cv_int32_t_alignment=yes,pac_cv_int32_t_alignment=$default_int32_t_alignment)
])
    if test "$pac_cv_int32_t_alignment" = "no" ; then
         AC_DEFINE(HAVE_ANY_INT32_T_ALIGNMENT,1,[Define if int32_t works with any alignment])
    fi
fi

# Get the size for the bsendoverhead
AC_CHECK_SIZEOF(MPIR_Bsend_data_t,128,[
#define MPI_Datatype int
#include "${master_top_srcdir}/src/include/mpibsend.h"]
)
BSEND_OVERHEAD=$ac_cv_sizeof_MPIR_Bsend_data_t
export BSEND_OVERHEAD
AC_SUBST(BSEND_OVERHEAD)

# Check for special compile characteristics
# If we are either gcc or icc, see if we can use __asm__
# We test on prog_gcc to allow gcc by any name; if we are using
# icc, the value of CC must be icc for this test to pass
if test "$ac_cv_prog_gcc" = "yes" -o "$ac_cv_prog_CC" = "icc" ; then
AC_MSG_CHECKING([for gcc __asm__ and pentium cmpxchgl instruction])
AC_TRY_RUN([
int main(int argc, char *argv[])
{
long int compval = 10;
volatile long int *p = &compval;
long int oldval = 10;
long int newval = 20;
char ret;
long int readval;
__asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
	: "=q" (ret), "=m" (*p), "=a" (readval)
	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
return (compval == 20) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_PENTIUM_ASM, 1,[Define if using gcc on a system with an Intel Pentium class chip])
   lac_cv_use_atomic_updates="yes", 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
if test "$lac_cv_use_atomic_updates" = "yes" ; then
    AC_DEFINE(USE_ATOMIC_UPDATES,, [Define if assembly language atomic update macros should be used (if available)])
fi

# check for x86_64
if test "$ac_cv_prog_gcc" = "yes" ; then
AC_MSG_CHECKING([for gcc __asm__ and AMD x86_64 cmpxchgq instruction])
AC_TRY_RUN([
int main(int argc, char *argv[])
{
long int compval = 10;
volatile long int *p = &compval;
long int oldval = 10;
long int newval = 20;
char ret;
long int readval;
__asm__ __volatile__ ("lock; cmpxchgq %3, %1; sete %0"
	: "=q" (ret), "=m" (*p), "=a" (readval)
	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
return (compval == 20) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_X86_64_ASM, 1,[Define if using gcc on a system with an AMD x86_64 class chip]), 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
dnl
dnl check for asm() format
dnl 
dnl AC_MSG_CHECKING([for asm() and pentium cmpxchgl instruction])
dnl AC_TRY_RUN([
dnl int main(int argc, char *argv[])
dnl {
dnl long int compval = 10;
dnl volatile long int *p = &compval;
dnl long int oldval = 10;
dnl long int newval = 20;
dnl char ret;
dnl long int readval;
dnl asm("lock; cmpxchgl %3, %1; sete %0"
dnl 	: "=q" (ret), "=m" (*p), "=a" (readval)
dnl 	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
dnl return (compval == 20) ? 0 : -1;
dnl }
dnl ], AC_MSG_RESULT(yes)
dnl    AC_DEFINE(HAVE_PENTIUM_ASM, 1,[Define if using asm() on a system with an Intel Pentium class chip]),
dnl AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
dnl
dnl
dnl check for IA64
dnl 
if test "$ac_cv_prog_gcc" = "yes" ; then
AC_MSG_CHECKING([for gcc __asm__ and IA64 xchg4 instruction])
AC_TRY_RUN([
unsigned long _InterlockedExchange(volatile void *ptr, unsigned long x)
{
   unsigned long result;
   __asm__ __volatile ("xchg4 %0=[%1],%2" : "=r" (result)
       : "r" (ptr), "r" (x) : "memory");
   return result;
}
int main(int argc, char *argv[])
{
long val = 1;
volatile long *p = &val;
long oldval = _InterlockedExchange(p, (unsigned long)2);
return (oldval == 1 && val == 2) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_IA64_ASM, 1,[Define if using gcc on a system with an IA64 class chip]), 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
# -----------------------------------------------------------------------------
# Check for support of enable-coverage.  Put this near the end of the tests
# because the coverage options may affect the other tests.
if test "$enable_coverage" = "yes" ; then
    if test "$ac_cv_prog_gcc" = "yes" ; then
        CFLAGS="$CFLAGS -fprofile-arcs -ftest-coverage"
        WRAPPER_CFLAGS="$WRAPPER_CFLAGS -fprofile-arcs -ftest-coverage"
    else
        AC_MSG_WARN([--enable-coverage only supported for GCC])
    fi
    if test "$enable_cxx" = "yes" ; then
        if test "$ac_cv_cxx_compiler_gnu" = "yes" ; then
            CXXFLAGS="$CXXFLAGS -fprofile-arcs -ftest-coverage"
            WRAPPER_CXXFLAGS="$WRAPPER_CXXFLAGS -fprofile-arcs -ftest-coverage"
        else
            AC_MSG_WARN([--enable-coverage only supported for GCC])
        fi
    fi
    # Add similar options for g77 so that the Fortran tests will also
    # 
    if test "$enable_f77" = yes ; then
        if test "$ac_cv_f77_compiler_gnu" = "yes" ; then
             FFLAGS="$FFLAGS -fprofile-arcs -ftest-coverage"
             WRAPPER_FFLAGS="$WRAPPER_FFLAGS -fprofile-arcs -ftest-coverage"
        else
            AC_MSG_WARN([--enable-coverage only supported for G77/GFORTRAN])
        fi
    fi
    if test "$enable_fc" = yes ; then
        if test "$ac_cv_fc_compiler_gnu" = "yes" ; then
             FCFLAGS="$FCFLAGS -fprofile-arcs -ftest-coverage"
             WRAPPER_FCFLAGS="$WRAPPER_FCFLAGS -fprofile-arcs -ftest-coverage"
        else
            AC_MSG_WARN([--enable-coverage only supported for GFORTRAN])
        fi
    fi
    # On some platforms (e.g., Mac Darwin), we must also *link* 
    # with the -fprofile-args -ftest-coverage option.
    AC_MSG_CHECKING([whether compilation with coverage analysis enabled works])
    AC_LINK_IFELSE([
        AC_LANG_SOURCE([int main(int argc, char **argv){return 1;}])
    ],[
        AC_MSG_RESULT(yes)
    ],[
        AC_MSG_RESULT(no)
        AC_MSG_ERROR([Unable to link programs when coverage analysis enabled])
    ])
    
    # Test for the routines that we need to use to ensure that the
    # data files are (usually) written out
    # FIXME: Some versions of Linux provide usleep, but it rounds times
    # up to the next second (!)
    AC_CHECK_FUNCS(usleep)
    AC_DEFINE(USE_COVERAGE,1,[Define if performing coverage tests])
fi
# -----------------------------------------------------------------------------
# Look for Standard headers
AC_HEADER_STDC
# Check for a specific header
# Grrr.  OS/X fails the test for sys/uio.h because uio *requires* sys/types.h
# to compile.  Thus, we'll make that a separate test
# stddef.h is sometimes needed for types like wchar_t
AC_CHECK_HEADERS(stdlib.h stdarg.h sys/types.h string.h inttypes.h limits.h stddef.h errno.h sys/socket.h sys/time.h unistd.h endian.h assert.h sys/param.h)
AC_CACHE_CHECK([for sys/uio.h],ac_cv_header_sys_uio_h,[
AC_TRY_COMPILE([
#include <sys/types.h>
#include <sys/uio.h>
],[int a;],ac_cv_header_sys_uio_h=yes,ac_cv_header_sys_uio_h=no)])
if test "$ac_cv_header_sys_uio_h" = yes ; then
    AC_DEFINE(HAVE_SYS_UIO_H,1,[Define if you have the <sys/uio.h> header file.])
fi

# Check for special types
AC_TYPE_SIZE_T

# These are used to support timeouts
AC_CHECK_FUNCS(setitimer alarm)
# These are used for error reporting
AC_CHECK_FUNCS(vsnprintf vsprintf)
if test "$ac_cv_func_vsnprintf" = "yes" ; then
    # vsnprintf may be declared in stdio.h and may need stdarg.h 
    PAC_FUNC_NEEDS_DECL([#include <stdio.h>
#include <stdarg.h>],vsnprintf)
fi
# We would like to use strerror in the file namepublisher; it is also used
# in MPIU_Strerror (whose implementation is broken if strerror is not found)
AC_CHECK_FUNCS(strerror strncasecmp)
AC_FUNC_STRERROR_R
if test "$ac_cv_func_strerror_r" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <string.h>],strerror_r)
fi

# Use snprintf if possible when creating messages
AC_CHECK_FUNCS(snprintf)
if test "$ac_cv_func_snprintf" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <stdio.h>],snprintf)
fi

# qsort will be used in MPI_Comm_split, if available
AC_CHECK_FUNCS([qsort])

# if we are using stdarg, we may need va_copy .  Test to see if we have it
# Since it may be a built-in instead of a function, we must try to 
# compile and link a program that uses it.
# va_copy is currently used only in src/util/dbg_printf.c, in an obsolete
# debugging routine.  We may want to withdraw this (saving the
# test in confdb/aclocal_cc.m4).
AC_CACHE_CHECK([for va_copy],pac_cv_func_va_copy,[
AC_TRY_LINK([
#include <stdarg.h>
void foo1( char *fmt, ... ) {
    va_list ap, list;
    va_start(ap,fmt);
    va_copy(list,ap);
    va_end(list);
    va_end(ap);
}
],[foo1("a test %d", 3);],pac_cv_func_va_copy=yes,pac_cv_func_va_copy=no)])

if test "$pac_cv_func_va_copy" = "yes" ; then
    AC_DEFINE(HAVE_VA_COPY,1,[Define if we have va_copy])
else
    AC_CACHE_CHECK([for __va_copy],pac_cv_func___va_copy,[
    AC_TRY_LINK([
#include <stdarg.h>
void foo1( char *fmt, ... ) {
    va_list ap, list;
    va_start(ap,fmt);
    __va_copy(list,ap);
    va_end(list);
    va_end(ap);
}
],[foo1("a test %d", 3);],pac_cv_func___va_copy=yes,pac_cv_func___va_copy=no)])
    if test "$pac_cv_func___va_copy" = "yes" ; then
        AC_DEFINE(HAVE___VA_COPY,1,[Define if we have __va_copy])
    fi
fi

PAC_C_MACRO_VA_ARGS

dnl
dnl If internationalization selected, try to find the needed functions
dnl if test "$enable_internat" = "yes" ; then
dnl     AC_CHECK_HEADERS(libintl.h)
dnl     AC_CHECK_FUNCS(gettext dgettext)
dnl     if test "$ac_cv_header_libintl" = "yes" -a \
dnl 	    "$ac_cv_func_gettext" = "yes" -a \
dnl 	    "$ac_cv_func_dgettext" = "yes" ; then
dnl 	AC_DEFINE(USE_GETTEXT,1,[Define if messages should use gettext])
dnl     else
dnl         AC_MSG_WARN([Cannot use internationalization because necessary headers and functions are not available])
dnl     fi
dnl fi
# Check for alloca function.  May set HAVE_ALLOCA_H and HAVE_ALLOCA
AC_FUNC_ALLOCA
# We don't use alloca unless USE_ALLOCA is also set.
AC_ARG_ENABLE(alloca,
	AC_HELP_STRING([--enable-alloca],
		[Use alloca to allocate temporary memory if available]),,enable_alloca=no)
if test "$enable_alloca" = yes ; then
    AC_DEFINE(USE_ALLOCA,1,[Define if alloca should be used if available])
fi

if test "$enable_g_mem" != "yes" ; then
    # Strdup is needed only if memory tracing is not enabled.
    AC_CHECK_FUNCS(strdup)
    if test "$ac_cv_func_strdup" = "yes" ; then
        # Do we need to declare strdup?
        PAC_FUNC_NEEDS_DECL([#include <string.h>],strdup)
    fi
else
    # search.h is used for fancier output from trmem.  Disabled for now,
    # since the tsearch routines have problematic prototypes.
    AC_CHECK_HEADERS(search)
    AC_CHECK_FUNCS(tsearch)
    # Check that we can compile tsearch without error.  Try to compile
    # it with the header and the char * args
    if test "$ac_cv_func_tsearch" = "yes" ; then
        AC_CACHE_CHECK([whether tsearch requires char* args],
	               pac_cv_tsearch_charp,[
        AC_TRY_COMPILE([#include <search.h>
    char *tsearch( char *k, char **r, (int (*)())compare ) { return k; }],
    [int f=0;],pac_cv_tsearch_charp=yes,pac_cv_tsearch_charp=no)])
        if test "$pac_cv_tsearch_charp" = "yes" ; then
	    # this should consider defining a name with the argument type
	    # so that no further ifdefs are needed
	    AC_DEFINE(USE_TSEARCH_WITH_CHARP,1,[Define if tsearch requires char pointers])
	fi
    fi
    # Note that HPUX and AIX may require _INCLUDE_XOPEN_SOURCE or
    # _XOPEN_SOURCE be defined respectively.
fi

# ----------------------------------------------------------------------------
# Look for some non-posix, but commonly provided functions
# ----------------------------------------------------------------------------
# mkstemp() is a better replacement for mktemp()
AC_HAVE_FUNCS(mkstemp)
if test "$ac_cv_func_mkstemp" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <stdlib.h>],mkstemp)
fi
# fdopen() converts from an fd to a FILE*
AC_HAVE_FUNCS(fdopen)
if test "$ac_cv_func_fdopen" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <stdlib.h>],fdopen)
fi
# putenv() sets environment variable
AC_HAVE_FUNCS(putenv)
if test "$ac_cv_func_putenv" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <stdlib.h>],putenv)
fi


# ----------------------------------------------------------------------------
# Support for timers.  The following code processes the 
#  --enable-timer-type=name argument and selects the timer based on 
# both that field and what configure is able to determine is available.
# The file src/include/mpichtimer.h is also created.
# Note that at least the handling of the "device" option must come *after* 
# the setup_device script is loaded so that the device can set the appropriate
# fields.  For now, we've split this so that there is an update to the timer
# after the setup_device script is loaded, but we should consider moving
# this entire block.
# ----------------------------------------------------------------------------
# Default type for timer stamp.
MPID_TIMER_TYPE=long
AC_SUBST(MPID_TIMER_TYPE)

# clock_gettime is the POSIX gettimeofday
# gethrtime is the Solaris high-resolution timer
dnl
dnl Specific checks that a function works correctly
dnl
dnl Now that we know what the options are, choose the timer to use
dnl
dnl The default preference is
dnl    Solaris gethrtime
dnl    Posix   clock_gettime
dnl    Unix    gettimeofday (one of two versions)
dnl
dnl Also available are various hardware time stamps
dnl    Linux-x86 cycle counter
dnl    Linux-alpha cycle counter
dnl
dnl We also allow --enable-timer-type=name to select a timer type
AC_ARG_ENABLE(timer-type,
[  --enable-timer-type=name - Select the timer to use for MPI_Wtime and
                             internal timestamps.
        gethrtime          - Solaris timer (Solaris systems only)
        clock_gettime      - Posix timer (where available)
        gettimeofday       - Most Unix systems
        linux86_cycle      - Linux x86; returns cycle counts, not time in seconds*
        gcc_ia64_cycle     - IPF ar.itc timer*
	mach_absolute_time - Mach absolute time (alternative to clock_gettime
                             for OSX)
        device - The timer is provided by the device

        *Note that the cycle timers are intended to be used by MPICH2
        developers for internal low-level timing.  Normal users should
        not use these as they are not guaranteed to be accurate in
        certain situations.

        linuxalpha_cycle is no longer supported.
],timer_type=$enable_timer_type)

if test -z "$timer_type" ; then 
    # Try to pick a timer based on what is available
    AC_CHECK_FUNCS(clock_gettime clock_getres gethrtime mach_absolute_time gettimeofday)
    if test "$ac_cv_func_gethrtime" = "yes" ; then
        # Sigh.  The Solaris include files do not define hrtime_t
	# Before we accept this choice, make sure that we can 
	# do arithmetic with hrtime_t .
        AC_CACHE_CHECK([that hrtime_t is properly defined for gethrtime],
	pac_cv_hrtime_works,[
	AC_TRY_COMPILE([
#include <sys/time.h>
],[hrtime_t t1, t2; t1 = 1; t2 = 2; t1 = t1 + t2;],
pac_cv_hrtime_works=yes,pac_cv_hrtime_works=no)])
	# A more ambitious test would look to see if casting an 
	# hrtime_t to int64_t works, and even more ambitious
	# would check whether long or long long was 64 bits (or even
	# better, the sizeof hrtime_t).  
    fi
    if test "$ac_cv_func_gethrtime" = "yes" -a \
            "$pac_cv_hrtime_works" = "yes" ; then
        timer_type=gethrtime
    elif test "$ac_cv_func_clock_gettime" = "yes" -a \
              "$ac_cv_func_clock_getres" = "yes" ; then
	 # Test on both because some systems (e.g., cygwin) provide
	 # clock_gettime but not clock_getres
        timer_type=clock_gettime
    elif test "$ac_cv_func_mach_absolute_time" = "yes" ; then 
        timer_type=mach_absolute_time
    elif test "$ac_cv_func_gettimeofday" = "yes" ; then
        timer_type=gettimeofday
    fi
fi
if test -z "$timer_type" ; then
    AC_MSG_ERROR([No timer found])
fi

# Check for valid timer and select datatypes for the time stamp
case "$timer_type" in

    gethrtime)
    MPID_TIMER_TYPE=hrtime_t
    AC_CHECK_FUNC(gethrtime,,[
         AC_MSG_ERROR([Requested timer gethrtime is not available])
])
    ;;

    clock_gettime)
    missing_function=no
    AC_SEARCH_LIBS([clock_gettime],[rt],,AC_MSG_ERROR([clock_gettime is not available]))
    AC_SEARCH_LIBS([clock_getres],[rt],,AC_MSG_ERROR([clock_getres is not available]))
    MPID_TIMER_TYPE="struct timespec"
    # AIX does not always define struct timespec (!)
    # Make sure that we can use struct timespec
    AC_CACHE_CHECK([whether struct timespec is defined in time.h],
                    pac_cv_struct_timespec_defined,[
    AC_TRY_COMPILE([
#include <time.h>],[
    struct timespec t;],pac_cv_struct_timespec_defined=yes,
    pac_cv_struct_timespec_defined=no)
])
    if test "$pac_cv_struct_timespec_defined" != "yes" ; then
        # Try again, but with -D_XOPEN_SOURCE=500 (works for AIX)
        AC_CACHE_CHECK([whether struct timespec is defined in time.h with _XOPEN_SOURCE=500],
                    pac_cv_struct_timespec_defined_with_xopen500,[
        AC_TRY_COMPILE([
#define _XOPEN_SOURCE 500
#include <time.h>],[
    struct timespec t;],pac_cv_struct_timespec_defined_with_xopen500=yes,
    pac_cv_struct_timespec_defined_with_xopen500=no)
])
	if test "$pac_cv_struct_timespec_defined_with_xopen500" = "yes" ; then
	    # We need to define _XOPEN_SOURCE=500, but we need to ensure that
	    # this is done before any include files are loaded.  At
	    # this point it is really too late to add this definition,
	    # since it may make other tests incompatible.
	    AC_MSG_ERROR([The available timer requires _XOPEN_SOURCE=500.  Add -D_XOPEN_SOURCE=500 to CFLAGS and rerun configure])
        fi
    fi
    # 
    # FreeBSD 4.3 incorrectly puts the header into sys/time.h; 
    # time.h is required (see pages 45 and 46 in the POSIX standard).
    # See if we can compile
    AC_CACHE_CHECK([for CLOCK_REALTIME defined in time.h],pac_cv_posix_clock_realtime,[
    AC_TRY_COMPILE([
#include <time.h>],[
    clockid_t cid = CLOCK_REALTIME;],pac_cv_posix_clock_realtime=yes,
pac_cv_posix_clock_realtime=no)])
    if test "$pac_cv_posix_clock_realtime" = "no" ; then
         AC_MSG_WARN([POSIX timer requires definitions in time.h])
	 # Check for the definition in sys/time.h, which is where
	 # OpenBSD and FreeBSD have put it by mistake
         AC_TRY_COMPILE([
#include <time.h>
#include <sys/time.h>],[
    clockid_t cid = CLOCK_REALTIME;],pac_cv_posix_clock_realtime=yes,
pac_cv_posix_clock_realtime=no)
	if test "$pac_cv_posix_clock_realtime" = yes ; then
	    AC_MSG_WARN([sys/time.h required for POSIX timer])
	    AC_DEFINE(NEEDS_SYS_TIME_H,1,[Define if sys/time.h is required to get timer definitions])
	else
	    AC_MSG_ERROR([Cannot find the definition of CLOCK_REALTIME for the POSIX timer])
	fi
    fi
    ;;

    gettimeofday)
    MPID_TIMER_TYPE="struct timeval"
    # We may have already tested for gettimeofday.  If we got a "yes",
    # we're good to go
    if test "$ac_cv_func_gettimeofday" != "yes" ; then
        AC_CHECK_FUNC(gettimeofday,,[
         AC_MSG_ERROR([Requested timer gettimeofday is not available])
])
    fi
    ;;

    linux86_cycle|linux86_cycle_2)
    
# The following AC_TRY_RUN statements are needed because x86_64 compilers
# usually know about rdtscp but the cpu may or may not actually implement the
# feature.  This is not cross-compile safe, unfortunately.  In the long run we
# should allow the user to override this with a configure flag.
    AC_CACHE_CHECK([that linux86 cycle counter is available],
        pac_cv_linux86_cycle,
            AC_TRY_RUN([
int main()
{
    /* rdtscp */
    long long var, *var_ptr=&var;
    __asm__ __volatile__("rdtscp; shl \$32, %%rdx; or %%rdx, %%rax" : "=a" (*var_ptr) : : "ecx", "rdx");
    return 0;
}
            ],pac_cv_linux86_cycle=rdtscp,
                AC_TRY_RUN([[
int main()
{
    /* cpuid 64 */
    long long var, *var_ptr=&var;
    __asm__ __volatile__("push %%rbx ; cpuid ; rdtsc ; pop %%rbx ; shl $32, %%rdx; or %%rdx, %%rax" : "=a" (*var_ptr) : : "ecx", "rdx");
    return 0;
}
                ]],pac_cv_linux86_cycle=cpuid_rdtsc64,
                    AC_TRY_RUN([[[
int main()
{
    /* cpuid 32 */
    long long var, *var_ptr=&var;
    __asm__ __volatile__("push %%ebx ; cpuid ; rdtsc ; pop %%ebx" : "=A" (*var_ptr) : : "ecx");
    return 0;
}
                    ]]],pac_cv_linux86_cycle=cpuid_rdtsc32,
                        AC_TRY_RUN([[[[
int main()
{
    /* simple */
    long long var, *var_ptr=&var;
    __asm__ __volatile__("rdtsc" : "=A" (*var_ptr));
    return 0;
}
                        ]]]],pac_cv_linux86_cycle=rdtsc,
                        pac_cv_linux86_cycle=no)
                    )
                ),
dnl The if-cross-compiling clause from the first AC_TRY_RUN.  Hope that if the
dnl compiler knows about the instruction then it's supported by the target
dnl platform.
                AC_TRY_COMPILE(,[[
                    long long var, *var_ptr=&var;
                    __asm__ __volatile__("rdtscp; shl \$32, %%rdx; or %%rdx, %%rax" : "=a" (*var_ptr) : : "ecx", "rdx");
                ]],pac_cv_linux86_cycle=rdtscp,
                    AC_TRY_COMPILE(,[[[
                        long long var, *var_ptr=&var;
                        __asm__ __volatile__("push %%rbx ; cpuid ; rdtsc ; pop %%rbx ; shl $32, %%rdx; or %%rdx, %%rax" : "=a" (*var_ptr) : : "ecx", "rdx");
                    ]]],pac_cv_linux86_cycle=cpuid_rdtsc64,
                        AC_TRY_COMPILE(,[[[[
                            long long var, *var_ptr=&var;
                            __asm__ __volatile__("push %%ebx ; cpuid ; rdtsc ; pop %%ebx" : "=A" (*var_ptr) : : "ecx");
                        ]]]],pac_cv_linux86_cycle=cpuid_rdtsc32,
                            AC_TRY_COMPILE(,[[[[[
                                long long var, *var_ptr=&var;
                                __asm__ __volatile__("rdtsc" : "=A" (*var_ptr));
                            ]]]]],pac_cv_linux86_cycle=rdtsc,
                            pac_cv_linux86_cycle=no)
                        )
                    )
                )
            )
    )

    case "$pac_cv_linux86_cycle" in
        "rdtscp")
            AC_DEFINE(LINUX86_CYCLE_RDTSCP,1,[Define which x86 cycle counter to use])
	    ;;
        "cpuid_rdtsc64")
            AC_DEFINE(LINUX86_CYCLE_CPUID_RDTSC64,1,[Define which x86 cycle counter to use])
            ;;
        "cpuid_rdtsc32")
            AC_DEFINE(LINUX86_CYCLE_CPUID_RDTSC32,1,[Define which x86 cycle counter to use])
	    ;;
        "rdtsc")
            AC_DEFINE(LINUX86_CYCLE_RDTSC,1,[Define which x86 cycle counter to use])
	    ;;
        *)
            cpu_gcc_x86_cycle=no
	    ;;
    esac

    if test "$cpu_gcc_x86_cycle" = "no" ; then
        AC_MSG_ERROR([Linux86 cycle counter is not available on this system and or with the $CC compiler])
    fi
    MPID_TIMER_TYPE="long long"
    ;;

    gcc_ia64_cycle)
    AC_CACHE_CHECK([that IPF timer is available],
pac_cv_ia64_cycle,[
    AC_TRY_COMPILE(,[
    long var, *var_ptr=&var;
#ifdef __INTEL_COMPILER
#include "ia64regs.h"
    var=__getReg(_IA64_REG_AR_ITC);
#else
    __asm__ __volatile__("mov %0=ar.itc" : "=r" (var_ptr));
#endif
],pac_cv_gcc_ia64_cycle=yes,pac_cv_gcc_ia64_cycle=no)])
    if test "$pac_cv_gcc_ia64_cycle" != "yes" ; then
        AC_MSG_ERROR([IPF cycle counter is not available on this system and or with the $CC compiler])
     fi
     MPID_TIMER_TYPE="long"
     ;;

    linuxalpha_cycle)
    AC_MSG_ERROR([linuxalpha_cycle is no longer supported])
    ;;

    mach_absolute_time)
    AC_CHECK_FUNC(mach_absolute_time,,[AC_MSG_ERROR([mach_absolute_time is not available])])
    AC_CHECK_FUNC(mach_timebase_info,,[AC_MSG_ERROR([mach_timebase_info is not available])])
    MPID_TIMER_TYPE="uint64_t"
    ;;

    device)
    # The device selected should export the datatype for the timer
    # in MPID_DEVICE_TIMER_TYPE if something other than long is needed
    if test -n "$MPID_DEVICE_TIMER_TYPE" ; then 
       MPID_TIMER_TYPE=$MPID_DEVICE_TIMER_TYPE
    fi
    ;;

    *)
    AC_MSG_ERROR([Invalid timer type $timer_type])
    ;;
esac
# Convert timer type to upper case
timer_type=`echo $timer_type | \
    tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
MPICH_TIMER_KIND=USE_$timer_type
AC_SUBST(MPICH_TIMER_KIND)
# ----------------------------------------------------------------------------
# End of code for timer support (except for ac_ OUTPUT)
# ----------------------------------------------------------------------------
# Setup other replaceable values
AC_SUBST(MPILIBNAME)
AC_SUBST(PMPILIBNAME)
# Note that aint_size must be used instead of void_p where the desired check
# is on the size of MPI_Aint
aint_size=$ac_cv_sizeof_void_p
if test "$with_aint_size" -gt 0 ; then
   aint_size=$with_aint_size
   if test "$aint_size" != "$ac_cv_sizeof_void_p" ; then
        AC_MSG_RESULT([Overriding MPI_Aint to be $aint_size bytes])
   fi
fi
MPI_AINT=int
for type in int long long_long short ; do
    eval len=\$ac_cv_sizeof_$type
    if test "$len" = "$aint_size" ; then
        MPI_AINT=`echo $type | sed -e 's/_/ /'`
        # Make the sizeof AINT available to other configures
        MPI_SIZEOF_AINT=$len
        export MPI_SIZEOF_AINT
        case $type in
            int)
                MPI_AINT_FMT_DEC_SPEC="%d"
                MPI_AINT_FMT_HEX_SPEC="%x"
                ;;
            long)
                MPI_AINT_FMT_DEC_SPEC="%ld"
                MPI_AINT_FMT_HEX_SPEC="%lx"
                ;;
            long_long)
                MPI_AINT_FMT_DEC_SPEC="%lld"
                MPI_AINT_FMT_HEX_SPEC="%llx"
                ;;
            short)
                MPI_AINT_FMT_DEC_SPEC="%hd"
                MPI_AINT_FMT_HEX_SPEC="%hx"
                ;;
            *)
                AC_MSG_WARN([unable to determine format specifiers for MPI_Aint, defaulting to int])
                MPI_AINT_FMT_DEC_SPEC="%d"
                MPI_AINT_FMT_HEX_SPEC="%x"
            ;;
        esac
        export MPI_AINT_FMT_DEC_SPEC MPI_AINT_FMT_HEX_SPEC
        break
    fi
done
AC_SUBST(MPI_AINT)
AC_SUBST(MPI_AINT_FMT_DEC_SPEC)
AC_SUBST(MPI_AINT_FMT_HEX_SPEC)

# If sizeof(mpi_aint) = sizeof(int), set this value
if test "$ac_cv_sizeof_int" = "$aint_size" ; then
    AC_DEFINE(SIZEOF_INT_IS_AINT,1,[define if sizeof(int) = sizeof(MPI_Aint)])
fi

# Find a pointer-sized int
for type in int long long_long short ; do
    eval len=\$ac_cv_sizeof_$type
    if test "$len" = "$ac_cv_sizeof_void_p" ; then
        case $type in
            int)
                MPIR_PINT_FMT_DEC_SPEC="\"%d\""
                MPIR_UPINT_FMT_DEC_SPEC="\"%u\""
                ;;
            long)
                MPIR_PINT_FMT_DEC_SPEC="\"%ld\""
                MPIR_UPINT_FMT_DEC_SPEC="\"%lu\""
                ;;
            long_long)
                MPIR_PINT_FMT_DEC_SPEC="\"%lld\""
                MPIR_UPINT_FMT_DEC_SPEC="\"%llu\""
                ;;
            short)
                MPIR_PINT_FMT_DEC_SPEC="\"%hd\""
                MPIR_UPINT_FMT_DEC_SPEC="\"%hu\""
                ;;
            *)
                AC_MSG_WARN([unable to determine format specifiers for MPIR_Pint, defaulting to int])
                MPIR_PINT_FMT_DEC_SPEC="\"%d\""
                MPIR_UPINT_FMT_DEC_SPEC="\"%u\""
            ;;
        esac
        MPIR_PINT=`echo $type | sed -e 's/_/ /'`
        break
    fi
done
AC_DEFINE_UNQUOTED(MPIR_Pint,$MPIR_PINT,[MPIR_Pint is a pointer-sized integer])
AC_DEFINE_UNQUOTED(MPIR_PINT_FMT_DEC_SPEC,
    $MPIR_PINT_FMT_DEC_SPEC,[MPIR_PINT_FMT_DEC_SPEC is the format
    specifier for printing Pint as a decimal])
AC_DEFINE_UNQUOTED(MPIR_Upint,unsigned $MPIR_PINT,[MPIR_Upint is an unsigned pointer-sized integer])
AC_DEFINE_UNQUOTED(MPIR_UPINT_FMT_DEC_SPEC,
    $MPIR_UPINT_FMT_DEC_SPEC,[MPIR_UPINT_FMT_DEC_SPEC is the format
    specifier for printing Upint as a decimal])

# ----------------------------------------------------------------------------
# MPI_AINT datatype
# ----------------------------------------------------------------------------
# Must be done after MPI_Aint type determination but before subconfigures.

# convert to 2-char hex size
case "$MPI_SIZEOF_AINT" in
    4)    len_mpi_aint=04 ;;
    8)    len_mpi_aint=08 ;;
    16)   len_mpi_aint=10 ;;
    *)    AC_MSG_ERROR([Unable to convert MPI_SIZEOF_AINT to a hex string.  This is either because we are building on a very strange platform or there is a bug somewhere in configure.]) ;;
esac
# MPI_AINT and MPI_OFFSET are already taken, appending a _DATATYPE suffix
MPI_AINT_DATATYPE=0x4c00${len_mpi_aint}43
AC_SUBST(MPI_AINT_DATATYPE)
export MPI_AINT_DATATYPE

# 0x4c000043 is 1275068483 in decimal, add ($MPI_SIZEOF_AINT * 256) and you get
# the decimal equivalent of the hex number
MPI_F77_AINT=`expr 1275068483 '+' '(' 256 '*' $MPI_SIZEOF_AINT ')'`
AC_SUBST(MPI_F77_AINT)
export MPI_F77_AINT
# ----------------------------------------------------------------------------

# define MPIU_Size_t - used to express the size of objects
# This is used in src/include/mpitypedefs.h to define MPIU_SIZE_T, 
# and is used in various parts of ch3 and mpid/common/sock.  
# This is used to handle the potential problem that a message is 
# too long to fit with an int.  However, we may still need to make
# some more adjustments in the code (this may not be used everywhere
# that it is needed).
#
# FIXME: this should really be in a util configure file, but we don't
# have one at the moment
#
MPIU_SIZE_T="unsigned $MPI_AINT"
AC_DEFINE_UNQUOTED(MPIU_SIZE_T,$MPIU_SIZE_T,[Set to a type that can express the size of the entire address space]) 

if test "$ac_cv_sizeof_void_p" -lt "$aint_size" ; then
    AC_DEFINE(USE_AINT_FOR_ATTRVAL,1,[Define if MPI_Aint should be used instead of void * for storing attribute values])
fi
#
# If it is necessary for the device to update some of the variables,
# this step allows that to happen.  Possible variables to update are
#   LIBS - Add libraries needed for linking
#   LDFLAGS - Add other LD flags (e.g., search paths for libraries)
#   CPPFLAGS - Add C preprocessor flags, including -Idir
#   DEFS  - Add C preprocessor definitions, e.g., -Dfoo
# These must be updated, not replaced, so the setup_device script should
# do, e.g., 
#   LIBS="$LIBS -lmywierdlib",
# not
#   LIBS="-lmywierdlib"
# In some cases (particularly for LIBS), we want to perform this update
# *after* the configure step.  This is done by including the file
# localdefs if it exists.  Note that the use of a file *after* the configure
# of subdirectories means that the subdir configures will not get the 
# value.  This is normally ok for libraries but not for include paths,
# which is why there is a pre and post step
if test -f $devicedir/setup_device ; then
    echo sourcing $devicedir/setup_device
    . $devicedir/setup_device
fi
# See if we need to update the timer type (which was converted to uppercase)
if test "$timer_type" = "DEVICE" ; then
    # The device selected should export the datatype for the timer
    # in MPID_DEVICE_TIMER_TYPE if something other than long is needed
    if test -n "$MPID_DEVICE_TIMER_TYPE" ; then 
       MPID_TIMER_TYPE=$MPID_DEVICE_TIMER_TYPE
    fi
fi

dnl Configure any subdirectories.  Note that config.status will *not* 
dnl reexecute these!
dnl Export any important variables first:
dnl 
dnl Gastly problem.  CONFIG_SUBDIRS only adds the directories to the
dnl list of directories to be configured.  It does NOT control the
dnl timing of the configuration.  For that, we must do something different.
dnl Our original solution was to use a separate macro that does cause 
dnl immediate configure; this macro made use of the code that autoconf 
dnl uses to handle the subdir configure.  However, later versions of 
dnl autoconf did this in a way that caused problems, paritcularly with 
dnl errors reported as inconsistent cache files.  Instead, we simply
dnl invoke the configure scripts (if present) directly.
export AR
export AR_FLAGS
export RANLIB
export MPILIBNAME
export PMPILIBNAME
export CC
export CPPFLAGS
export LIBS
export CXX
export CXXFLAGS
export FFLAGS
export CFLAGS
export FCFLAGS
export LDFLAGS
# Make sure that any Fortran 77 and Fortran 90 compilers are exported to 
# the subdir builds (in particular, ROMIO may try to use the Fortran 90
# compiler to determine the Fortran 90 KINDS for MPI_OFFSET_KIND).
export F77
export FC
#
# -----------------------------------------------------------------------------
# Configure threads first.  This is necessary to obtain all required
# definitions, flags, and libraries that the other subsystems will need
#
# 
# -----------------------------------------------------------------------------
MPIU_THREAD_DEFAULT=${MPIU_THREAD_DEFAULT:-posix}

AC_ARG_WITH([thread-package],
[  --with-thread-package=package     Thread package to use. Supported thread packages include:
        posix or pthreads - POSIX threads
        solaris - Solaris threads (Solaris OS only)
        win - windows threads
        none - no threads

    If the option is not specified, the default package is
    ${MPIU_THREAD_DEFAULT}.  If the option is specified, but a package
    is not given, then the default is posix
],,with_thread_package=${MPIU_THREAD_DEFAULT})

if test "$with_thread_package" = "yes" ; then
   with_thread_package=posix
fi

MPICH2_THREAD_PACKAGE=none
MPIU_THREAD_PACKAGE_NAME=MPIU_THREAD_PACKAGE_INVALID
case $with_thread_package in 
    posix|pthreads)
	with_thread_package=posix
	AC_CHECK_HEADERS(pthread.h)

        # If pthreads library is found, just include it on the link line. We don't try
        # to test if the C compiler needs it or not, since the C++ or Fortran
        # compilers might need it even if the C compiler doesn't
        # (nvcc with gfortran, for example).
        #
        # OSF1 has __pthread_create but not pthread_create (because of
        # inconsistencies in the pthread spec).  Thus, we look for pthread_key_create
        AC_CHECK_LIB([pthread],[pthread_key_create],have_pthreads=yes)
	if test "$have_pthreads" = "yes" ; then
	   PAC_PREPEND_FLAG([-lpthread],[LIBS])
	fi

        AC_CHECK_FUNCS(pthread_yield)

        # this check should come after the AC_CHECK_LIB for -lpthread
        AC_CHECK_FUNC([pthread_key_create],[],[AC_MSG_ERROR([unable to find pthreads library])])

	# Check for a routine that specify a routine to call on 
	# thread exit.  We can use this to release memory that may
	# be allocated by the MPICH2 library in the thread.  
	# A complication: pthread_cleanup_push may be a macro; in that
	# case, check_funcs will fail to find it.
	# Under OSX, pthread_cleanup_push and pop are macros that must
	# appear together in the same lexical scope, and hence are
	# really useless in libraries that may allocate data within 
	# a user-managed thread.
	AC_CHECK_FUNCS(pthread_cleanup_push)
	if test "$ac_cv_func_pthread_cleanup_push" = "no" ; then
            AC_CACHE_CHECK([whether pthread_cleanup_push is available (may be a macro in pthread.h)],pac_cv_func_pthread_cleanup_push,[
	    AC_TRY_LINK([
#include <pthread.h>
void f1(void *a) { return; }],
[pthread_cleanup_push( f1, (void *)0 );],
            pac_cv_func_pthread_cleanup_push=yes,
            pac_cv_func_pthread_cleanup_push=no)])
            if test "$pac_cv_func_pthread_cleanup_push" = yes ; then
	        AC_DEFINE(HAVE_PTHREAD_CLEANUP_PUSH_MACRO,1,[Define if pthread_cleanup_push is available, even as a macro])
            fi
    
        fi
	# Check for PTHREAD_MUTEX_RECURSIVE_NP and PTHREAD_MUTEX_RECURSIVE
	AC_CACHE_CHECK([whether pthread.h defines PTHREAD_MUTEX_RECURSIVE_NP],
	pac_cv_has_pthread_mutex_recursive_np,[
        AC_TRY_COMPILE([#include <pthread.h>],
                       [int a=PTHREAD_MUTEX_RECURSIVE_NP;],
		       pac_cv_has_pthread_mutex_recursive_np=yes,
		       pac_cv_has_pthread_mutex_recursive_np=no)])
	AC_CACHE_CHECK([whether pthread.h defines PTHREAD_MUTEX_RECURSIVE],
	pac_cv_has_pthread_mutex_recursive,[
        AC_TRY_COMPILE([#include <pthread.h>],
                       [int a=PTHREAD_MUTEX_RECURSIVE;],
		       pac_cv_has_pthread_mutex_recursive=yes,
		       pac_cv_has_pthread_mutex_recursive=no)])
        if test "$pac_cv_has_pthread_mutex_recursive_np" = yes ; then
	    AC_DEFINE(HAVE_PTHREAD_MUTEX_RECURSIVE_NP,1,[Define if PTHREAD_MUTEX_RECURSIVE_NP is available in pthread.h])
	fi		       
        if test "$pac_cv_has_pthread_mutex_recursive" = yes ; then
	    AC_DEFINE(HAVE_PTHREAD_MUTEX_RECURSIVE,1,[Define if PTHREAD_MUTEX_RECURSIVE is available in pthread.h])
	fi		       

        # Check for PTHREAD_MUTEX_ERRORCHECK_NP and PTHREAD_MUTEX_ERRORCHECK
        AC_CACHE_CHECK([whether pthread.h defines PTHREAD_MUTEX_ERRORCHECK_NP],
        pac_cv_has_pthread_mutex_errorcheck_np,[
        AC_TRY_COMPILE([#include <pthread.h>],
                       [int a=PTHREAD_MUTEX_ERRORCHECK_NP;],
                       pac_cv_has_pthread_mutex_errorcheck_np=yes,
                       pac_cv_has_pthread_mutex_errorcheck_np=no)])
        AC_CACHE_CHECK([whether pthread.h defines PTHREAD_MUTEX_ERRORCHECK],
        pac_cv_has_pthread_mutex_errorcheck,[
        AC_TRY_COMPILE([#include <pthread.h>],
                       [int a=PTHREAD_MUTEX_ERRORCHECK;],
                       pac_cv_has_pthread_mutex_errorcheck=yes,
                       pac_cv_has_pthread_mutex_errorcheck=no)])

        if test "$pac_cv_has_pthread_mutex_errorcheck" = yes ; then
            AC_DEFINE(PTHREAD_MUTEX_ERRORCHECK_VALUE,PTHREAD_MUTEX_ERRORCHECK,
                      [Define to an expression that will result in an error checking mutex type.])
        elif test "$pac_cv_has_pthread_mutex_errorcheck_np" = yes ; then
            AC_DEFINE(PTHREAD_MUTEX_ERRORCHECK_VALUE,PTHREAD_MUTEX_ERRORCHECK_NP,
                      [Define to an expression that will result in an error checking mutex type.])
        fi

	MPICH2_THREAD_PACKAGE=pthreads
        MPIU_THREAD_PACKAGE_NAME=MPIU_THREAD_PACKAGE_POSIX
	;;
    solaris)
	AC_CHECK_HEADERS(thread.h)
	AC_CHECK_FUNCS(thr_yield)
	AC_SEARCH_LIBS(thr_create,thread,found=yes,found=no)
	if test "$found" != "yes" ; then
	   AC_MSG_ERROR([unable to find Solaris threads library])
	fi
	# FIXME: need to add -mt if using solaris compilers
	MPICH2_THREAD_PACKAGE=solaris
        MPIU_THREAD_PACKAGE_NAME=MPIU_THREAD_PACKAGE_SOLARIS
	;;
    win|windows)
        with_thread_package=win
        MPICH2_THREAD_PACKAGE=win
        MPIU_THREAD_PACKAGE_NAME=MPIU_THREAD_PACKAGE_WIN
        AC_MSG_ERROR([The 'win' thread package is not supported via autoconf builds at this time.])
        ;;
    no|none)
	with_thread_package=none
        MPIU_THREAD_PACKAGE_NAME=MPIU_THREAD_PACKAGE_NONE
	;;
    *)
	AC_MSG_ERROR([The specified thread package, $with_thread_package, is not supported.]) 
	;;
esac

# Define and export the selected thread library so that other packages, 
# such as MPE, will know what's used in MPICH2
export MPICH2_THREAD_PACKAGE
AC_DEFINE_UNQUOTED([MPIU_THREAD_PACKAGE_NAME],[$MPIU_THREAD_PACKAGE_NAME],[set to the name of the thread package])

# check for compiler-support for thread-local storage (MPIU_TLS_SPECIFIER)
AX_TLS

AC_CHECK_HEADERS(sched.h)
AC_CHECK_FUNCS(sched_yield yield usleep sleep select getpid)

# Check for the Linux functions for controlling processor affinity.
# LINUX: sched_setaffinity
# AIX:   bindprocessor
# OSX (Leopard): thread_policy_set
AC_CHECK_FUNCS(sched_setaffinity sched_getaffinity bindprocessor thread_policy_set)
if test "$ac_cv_func_sched_setaffinity" = "yes" ; then
    # Test for the cpu process set type
    AC_CACHE_CHECK([whether cpu_set_t available],pac_cv_have_cpu_set_t,[
    AC_TRY_COMPILE( [
#include <sched.h>],[ cpu_set_t t; ],pac_cv_have_cpu_set_t=yes,pac_cv_have_cpu_set_t=no)])
    if test "$pac_cv_have_cpu_set_t" = yes ; then
        AC_DEFINE(HAVE_CPU_SET_T,1,[Define if cpu_set_t is defined in sched.h])

	AC_CACHE_CHECK([whether the CPU_SET and CPU_ZERO macros are defined],
	pac_cv_cpu_set_defined,[
        AC_TRY_LINK( [
#include <sched.h>],[ cpu_set_t t; CPU_ZERO(&t); CPU_SET(1,&t); ],
        pac_cv_cpu_set_defined=yes,pac_cv_cpu_set_defined=no)])
	if test "$pac_cv_cpu_set_defined" = "yes" ; then
	    AC_DEFINE(HAVE_CPU_SET_MACROS,1,[Define if CPU_SET and CPU_ZERO defined])
        fi
	# FIXME: Some versions of sched_setaffinity return ENOSYS (!), 
	# so we should test for the unfriendly and useless behavior
    fi
fi
if test "$ac_cv_func_thread_policy_set" = yes ; then
    AC_CACHE_CHECK([whether thread affinity macros defined],
    pac_cv_have_thread_affinity_policy,[
    AC_TRY_COMPILE([#include <mach/thread_policy.h>],[
#if !defined(THREAD_AFFINITY_POLICY) || !defined(THREAD_AFFINITY_TAG_NULL)
    :'thread macros not defined
],pac_cv_have_thread_affinity_policy=yes,
  pac_cv_have_thread_affinity_policy=no)])
    if test "$pac_cv_have_thread_affinity_policy" = yes ; then
        AC_DEFINE(HAVE_OSX_THREAD_AFFINITY,1,[Define is the OSX thread affinity policy macros defined])
    fi
fi

MPIU_THREAD_LIB_NAME=${MPILIBNAME}
AC_SUBST(MPIU_THREAD_LIB_NAME)

# -----------------------------------------------------------------------------
# End of thread configure
# -----------------------------------------------------------------------------


# Checkpointing
AC_ARG_ENABLE(checkpointing,
    [AC_HELP_STRING([--enable-checkpointing], [Enable application checkpointing])],
    [ if test "$enableval" != "no" ; then
        PAC_SET_HEADER_LIB_PATH(blcr)
	PAC_CHECK_HEADER_LIB_FATAL(blcr, libcr.h, cr, cr_init)
        AC_DEFINE(ENABLE_CHECKPOINTING,1,[Application checkpointing enabled])
      fi ],
)

# Update the cache first with the results of the previous configure steps
# We don't use the subdir cache because ensuring that the cache is consistant
# with the way in which configure wishes to use it is very difficult and 
# too prone to error.
dnl PAC_SUBDIR_CACHE(always)
# -----------------------------------------------------------------------------
# experiment with creating a cache file
#if test "$CONF_USE_CACHEFILE" = yes ; then
#    basecachefile=`pwd`/cache.base
#    set | grep ac_cv > $basecachefile
#    # Tell other configures to load this file
#    echo "Creating and exporting the base cache file $basecachefile"
#    CONF_BASE_CACHEFILE=$basecachefile
#    export CONF_BASE_CACHEFILE
#fi
PAC_CREATE_BASE_CACHE
# -----------------------------------------------------------------------------

#
# Configure the device second.  This way, any libraries or variables that
# it needs can be extracted before building the other subsystems (this is
# particularly important for the bindings, which may need to know the
# libraries in order to create the compilation scripts)

user_specified_atomic_primitives=no
if test "$DEBUG_SUBDIR_CACHE" = yes ; then 
    set -x
fi
for subsys in $devsubsystems $subsystems ; do 
    PAC_CONFIG_SUBDIR($subsys,,AC_ERROR($subsys configure failed))
done 
if test "$DEBUG_SUBDIR_CACHE" = yes -a "$enable_echo" != yes ; then 
    set +x
fi
dnl PAC_SUBDIR_CACHE_CLEANUP

## The MPE configure requires MPI_LIBS, and that requires all of the LIBS
#MPI_LIBS="$MPI_LIBS $LIBS"
#
# Get any localdefs that the subsystems created. Use a guard in case
# the list is empty
#for dir in $subsystems /dev/null ; do 
#    if test -f $dir/localdefs ; then
#        . $dir/localdefs
#    fi
#done
#
# Make subsystems available to makefiles.
subsystems="$devsubsystems $subsystems $bindingsubsystems"
AC_SUBST(subsystems)

# Find the size of OPA_ptr_t. This step needs to come after the OPA
# configure above in order to get the size OPA_ptr_t evaluated for
# this platform.
AC_CHECK_SIZEOF(OPA_ptr_t,-1,[
#include "${master_top_srcdir}/src/openpa/src/opa_primitives.h"
pthread_mutex_t *OPA_emulation_lock;
])

if test "$enable_f77" != "yes" ; then
    # These are Fortran datatypes ONLY.  Set to null if no Fortran compiler.
    for name in CHARACTER INTEGER REAL LOGICAL COMPLEX DOUBLE_PRECISION \
	2INTEGER 2REAL DOUBLE_COMPLEX 2COMPLEX 2DOUBLE_PRECISION \
	2DOUBLE_COMPLEX ; do
	fullname="MPI_$name"
	eval $fullname=MPI_DATATYPE_NULL
    done
    AC_MSG_WARN([Could not define Fortran MPI datatypes for C])
    AC_DEFINE(HAVE_NO_FORTRAN_MPI_TYPES_IN_C,1,[Define if the Fortran types are not available in C])
    # Temporary values for MPI_Fint (need help from the Fortran subsystem)
    MPI_FINT=int
fi
AC_SUBST(MPI_CHARACTER)
AC_SUBST(MPI_INTEGER)
AC_SUBST(MPI_REAL)
AC_SUBST(MPI_LOGICAL)
AC_SUBST(MPI_COMPLEX)
AC_SUBST(MPI_DOUBLE_PRECISION)
AC_SUBST(MPI_2INTEGER)
AC_SUBST(MPI_2REAL)
AC_SUBST(MPI_DOUBLE_COMPLEX)
AC_SUBST(MPI_2DOUBLE_PRECISION)
AC_SUBST(MPI_2COMPLEX)
AC_SUBST(MPI_2DOUBLE_COMPLEX)
AC_SUBST(MPI_FINT)

# If ROMIO was successfully configured, then ROMIO will have exported the
# definition of MPI_OFFSET_TYPE through its localdefs file (created by the
# ROMIO configure in src/mpi/romio/localdefs).  If MPI_OFFSET_TYPE was not
# defined, this code attempts to find a good choice for MPI_OFFSET_TYPE
# (As the offset type is used for File operations, the specific type
# really doesn't matter if ROMIO doesn't provide it).
if test -n "$MPI_OFFSET_TYPE" ; then
    # We got the value from the ROMIO configure
    MPI_OFFSET="$MPI_OFFSET_TYPE"
    # Get and export the size of this type if possible
    if test -z "$MPI_SIZEOF_OFFSET" ; then 
        # set a default
        AC_CACHE_CHECK([the sizeof MPI_Offset],ac_cv_sizeof_MPI_Offset,[
            ac_cv_sizeof_MPI_Offset=unknown
            AC_COMPUTE_INT([ac_cv_sizeof_MPI_Offset],[sizeof($MPI_OFFSET)],[],[
                AC_MSG_WARN([Unable to determine the size of MPI_Offset])
            ])
	])
	if test "$ac_cv_sizeof_MPI_Offset" != "unknown" ; then 
  	    MPI_SIZEOF_OFFSET=$ac_cv_sizeof_MPI_Offset
        fi
    fi
    export MPI_SIZEOF_OFFSET
else
    # Make a guess at the appropriate definition for offset.  Try to 
    # find a 64bit type.
    if test "$ac_cv_sizeof_long" = 8 ; then
        MPI_OFFSET="long"
	# Make the size of this type available to other configures
	MPI_SIZEOF_OFFSET=8
    elif test "$ac_cv_sizeof_long_long" = 8 ; then
        MPI_OFFSET="long long"
	# Make the size of this type available to other configures
	MPI_SIZEOF_OFFSET=8
    else
        MPI_OFFSET=long
        MPI_SIZEOF_OFFSET=$ac_cv_sizeof_long
    fi
    export MPI_SIZEOF_OFFSET
fi
AC_SUBST(MPI_OFFSET)
#
# FIXME: we need an explanation of why we need both MPI_OFFSET and 
# MPI_OFFSET_TYPEDEF.   Why is MPI_OFFSET_TYPEDEF necessary?
# This appears to be used by the Windows "winconfigure.wsf" which is used
# to create a multiline definition using an #ifdef check on USE_GCC 
# We may wish to use a different approach
MPI_OFFSET_TYPEDEF="typedef $MPI_OFFSET MPI_Offset;"
AC_SUBST(MPI_OFFSET_TYPEDEF)
#
# Fortran type for an Offset type (needed to define MPI_DISPLACEMENT_CURRENT
# The value for this comes from ROMIO, and is needed in mpif.h.in
# First, we check that this works with both Fortran compilers (if
# they are defined)
#
# If there is no FORTRAN_MPI_OFFSET type (because ROMIO is disabled),
# just use INTEGER
if test -z "$FORTRAN_MPI_OFFSET" ; then
    FORTRAN_MPI_OFFSET=INTEGER
fi
if test "$enable_f77" = yes -a "$enable_fc" = yes ; then
    AC_LANG_PUSH([Fortran 77])
    AC_MSG_CHECKING([whether the Fortran Offset type works with Fortran 77])
    AC_COMPILE_IFELSE([
        AC_LANG_PROGRAM([],[      $FORTRAN_MPI_OFFSET i])
    ],[has_f77_offsettype=yes],[has_f77_offsetype=no])
    AC_MSG_RESULT($has_f77_offsettype)
    AC_LANG_POP([Fortran 77])

    AC_LANG_PUSH([Fortran])
    AC_MSG_CHECKING([whether the Fortran Offset type works with Fortran 90])
    AC_COMPILE_IFELSE([
        AC_LANG_PROGRAM([],[      $FORTRAN_MPI_OFFSET i])
    ],[has_fc_offsettype=yes],[has_fc_offsetype=no])
    AC_LANG_POP([Fortran])
    AC_MSG_RESULT($has_fc_offsettype)

    if test "$has_f77_offsettype" != yes -o "$has_fc_offsettype" != yes ; then
        AC_MSG_WARN([mpif.h is not compatible with both $F77 $FFLAGS and $FC $FCFLAGS.  We recommend that you set both F77 and FC to the same compiler and reconfigure.])
    fi
fi
AC_SUBST(FORTRAN_MPI_OFFSET)
#

# ----------------------------------------------------------------------------
# MPI_OFFSET datatype
# ----------------------------------------------------------------------------
# must be done after ROMIO configure step
case "$MPI_SIZEOF_OFFSET" in
    4)    len_mpi_offset=04 ;;
    8)    len_mpi_offset=08 ;;
    16)   len_mpi_offset=10 ;;
    *)    AC_MSG_ERROR([Unable to convert MPI_SIZEOF_OFFSET to a hex string.  This is either because we are building on a very strange platform or there is a bug somewhere in configure.]) ;;
esac
MPI_OFFSET_DATATYPE=0x4c00${len_mpi_offset}44
AC_SUBST(MPI_OFFSET_DATATYPE)
export MPI_OFFSET_DATATYPE

# 0x4c000044 is 1275068484 in decimal, add ($MPI_SIZEOF_OFFSET * 256) and you get
# the decimal equivalent of the hex number
MPI_F77_OFFSET=`expr 1275068484 '+' '(' 256 '*' $MPI_SIZEOF_OFFSET ')'`
AC_SUBST(MPI_F77_OFFSET)
export MPI_F77_OFFSET
# ----------------------------------------------------------------------------

dnl Extra status information, from device subsystem, to be included in the
dnl declaration of MPI_Status in mpi.h.in
AC_SUBST(EXTRA_STATUS_DECL)
#
# See if we can support the type create functions that take 
# precision and exponent range.  These need are determined by running
# a configure script in the f90 test directory
if test "$enable_f77" = yes -a "$enable_fc" = yes ; then
    # Create the local directory
    if test ! -d src ; then mkdir src ; fi
    if test ! -d src/binding ; then mkdir src/binding ; fi
    if test ! -d src/binding/f90 ; then mkdir src/binding/f90 ; fi
    export F77
    export FC
    echo "Running Configure for Fortran 90 Type routines"
    # Include any options passed to the top-level configure
    ac_sub_configure_args=""
    # Strip off the args that we need to update
    for ac_arg in $ac_configure_args ; do
	# Remove any quotes around the args (added by configure)
	ac_narg=`expr x$ac_arg : 'x'"'"'\(.*\)'"'"`
	if test -n "$ac_narg" ; then ac_arg=$ac_narg ; fi	    
	case $ac_arg in 
	    -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
               | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* \
               | --c=*) ;;
               --config-cache | -C)
	    ;;
            -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*) ;;
	    -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
    	    ;;
	-*)
        ac_sub_configure_args="$ac_sub_configure_args $ac_arg" 
	;;

dnl Here's the problem.  If the user sets a few of the special variables
dnl such as CPPFLAGS, those original settings will override the
dnl updated values.  Here's an attempt at a fix
        CPPFLAGS=*)
	ac_sub_configure_args="$ac_sub_configure_args 'CPPFLAGS=$CPPFLAGS'"
        ;;

    	*) 
	    ac_sub_configure_args="$ac_sub_configure_args $ac_arg" ;;
	    esac
        done

	# add in the correct prefix argument
        ac_sub_configure_args="--prefix=$prefix $ac_sub_configure_args"
    
    # The eval below is needed to properly quote the sub-configure arguments.
    # Thanks to Steve Oyanagi at Cray for spotting it when it was missing.
    (cd src/binding/f90 && \
     eval $master_top_srcdir/src/binding/f90/configure $ac_sub_configure_args)
    rc=$?
    if test $rc = 0 ; then
        AC_DEFINE(HAVE_FC_TYPE_ROUTINES,1,
                  [Define if Fortran 90 type routines available])
    else
        AC_MSG_WARN([Unable to determine Fortran 90 type support; defaults used])
    fi
fi
# -----------------------------------------------------------------------------
# Get the value of MPI_MAX_PROCESSOR_NAME
if test -z "$MPID_MAX_PROCESSOR_NAME" ; then
    if test -z "$MPI_MAX_PROCESSOR_NAME" ; then
       MPI_MAX_PROCESSOR_NAME=128
    fi
    AC_MSG_WARN([The $with_device device did not set the maximum size of a processor name, $MPI_MAX_PROCESSOR_NAME being used.])
else
    MPI_MAX_PROCESSOR_NAME=$MPID_MAX_PROCESSOR_NAME
fi
AC_SUBST(MPI_MAX_PROCESSOR_NAME)

# Add a definition that is used to help support Windows DLLs (used in mpi.h.in)
MPIU_DLL_SPEC_DEF="#define MPIU_DLL_SPEC"
AC_SUBST(MPIU_DLL_SPEC_DEF)

dnl We can include external packages at configure/build time by 
dnl adding them to EXTERNAL_SRC_DIRS.
AC_SUBST(EXTERNAL_SRC_DIRS)

dnl We can configure the test directory after the rest of the configure 
dnl steps because it does not depend on them.
# set and export values that the test/mpi configure will reference to ensure
# that the correct decisions are made since this configure happens before the
# MPICH2 library is built. 
MPICH2_ENABLE_CXX=$enable_cxx
MPICH2_ENABLE_F77=$enable_f77
MPICH2_ENABLE_FC=$enable_fc
export MPICH2_ENABLE_CXX
export MPICH2_ENABLE_F77
export MPICH2_ENABLE_FC
# MPI_SRCDIR gives the test/mpi configure the location of the source
# files for an MPI implementation
if test -n "$ac_abs_srcdir" ; then
    MPI_SRCDIR=$ac_abs_srcdir
fi
# Pass these two values with "MPI" names to the test configure
MPI_NO_SPAWN=$MPID_NO_SPAWN
export MPI_NO_SPAWN
MPI_NO_RMA=$MPID_NO_RMA
export MPI_NO_RMA
AC_CONFIG_SUBDIRS(test/mpi)
dnl
dnl Generate the Makefiles from Makefile.in
dnl Also generate mpi.h from mpi.h.in so that we can eliminate all ifdefs
dnl from the file.
dnl
dnl Run a setup command for any external modules (normally, this is empty)
dnl Pass a subset of the environment to the invoked process.
AC_OUTPUT_COMMANDS([
for prog in $EXTERNAL_SETUPS - ; do
    if test "$prog" != "-" ; then 
      dir=`dirname $prog`
      name=`basename $prog`
      (cd $dir && ./$name)
    fi
done],[
EXTERNAL_SETUPS="$EXTERNAL_SETUPS"
LIBDIR="$libbuild_dir"
MPILIBNAME="$MPILIBNAME"
PMPILIBNAME="$PMPILIBNAME"
AR="$AR"
CC="$CC"
CC_SHL="$CC_SHL"
CPPFLAGS="$CPPFLAGS"
CFLAGS="$CFLAGS"
ENABLE_SHLIB="$ENABLE_SHLIB"
export LIBDIR ; export MPILIBNAME ; export AR ; export CC ; export CPPFLAGS 
export PMPILIBNAME 
export CFLAGS ; export CC_SHL ; export ENABLE_SHLIB ; export C_LINKPATH_SHL
# For test/mpi/configure
MPI_SRCDIR=$MPI_SRCDIR
MPI_NO_SPAWN=$MPID_NO_SPAWN
export MPI_SRCDIR
export MPI_NO_SPAWN
])

if test -z "$includebuild_dir" ; then
    includebuild_dir=`pwd`/src/include
fi
if test -z "$libbuild_dir" ; then
    libbuild_dir=`pwd`/lib
fi
if test -z "$modincbuild_dir" ; then
    # The include files may be in a different directory from the mpif.h file
    modincbuild_dir=`pwd`/src/binding/f90
fi

dnl create a copy of mpicc in the build directory that will work for compiling
dnl MPI programs without requiring installation
AC_OUTPUT_COMMANDS([
if test "$bashWorks" = yes ; then cp -f src/env/mpicc.bash src/env/mpicc ; fi
chmod a+x src/env/mpicc ;
if test ! -d bin  ; then mkdir bin ; fi 
sed -e 's%includedir=.*%includedir='$includebuild_dir% \
    -e 's%libdir=.*%libdir='$libbuild_dir% \
    src/env/mpicc > bin/mpicc ;
chmod a+x bin/mpicc ],
includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir
bashWorks=$bashWorks)

# Move the mpio.h file into the build directories for testing
#export top_srcdir
#export enable_romio
AC_OUTPUT_COMMANDS([if test "$enable_romio" = "yes" ; then
  rm -f src/include/mpio.h "${use_top_srcdir}/include/mpio.h"
  cp src/mpi/romio/include/mpio.h src/include ; fi],enable_romio=$enable_romio
top_srcdir=$top_srcdir)

dnl
dnl If dependencies are enabled in the updatefiles/simplemake step, then
dnl we must generate the dependency directories.  We do this by detecting 
dnl the dependencies target.  Note that this refers to the Makefile,
dnl in case we are building with VPATH
dnl Grr. Finds differ on how they handle {} in a string.  We could use
dnl xargs, but that may not be standard enough.  Instead we fall back on 
dnl the old standby of using find with -print, then sed to
dnl construct the line, which is fed to sh
dnl
dnl Note that once dependencies are enabled, we always try to
dnl update the dependencies (that is usually the desired behavior)
dnl    find . -type d -exec sh -c '(cd {} && grep MAKE_DEPEND_C Makefile >/dev/null 2>&1 && ( test -d .deps || mkdir .deps ) && touch .deps/alldeps )' \;
dnl We only apply this to src, as that is the only directory that 
dnl contains the source files for MPICH2; this avoids running through the
dnl test directories, for example.
AC_OUTPUT_COMMANDS([if grep 'dependencies:' Makefile >/dev/null 2>&1 ; then
    echo "Updating dependency directories .deps" 
    find src -type d -print | sed -e 's%\(.*\)%(cd \1 \&\& grep MAKE_DEPEND_C Makefile >/dev/null 2>\&1 \&\& ( test -d .deps || mkdir .deps) \&\& touch .deps/alldeps)%g' | sh
fi])

AC_OUTPUT_COMMANDS([chmod +x doc/mansrc/createhtmlindex])

dnl
dnl If we rerun configure, place a file in the lib directory with the
dnl date.  We can use this to avoid rebuilding the library when
dnl a build aborts due to an error (this is intended to help developers)
AC_OUTPUT_COMMANDS([if [ ! -d lib ] ; then mkdir lib ; fi 
date > lib/newconfig])

AC_OUTPUT_COMMANDS([chmod +x src/util/createshlib])
AC_OUTPUT_COMMANDS([chmod a+x src/util/dbg/getfuncstack])

AC_OUTPUT_COMMANDS([chmod a+x test/commands/cmdtests])


# For the examples, we want to use the scripts to encourage users
# to use them and to make them work more robustly with shared libraries
# and, for Fortran 90, any special Fortran 90 module features.
if test -z "$MPICC" ; then MPICC='$(bindir)/mpicc' ; fi
if test -z "$MPIF77" ; then MPIF77='$(bindir)/mpif77' ; fi
if test -z "$MPIFC" ; then MPIFC='$(bindir)/mpif90' ; fi
if test -z "$MPICXX" ; then MPICXX='$(bindir)/mpicxx' ; fi
AC_SUBST(MPICC)
AC_SUBST(MPICXX)
AC_SUBST(MPIF77)
AC_SUBST(MPIFC)

AC_DEFINE(HAVE_MPICHCONF,1,[Define so that we can test whether the mpichconf.h file has been included])

# Add the LDFLAGS/LIBS we got so far to WRAPPERs
WRAPPER_LDFLAGS="$WRAPPER_LDFLAGS $LDFLAGS"
WRAPPER_LIBS="$WRAPPER_LIBS $LIBS"

# Setup required inter-library dependencies
LIB_DEPS=""
LDFLAGS_DEPS=""
if test "$ENABLE_SHLIB" != "none" -a "$enable_lib_depend" = "yes" ; then
   LIB_DEPS="$WRAPPER_LIBS"
   WRAPPER_LIBS=""
   LDFLAGS_DEPS="$WRAPPER_LDFLAGS"
   # WRAPPER_LDFLAGS are not reset as they point to the position of
   # the dependency libraries when rpath builds are not enabled
fi
AC_SUBST(LIB_DEPS)
AC_SUBST(LDFLAGS_DEPS)

if test "$USE_PMI2_API" = "yes" ; then
   AC_DEFINE(USE_PMI2_API, 1, [Define if PMI2 API must be used])
fi

dnl This includes an experimental pkgconfig file for ch3 in the src/pkgconfig
dnl directory
AC_OUTPUT(Makefile src/Makefile src/include/Makefile \
	  src/include/mpich2info.h \
	  mpich2-doxygen \
          src/include/mpichtimer.h \
          src/binding/Makefile \
          src/binding/cxx/Makefile \
          src/binding/cxx/mpicxx.h \
	  src/binding/f77/Makefile \
	  src/binding/f77/mpif.h \
	  src/binding/f77/setbotf.f \
	  src/binding/f77/setbot.c \
	  src/binding/f90/Makefile \
	  src/binding/f90/mpi_sizeofs.f90 \
	  src/binding/f90/mpi_base.f90 \
	  src/packaging/Makefile \
	  src/packaging/pkgconfig/mpich2-c.pc \
	  src/packaging/pkgconfig/mpich2-cxx.pc \
	  src/packaging/pkgconfig/mpich2-f77.pc \
	  src/packaging/pkgconfig/mpich2-f90.pc \
	  src/packaging/pkgconfig/Makefile \
	  src/packaging/envmods/mpich2.module \
	  src/packaging/envmods/Makefile \
          src/env/mpixxx_opts.conf \
          src/env/mpicc \
	  src/env/mpicc.conf \
	  src/env/mpicc.bash \
          src/env/mpicxx \
	  src/env/mpicxx.conf \
	  src/env/mpicxx.bash \
	  src/env/mpif77 \
	  src/env/mpif77.conf \
	  src/env/mpif77.bash \
	  src/env/mpif90 \
	  src/env/mpif90.conf \
	  src/env/mpif90.bash \
	  src/env/Makefile\
	  src/util/createshlib \
          src/mpi/Makefile \
          src/mpi/attr/Makefile \
	  src/mpi/coll/Makefile \
          src/mpi/comm/Makefile \
	  src/mpi/datatype/Makefile \
	  src/mpi/debugger/Makefile \
          src/mpi/errhan/Makefile \
          src/mpi/group/Makefile \
          src/mpi/init/Makefile \
          src/mpi/misc/Makefile \
          src/mpi/pt2pt/Makefile \
          src/mpi/rma/Makefile \
          src/mpi/spawn/Makefile \
          src/mpi/timer/Makefile \
          src/mpi/topo/Makefile \
          src/mpix/Makefile \
          src/mpix/comm/Makefile \
          src/mpid/Makefile \
          src/mpid/common/Makefile \
          src/mpid/common/datatype/Makefile \
          src/mpid/common/datatype/dataloop/Makefile \
          src/pm/Makefile \
          src/pmi/Makefile \
          src/pmi/${pmi_name}/Makefile \
	  src/nameserv/Makefile \
	  src/nameserv/file/Makefile \
	  src/nameserv/mpd/Makefile \
	  src/nameserv/pmi/Makefile \
	  src/nameserv/test/Makefile \
	  src/util/Makefile \
	  src/util/info/Makefile \
	  src/util/instrm/Makefile \
	  src/util/thread/Makefile \
	  src/util/mem/Makefile \
	  src/util/msgs/Makefile \
	  src/util/param/Makefile \
          src/util/dbg/Makefile \
	  src/util/dbg/getfuncstack \
	  src/util/osserv/Makefile \
	  src/util/procmap/Makefile \
	  src/util/other/Makefile \
          src/include/mpi.h \
	  test/Makefile test/util/Makefile \
	  test/basic/Makefile \
	  test/commands/Makefile \
	  test/commands/cmdtests \
	  test/mpid/Makefile \
	  test/mpid/ch3/Makefile \
	  test/util/timer/Makefile \
	  examples/Makefile \
	  examples/f77/Makefile \
	  examples/f90/Makefile \
	  examples/cxx/Makefile \
          src/util/logging/Makefile \
          src/util/logging/common/Makefile \
	  doc/Makefile doc/mansrc/Makefile \
	  doc/mansrc/createhtmlindex \
	  doc/refman/Makefile \
	  doc/installguide/Makefile \
	  doc/userguide/Makefile \
	  doc/logging/Makefile \
	  doc/design/Makefile \
	  doc/smpd/Makefile \
	  doc/windev/Makefile )

echo 'Configuration completed.'
